<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: readability | Trey Hunner]]></title>
  <link href="https://treyhunner.com/blog/categories/readability/atom.xml" rel="self"/>
  <link href="https://treyhunner.com/"/>
  <updated>2024-05-23T10:11:24-07:00</updated>
  <id>https://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Overusing list comprehensions and generator expressions in Python]]></title>
    <link href="https://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python/"/>
    <updated>2019-03-26T13:30:00-07:00</updated>
    <id>https://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python</id>
    <content type="html"><![CDATA[<p>List comprehensions are one of my favorite features in Python.
I love list comprehensions so much that I&rsquo;ve written an <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">article</a> about them, done <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">a talk</a> about them, and held a <a href="https://youtu.be/_6U1XoxyyBY" title="Using List Comprehensions and Generator Expressions For Data Processing">3 hour comprehensions tutorial</a> at PyCon 2018.</p>

<p>While I love list comprehensions, I&rsquo;ve found that once new Pythonistas start to really appreciate comprehensions they tend to use them everywhere.
<strong>Comprehensions are lovely, but they can easily be overused</strong>!</p>

<p>This article is all about cases when comprehensions aren&rsquo;t the best tool for the job, at least in terms of readability.
We&rsquo;re going to walk through a number of cases where there&rsquo;s a more readable alternative to comprehensions and we&rsquo;ll also see some not-so-obvious cases where comprehensions aren&rsquo;t needed at all.</p>

<p>This article isn&rsquo;t meant to scare you off from comprehensions if you&rsquo;re not already a fan; it&rsquo;s meant to encourage moderation for those of us (myself included) who need it.</p>

<p><strong>Note</strong>: In this article, I&rsquo;ll be using the term &ldquo;comprehension&rdquo; to refer to all forms of comprehensions (list, set, dict) as well as generator expressions.
If you&rsquo;re unfamiliar with comprehensions, I recommend reading <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">this article</a> or watching <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">this talk</a> (the talk dives into generator expressions a bit more deeply).</p>

<ul data-toc=".entry-content"></ul>


<h2>Writing comprehensions with poor spacing</h2>

<p>Critics of list comprehensions often say they&rsquo;re hard to read.
And they&rsquo;re right, many comprehensions <em>are</em> hard to read.
<strong>Sometimes all a comprehension needs to be more readable is better spacing</strong>.</p>

<p>Take the comprehension in this function:</p>

<pre><code class="python">def get_factors(dividend):
    """Return a list of all factors of the given number."""
    return [n for n in range(1, dividend+1) if dividend % n == 0]
</code></pre>

<p>We could make that comprehension more readable by adding some well-placed line breaks:</p>

<pre><code class="python">def get_factors(dividend):
    """Return a list of all factors of the given number."""
    return [
        n
        for n in range(1, dividend+1)
        if dividend % n == 0
    ]
</code></pre>

<p>Less code can mean more readable code, but not always.
<strong>Whitespace is your friend, especially when you&rsquo;re writing comprehensions</strong>.</p>

<p>In general, I prefer to write most of my comprehensions <strong>spaced out over multiple lines of code</strong> using the indentation style above.
I do write one-line comprehensions sometimes, but I don&rsquo;t default to them.</p>

<h2>Writing ugly comprehensions</h2>

<p>Some loops technically <em>can</em> be written as comprehensions but they have so much logic in them they probably <em>shouldn&rsquo;t</em> be.</p>

<p>Take this comprehension:</p>

<pre><code class="python">fizzbuzz = [
    f'fizzbuzz {n}' if n % 3 == 0 and n % 5 == 0
    else f'fizz {n}' if n % 3 == 0
    else f'buzz {n}' if n % 5 == 0
    else n
    for n in range(100)
]
</code></pre>

<p>This comprehension is equivalent to this <code>for</code> loop:</p>

<pre><code class="python">fizzbuzz = []
for n in range(100):
    fizzbuzz.append(
        f'fizzbuzz {n}' if n % 3 == 0 and n % 5 == 0
        else f'fizz {n}' if n % 3 == 0
        else f'buzz {n}' if n % 5 == 0
        else n
    )
</code></pre>

<p>Both the comprehension and the <code>for</code> loop use three nested <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator">inline if statements</a> (Python&rsquo;s <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a>).</p>

<p>Here&rsquo;s a more readable way to write this code, using an <code>if-elif-else</code> construct:</p>

<pre><code class="python">fizzbuzz = []
for n in range(100):
    if n % 3 == 0 and n % 5 == 0:
        fizzbuzz.append(f'fizzbuzz {n}')
    elif n % 3 == 0:
        fizzbuzz.append(f'fizz {n}')
    elif n % 5 == 0:
        fizzbuzz.append(f'buzz {n}')
    else:
        fizzbuzz.append(n)
</code></pre>

<p>Just because there <em>is</em> a way to write your code as a comprehension, <strong>that doesn&rsquo;t mean that you <em>should</em> write your code as a comprehension</strong>.</p>

<p>Be careful using any amount of complex logic in comprehensions, even a single <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator">inline if</a>:</p>

<pre><code class="python">number_things = [
    n // 2 if n % 2 == 0 else n * 3
    for n in numbers
]
</code></pre>

<p>If you really prefer to use a comprehension in cases like this, at least give some thought to <strong>whether whitespace or parenthesis could make things more readable</strong>:</p>

<pre><code class="python">number_things = [
    (n // 2 if n % 2 == 0 else n * 3)
    for n in numbers
]
</code></pre>

<p>And consider whether breaking some of your logic out into a separate function might improve readability as well (it may not in this somewhat silly example).</p>

<pre><code class="python">number_things = [
    even_odd_number_switch(n)
    for n in numbers
]
</code></pre>

<p>Whether a separate function makes things more readable will depend on how important that operation is, how large it is, and how well the function name conveys the operation.</p>

<h2>Loops disguised as comprehensions</h2>

<p>Sometimes you&rsquo;ll encounter code that uses a comprehension syntax but breaks the spirit of what comprehensions are used for.</p>

<p>For example, this code looks like a comprehension:</p>

<pre><code class="python">[print(n) for n in range(1, 11)]
</code></pre>

<p>But it doesn&rsquo;t <em>act</em> like a comprehension.
We&rsquo;re using a comprehension for a purpose it wasn&rsquo;t intended for.</p>

<p>If we execute this comprehension in the Python shell you&rsquo;ll see what I mean:</p>

<pre><code class="python">&gt;&gt;&gt; [print(n) for n in range(1, 11)]
1
2
3
4
5
6
7
8
9
10
[None, None, None, None, None, None, None, None, None, None]
</code></pre>

<p>We wanted to print out all the numbers from 1 to 10 and that&rsquo;s what we did.
But this comprehension statement also returned a list of <code>None</code> values to us, which we promptly discarded.</p>

<p><strong>Comprehensions build up lists: that&rsquo;s what they&rsquo;re for</strong>.
We built up a list of the return values from the <code>print</code> function and the <code>print</code> function returns <code>None</code>.</p>

<p>But we didn&rsquo;t care about the list our comprehension built up: we only cared about its side effect.</p>

<p>We could have instead written that code like this:</p>

<pre><code class="python">for n in range(1, 11):
    print(n)
</code></pre>

<p>List comprehensions are for <strong>looping over an iterable and building up new lists</strong>, while <code>for</code> loops are for <strong>looping over an iterable to do pretty much any operation you&rsquo;d like</strong>.</p>

<p>When I see a list comprehension in code <strong>I immediately assume that we&rsquo;re building up a new list</strong> (because that&rsquo;s what they&rsquo;re for).
If you use a comprehension for <strong>a purpose outside of building up a new list</strong>, it&rsquo;ll confuse others who read your code.</p>

<p>If you don&rsquo;t care about building up a new list, don&rsquo;t use a comprehension.</p>

<h2>Using comprehensions when a more specific tool exists</h2>

<p>For many problems, a more specific tool makes more sense than a general purpose <code>for</code> loop.
<strong>But comprehensions aren&rsquo;t always the best special-purpose tool for the job at hand.</strong></p>

<p>I have both seen and written quite a bit of code that looks like this:</p>

<pre><code class="python">import csv

with open('populations.csv') as csv_file:
    lines = [
        row
        for row in csv.reader(csv_file)
    ]
</code></pre>

<p>That comprehension is sort of an <em>identity</em> comprehension.
Its only purpose is to loop over the given iterable (<code>csv.reader(csv_file)</code>) and create a list out of it.</p>

<p>But in Python, we have a more specialized tool for this task: the <code>list</code> constructor.
Python&rsquo;s <code>list</code> constructor can do all the looping and list creation work for us:</p>

<pre><code class="python">import csv

with open('populations.csv') as csv_file:
    lines = list(csv.reader(csv_file))
</code></pre>

<p>Comprehensions are a special-purpose tool for looping over an iterable to build up a new list while modifying each element along the way and/or filtering elements down.
The <code>list</code> constructor is a special-purpose tool for looping over an iterable to build up a new list, without changing anything at all.</p>

<p>If you don&rsquo;t need to filter your elements down or map them into new elements while building up your new list, <strong>you don&rsquo;t need a comprehension: you need the <code>list</code> constructor</strong>.</p>

<p>This comprehension converts each of the <code>row</code> tuples we get from looping over <code>zip</code> into lists:</p>

<pre><code class="python">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        [n for n in row]
        for row in zip(*matrix)
    ]
</code></pre>

<p>We could use the <code>list</code> constructor for that too:</p>

<pre><code class="python">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        list(row)
        for row in zip(*matrix)
    ]
</code></pre>

<p>Whenever you see a comprehension like this:</p>

<pre><code class="python">my_list = [x for x in some_iterable]
</code></pre>

<p>You could write this instead:</p>

<pre><code class="python">my_list = list(some_iterable)
</code></pre>

<p>The same applies for <code>dict</code> and <code>set</code> comprehensions.</p>

<p>This is also something I&rsquo;ve written quite a bit in the past:</p>

<pre><code class="python">states = [
    ('AL', 'Alabama'),
    ('AK', 'Alaska'),
    ('AZ', 'Arizona'),
    ('AR', 'Arkansas'),
    ('CA', 'California'),
    # ...
]

abbreviations_to_names = {
    abbreviation: name
    for abbreviation, name in states
}
</code></pre>

<p>Here we&rsquo;re looping over a list of two-item tuples and making a dictionary out of them.</p>

<p>This task is exactly what the <code>dict</code> constructor was made for:</p>

<pre><code class="python">abbreviations_to_names = dict(states)
</code></pre>

<p>The built-in <code>list</code> and <code>dict</code> constructors aren&rsquo;t the only comprehension-replacing tools.
The standard library and third-party libraries also include tools that are sometimes better suited for your looping needs than a comprehension.</p>

<p>Here&rsquo;s a generator expression that sums up an iterable-of-iterables-of-numbers:</p>

<pre><code class="python">def sum_all(number_lists):
    """Return the sum of all numbers in the given list-of-lists."""
    return sum(
        n
        for numbers in number_lists
        for n in numbers
    )
</code></pre>

<p>And here&rsquo;s the same thing using <code>itertools.chain</code>:</p>

<pre><code class="python">from itertools import chain

def sum_all(number_lists):
    """Return the sum of all numbers in the given list-of-lists."""
    return sum(chain.from_iterable(number_lists))
</code></pre>

<p>When you should use a comprehension and when you should use the alternative isn&rsquo;t always straightforward.</p>

<p>I&rsquo;m often torn on whether to use <code>itertools.chain</code> or a comprehension.
I usually write my code both ways and then go with the one that seems clearer.</p>

<p>Readability is fairly problem-specific with many programming constructs, comprehensions included.</p>

<h2>Needless work</h2>

<p>Sometimes you&rsquo;ll see comprehensions that shouldn&rsquo;t be replaced by another construct but should instead be <strong>removed entirely</strong>, leaving only the iterable they loop over.</p>

<p>Here we&rsquo;re opening up a file of words (with one word per line), storing file in memory, and counting the number of times each occurs:</p>

<pre><code class="python">from collections import Counter

word_counts = Counter(
    word
    for word in open('word_list.txt').read().splitlines()
)
</code></pre>

<p>We&rsquo;re using a generator expression here, but we don&rsquo;t need to be.
This works just as well:</p>

<pre><code class="python">from collections import Counter

word_counts = Counter(open('word_list.txt').read().splitlines())
</code></pre>

<p>We were looping over a list to convert it to a generator before passing it to the <code>Counter</code> class.
That was needless work!
The <code>Counter</code> class accepts <strong>any iterable: it doesn&rsquo;t care whether they&rsquo;re lists, generators, tuples, or something else</strong>.</p>

<p>Here&rsquo;s another needless comprehension:</p>

<pre><code class="python">with open('word_list.txt') as words_file:
    lines = [line for line in words_file]
    for line in lines:
        if 'z' in line:
            print('z word', line, end='')
</code></pre>

<p>We&rsquo;re looping over <code>words_file</code>, converting it to a list of <code>lines</code>, and then looping over <code>lines</code> just once.
That conversion to a list was unnecessary.</p>

<p>We could just loop over <code>words_file</code> directly instead:</p>

<pre><code class="python">with open('word_list.txt') as words_file:
    for line in words_file:
        if 'z' in line:
            print('z word', line, end='')
</code></pre>

<p>There&rsquo;s no reason to convert an iterable to a list if all we&rsquo;re going to do is loop over it once.</p>

<p>In Python, we often care less about <strong>whether something is a list</strong> and more about <strong>whether it&rsquo;s an iterable</strong>.</p>

<p>Be careful not to create new iterables when you don&rsquo;t need to: <strong>if you&rsquo;re only going to loop over an iterable once, just use the iterable you already have</strong>.</p>

<h2>When would I use a comprehension?</h2>

<p>So when would you actually use a comprehension?</p>

<p>The simple but imprecise answer is whenever you can write your code in the below <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">comprehension copy-pasteable format</a> and there isn&rsquo;t another tool you&rsquo;d rather use for shortening your code, you should consider using a list comprehension.</p>

<pre><code class="python">new_things = []
for ITEM in old_things:
    if condition_based_on(ITEM):
        new_things.append(some_operation_on(ITEM))
</code></pre>

<p>That loop can be rewritten as this comprehension:</p>

<pre><code class="python">new_things = [
    some_operation_on(ITEM)
    for ITEM in old_things
    if condition_based_on(ITEM)
]
</code></pre>

<p>The complex answer is whenever comprehensions make sense, you should consider them.
That&rsquo;s not really an answer, but there is no one answer to the question &ldquo;when should I use a comprehension&rdquo;?</p>

<p>For example here&rsquo;s a <code>for</code> loop which doesn&rsquo;t really look like it could be rewritten using a comprehension:</p>

<pre><code class="python">def is_prime(candidate):
    for n in range(2, candidate):
        if candidate % n == 0:
            return False
    return True
</code></pre>

<p>But there is in fact another way to write this loop using a generator expression, if we know how to use the built-in <code>all</code> function:</p>

<pre><code class="python">def is_prime(candidate):
    return all(
        candidate % n != 0
        for n in range(2, candidate)
    )
</code></pre>

<p>I wrote <a href="https://treyhunner.com/2016/11/check-whether-all-items-match-a-condition-in-python/">a whole article on the <code>any</code> and <code>all</code> functions</a> and how they pair so nicely with generator expressions.
But <code>any</code> and <code>all</code> aren&rsquo;t alone in their affinity for generator expressions.</p>

<p>We have a similar situation with this code:</p>

<pre><code class="python">def sum_of_squares(numbers):
    total = 0
    for n in numbers:
        total += n**2
    return total
</code></pre>

<p>There&rsquo;s no <code>append</code> there and no new iterable being built up.
But if we create a generator of squares, we could pass them to the built-in <code>sum</code> function to get the same result:</p>

<pre><code class="python">def sum_of_squares(numbers):
    return sum(n**2 for n in numbers)
</code></pre>

<p>So in addition to the &ldquo;can I copy-paste my way from a loop to a comprehension&rdquo; check, there&rsquo;s another, fuzzier, check to consider: could your code be enhanced by a generator expression combined with an iterable-accepting function or class?</p>

<p>Any function or class that <strong>accepts an iterable as an argument</strong> <em>might</em> be a good candidate for <strong>combining with a generator expression</strong>.</p>

<h2>Use list comprehensions thoughtfully</h2>

<p>List comprehensions can make your code more readable (if you don&rsquo;t believe me, see the examples in my <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">Comprehensible Comprehensions</a> talk), but they can definitely be abused.</p>

<p>List comprehensions are a special-purpose tool for solving a specific problem.
The <code>list</code> and <code>dict</code> constructors are <strong>even more special-purpose tools</strong> for solving even more specific problems.</p>

<p>Loops are <strong>a more general purpose tool</strong> for times when you have a problem that doesn&rsquo;t fit within the realm of comprehensions or another special-purpose looping tool.</p>

<p>Functions like <code>any</code>, <code>all</code>, and <code>sum</code>, and classes like <code>Counter</code> and <code>chain</code> are iterable-accepting tools that <strong>pair very nicely with comprehensions</strong> and sometimes <strong>replace the need for comprehensions entirely</strong>.</p>

<p>Remember that comprehensions are for a single purpose: <strong>creating a new iterable from an old iterable</strong>, while tweaking values slightly along the way and/or for filtering out values that don&rsquo;t match a certain condition.
Comprehensions are a lovely tool, but <strong>they&rsquo;re not your only tool</strong>.
Don&rsquo;t forget the <code>list</code> and <code>dict</code> constructors and always consider <code>for</code> loops when your comprehensions get out of hand.</p>

<h2>Practice Python list comprehensions right now!</h2>

<p><strong>The best way to learn</strong> is through <strong>regular practice</strong>.
Every week I send out carefully crafted Python exercises through my Python skill-building service, <a href="https://www.pythonmorsels.com/">Python Morsels</a>.</p>

<p>If you&rsquo;d like to practice your comprehensions through one Python exercise right now, you can sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a> using the form below.
After you sign up, I&rsquo;ll immediately give you <strong>one exercise to practice your comprehension copy-pasting skills</strong>.</p>

<form method="post" action="https://www.pythonmorsels.com/accounts/signup/">
    <label><input type="radio" name="exercise_track" value="comprehension4"> I'm pretty much an expert at comprehensions</label>
    <br>
    <label><input type="radio" name="exercise_track" value="comprehension3"> I use comprehensions quite often</label>
    <br>
    <label><input type="radio" name="exercise_track" value="comprehension2"> I understand comprehensions, I just don't write them much</label>
    <br>
    <label><input type="radio" name="exercise_track" value="comprehension1"> What's a comprehension?</label>
    <br>
    <br>
  <input type="email" name="email" placeholder="Your email" class="subscribe-email form-big" required>
  <input type="hidden" name="form_id" value="overusing comprehensions">
  <button type="submit" class="subscribe-btn form-big">Get my Python Morsels exercise</button>
<br>

<small>
I won't share you info with others (see the <a href="https://www.pythonmorsels.com/privacy/">Python Morsels Privacy Policy</a> for details).<br>
This form is reCAPTCHA protected (Google <a href="https://policies.google.com/privacy">Privacy Policy</a> &amp; <a href="https://policies.google.com/terms">TOS</a>)
</small>

</form>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tuple ordering and deep comparisons in Python]]></title>
    <link href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/"/>
    <updated>2019-03-13T07:30:00-07:00</updated>
    <id>https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability</id>
    <content type="html"><![CDATA[<p>Comparing things in Python.
That sounds like something that almost doesn&rsquo;t even need to be taught.
But I&rsquo;ve found that <strong>Python&rsquo;s comparison operators are often misunderstood and under-appreciated by newer Pythonistas</strong>.</p>

<p>Let&rsquo;s review how Python&rsquo;s comparison operators work on different types of objects and then take a look at how we can use this to improve the readability of our code.</p>

<ul data-toc=".entry-content"></ul>


<h2>Python&rsquo;s comparison operators</h2>

<p>By &ldquo;comparison operators&rdquo; I mean the equality operators (<code>==</code> and <code>!=</code>) and the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>).</p>

<p>We can use these operators to compare numbers, as you&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; 3 == 4
False
&gt;&gt;&gt; 3 != 4
True
&gt;&gt;&gt; 3 &lt; 4
True
&gt;&gt;&gt; 3 &gt; 4
False
</code></pre>

<p>But we can also use these operators to compare strings:</p>

<pre><code class="python">&gt;&gt;&gt; "pear" == "pickle"
False
&gt;&gt;&gt; "pear" != "pickle"
True
&gt;&gt;&gt; "pear" &lt; "pickle"
True
&gt;&gt;&gt; "pear" &gt; "pickle"
False
</code></pre>

<p>And even tuples:</p>

<pre><code class="python">&gt;&gt;&gt; target = (3, 6, 2)
&gt;&gt;&gt; installed = (3, 7, 0)
&gt;&gt;&gt; target == installed
False
&gt;&gt;&gt; target &lt;= installed
True
&gt;&gt;&gt; target &gt; installed
False
</code></pre>

<p>Many programming languages don&rsquo;t have an equivalent to Python&rsquo;s very flexible comparison operators.</p>

<p>We&rsquo;ll take a look at how these operators work on tuples and more complex objects in a moment, but we&rsquo;ll start with something simpler: string comparisons.</p>

<h2>String comparisons in Python</h2>

<p>Equality and inequality with strings is fairly simple.
If two strings have exactly the same characters, they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; "hello" == "hello"
True
&gt;&gt;&gt; "hello" == "hella"
False
</code></pre>

<p>Note that I&rsquo;m glossing over a very big exception: unicode characters.
There are often multiple ways to represent the same text and those different representations must be <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize">normalized</a> before they&rsquo;re seen as equal.
For simplicity, we&rsquo;re going to stick to ASCII characters in this article.</p>

<p>Ordering of strings is where things get a bit interesting in Python:</p>

<pre><code class="python">&gt;&gt;&gt; "pickle" &lt; "python"
True
</code></pre>

<p>The string <code>"pickle"</code> is <em>less than</em> the string <code>"python"</code> because we&rsquo;re ordering alphabetically&hellip; sort of.
Capitalization matters:</p>

<pre><code class="python">&gt;&gt;&gt; "pickle" &lt; "Python"
False
</code></pre>

<p>The string <code>"Python"</code> is less than <code>"pickle"</code> because <code>P</code> is less than <code>p</code>.</p>

<p>We&rsquo;re not actually ordering alphabetically here so much as <strong>ASCII-betically</strong> (unicode-betically really since we&rsquo;re in Python 3).
These strings are being ordered by the ASCII values of their characters (<code>p</code> is 112 in <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">ASCII</a> and <code>P</code> is 80).</p>

<pre><code class="python">&gt;&gt;&gt; ord("p")
112
&gt;&gt;&gt; ord("P")
80
&gt;&gt;&gt; "P" &lt; "p"
True
</code></pre>

<p>Technically Python compares the Unicode code point (which is what <a href="https://docs.python.org/3/library/functions.html#ord">ord</a> does) for these characters and that happens to be the same as the ASCII value for ASCII characters.</p>

<p>The rules for ordering strings are:</p>

<ol>
<li>Compare the n-th characters of each string (starting with the first character, index <code>0</code>) using the <code>==</code> operator; if they&rsquo;re equal, repeat this step with the next character</li>
<li>For two unequal characters, take the character that has the lower code point and declare its string &ldquo;less than&rdquo; the other</li>
<li>If all characters are equal, the strings are equal</li>
<li>If one string runs out of characters during step 1 (one string is a &ldquo;prefix&rdquo; of the other), the shorter string is &ldquo;less than&rdquo; the longer one</li>
</ol>


<p>The ordering algorithm Python uses for strings might seem complicated, but it&rsquo;s <strong>very similar to the ordering algorithm used in dictionaries</strong>; not Python dictionaries but <a href="https://en.wikipedia.org/wiki/Dictionary">physical dictionaries</a> (those things we used before the Internet existed).
We give precedence to the first characters when ordering words in dictionaries and if one word is a prefix of another, it comes first.</p>

<h2>Tuple comparisons</h2>

<p>We can ask tuples if they&rsquo;re equal, just as we can ask strings if they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; (3, 6, 2) == (3, 6, 2)
True
&gt;&gt;&gt; (3, 6, 2) == (3, 7, 0)
False
</code></pre>

<p>But we can also compare tuples using the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>):</p>

<pre><code class="python">&gt;&gt;&gt; (3, 6, 2) &lt; (3, 6, 2)
False
&gt;&gt;&gt; (3, 6, 2) &lt;= (3, 6, 2)
True
&gt;&gt;&gt; (3, 6, 2) &lt; (3, 7, 0)
True
&gt;&gt;&gt; (3, 6, 2) &gt;= (3, 7, 0)
False
</code></pre>

<p>String ordering might have been somewhat intuitive (most of us learned alphabetical ordering before Python), but tuple ordering doesn&rsquo;t often feel quite as intuitive at first.
But you&rsquo;re actually somewhat familiar with tuple ordering already because <strong>tuple ordering uses the same algorithm as string ordering</strong>.</p>

<p>The rules for ordering tuples (which are essentially the same as ordering strings):</p>

<ol>
<li>Compare the n-th items of each tuple (starting with the first, index <code>0</code>) using the <code>==</code> operator; if they&rsquo;re equal, repeat this step with the next item</li>
<li>For two unequal items, the item that is &ldquo;less than&rdquo; makes the tuple that contains it also &ldquo;less than&rdquo; the other tuple</li>
<li>If all items are equal, the tuples are equal</li>
<li>If one tuple runs out of items during step 1 (one tuple is a &ldquo;prefix&rdquo; of the other), the shorter tuple is &ldquo;less than&rdquo; the longer one</li>
</ol>


<p>In Python, this algorithm might look sort of like this:</p>

<pre><code class="python">def less_than(tuple1, tuple2):
    for x, y in zip(tuple1, tuple2):
        if x == y:
            continue
        return (x &lt; y)
    if len(tuple1) &lt; len(tuple2):
        return True  # There were more items in the second tuple
    else:
        return False  # The first tuple had more items or they are equal
</code></pre>

<p>Note that we&rsquo;d never write code like this because Python is doing all this work for us already.
That whole function is the same as using the <code>&lt;</code> operator:</p>

<pre><code class="python">def less_than(tuple1, tuple2):
    return tuple1 &lt; tuple2
</code></pre>

<h2>Lexicographical ordering</h2>

<p>This <strong>alphabetical-like style of ordering</strong> that gives precedence to the first items in an iterable is called <a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographical ordering</a>.
You don&rsquo;t need to know that phrase, but if you ever need to describe <em>the way ordering works in Python</em>, <strong>lexicographical</strong> is the word to use.</p>

<p>Strings and tuples are ordered lexicographically, as we&rsquo;ve seen, but so are lists:</p>

<pre><code class="python">&gt;&gt;&gt; [1, 2, 3] &lt; [1, 4]
True
&gt;&gt;&gt; [1, 2, 3] &lt; [1, 2, 2]
False
</code></pre>

<p>In fact, most <a href="https://docs.python.org/3/glossary.html#term-sequence">sequences</a> in Python <a href="https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types">should be ordered lexicographically</a> (<code>range</code> objects are an exception to this as they can&rsquo;t be ordered at all).</p>

<p>But not every collection in Python relies on lexicographical ordering.</p>

<h2>Dictionary and set comparisons</h2>

<p>Many objects in Python work with equality but don&rsquo;t work with ordering at all.</p>

<p>For example dictionaries compare &ldquo;equal&rdquo; when they have all the same keys and values:</p>

<pre><code class="python">&gt;&gt;&gt; expected = {'name': 'Trey', 'python_version': '3.7.0'}
&gt;&gt;&gt; actual = {'name': 'Trey', 'python_version': '2.7.0'}
&gt;&gt;&gt; expected == actual
False
&gt;&gt;&gt; actual['python_version'] = '3.7.0'
&gt;&gt;&gt; expected == actual
True
</code></pre>

<p>But <strong>dictionaries can&rsquo;t be ordered</strong> using the <code>&lt;</code> or <code>&gt;</code> operators:</p>

<pre><code class="python">&gt;&gt;&gt; expected &lt; actual
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>

<p>Sets are similar, except that sets <em>do</em> work with ordering operators&hellip; they just don&rsquo;t use those operators for ordering:</p>

<pre><code class="python">&gt;&gt;&gt; {1, 2} &lt; {1, 2, 3}
True
&gt;&gt;&gt; {1, 3} &lt; {1, 2, 4}
False
</code></pre>

<p>Sets overload these operators to answer questions about <strong>whether one set is a subset or superset of another</strong> (<a href="https://docs.python.org/3.7/library/stdtypes.html#set-types-set-frozenset">see sets in the documentation</a>).</p>

<h2>Deep equality</h2>

<p>Comparisons between two data structures in Python tend to be <strong>deep comparisons</strong>.
Whether we&rsquo;re comparing lists, tuples, sets, or dictionaries, when we ask whether two of these objects are &ldquo;equal&rdquo; Python will recurse through each sub-object and ask whether each is &ldquo;equal&rdquo;.</p>

<p>So given a dictionary that maps tuples to lists of tuples:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2), (3, 4)]}
&gt;&gt;&gt; previous_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2)]}
</code></pre>

<p>Asking whether these two dictionaries are equal is equivalent to asking whether each key-value pair is equal, recursively:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals == previous_portals
False
&gt;&gt;&gt; current_portals[2, 1].pop()
(3, 4)
&gt;&gt;&gt; current_portals == previous_portals
True
</code></pre>

<p>The dictionaries ask each of their keys &ldquo;are you in the other dictionary&rdquo; and then asks each of the corresponding values for those keys &ldquo;are you equal to the other value&rdquo;.
But each of these operations may (as in this case) require another level of depth: the keys are tuples which need to be traversed and the values are lists which need to be traversed.
And in this case those values, the lists, need to be traversed even deeper because they contain more data structures: tuples.</p>

<p><strong>We don&rsquo;t have to worry about any of this though</strong>: Python just does these deep comparisons for us automatically.</p>

<p>While you don&rsquo;t need to worry about how deep comparisons work, the fact that Python&rsquo;s comparisons <em>are</em> deep can be pretty handy to know.</p>

<p>For example if we have <a href="https://pastebin.com/raw/yspKmfyj">a class</a> with <code>x</code>, <code>y</code>, and <code>z</code> attributes we&rsquo;d like to compare in our <code>__eq__</code> method, instead of this long boolean expression:</p>

<pre><code class="python">def __eq__(self, other):
    return self.x == other.x and self.y == other.y and self.z == other.z
</code></pre>

<p>We could bundle these values into 3-item tuples and compare them that way instead:</p>

<pre><code class="python">def __eq__(self, other):
    return (self.x, self.y, self.z) == (other.x, other.y, other.z)
</code></pre>

<p>I find this more readable, mostly because <strong>we&rsquo;ve added symmetry to our code</strong>: we have one <code>==</code> expression with the same kind of object on each side of it.</p>

<h2>Deep ordering</h2>

<p>This &ldquo;deep comparison&rdquo; works for equality, but it also works for ordering.</p>

<p>The use case for deep ordering isn&rsquo;t as obvious as for deep equality, but identifying places where deep ordering is handy can help you drastically improve the readability of your code.</p>

<p>Take this example method:</p>

<pre><code class="python">def __lt__(self, other):
    if self.last_name &lt; other.last_name:
        return True
    elif other.last_name &lt; self.last_name:
        return False
    elif self.first_name &lt; other.first_name:
        return True
    else:
        return False
</code></pre>

<p>This <code>__lt__</code> method implements the <code>&lt;</code> operator on <a href="https://pastebin.com/raw/u8uGDArq">its class</a>, returning <code>True</code> if <code>self</code> is less than <code>other</code>.
Storing and comparing <code>first_name</code> and <code>last_name</code> attributes this way is <a href="https://www.youtube.com/watch?v=458KmAKq0bQ&amp;feature=youtu.be&amp;t=148">an anti-pattern</a> but we&rsquo;ll ignore that fact for this example.</p>

<p>That <code>__lt__</code> method above gives precedence to the <code>last_name</code>: the <code>first_name</code> is only checked if the <code>last_name</code> attribute of these two objects happens to be equal.</p>

<p>If we wanted to collapse this logic some, we could rewrite our code like this:</p>

<pre><code class="python">def __lt__(self, other):
    return (
        self.last_name &lt; other.last_name or
        self.last_name == other.last_name and self.first_name &lt; other.first_name
    )
</code></pre>

<p>Or&hellip; we could rely on the deep ordering of tuples instead:</p>

<pre><code class="python">def __lt__(self, other):
    return (self.last_name, self.first_name) &lt; (other.last_name, other.first_name)
</code></pre>

<p>Here we&rsquo;re ordering our tuples lexicographically (by their first item first).
Our tuples happen to contain strings, which are also ordered lexicographically (by their first character first).
So we&rsquo;re <strong>deeply ordering</strong> these objects.</p>

<h2>Sorting by multiple attributes at once</h2>

<p>Knowing about lexicographical ordering and deep ordering of Python sequences can be quite useful when sorting Python objects.
From Python&rsquo;s perspective, <strong>sorting is really just ordering over and over</strong>.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function accepts a <code>key</code> function which can return a corresponding key object to sort each of these items by.</p>

<p>Here we&rsquo;re specifying a <code>key</code> function that accepts a word and returns a tuple of two things: the length of the word and the case-normalized word:</p>

<pre><code class="python">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; def length_and_word(word): return (len(word), word.casefold())
...
&gt;&gt;&gt; sorted(fruits, key=length_and_word)
['jujube', 'longan', 'Loquat', 'kumquat', 'Cherimoya']
</code></pre>

<p>With the key function above we&rsquo;re able to sort fruits first by their length and <em>then</em> by their case-normalized equivalent.
So &ldquo;jujube&rdquo; comes first because it&rsquo;s 6 letters (like <code>longan</code> and <code>Loquat</code>) but it&rsquo;s also alphabetically before <code>longan</code> and <code>Loquat</code>.</p>

<p>If we just sorted by length we would have had a different ordering:</p>

<pre><code class="python">&gt;&gt;&gt; sorted(fruits, key=len)
['Loquat', 'longan', 'jujube', 'kumquat', 'Cherimoya']
</code></pre>

<p><strong>Slight aside</strong>: deep comparisons actually predate the <code>sorted</code> function&rsquo;s <code>key</code> argument in Python.
Before there was a key function Python developers would create lists of tuples, sort the lists of tuples, and then grab the actual value they cared about out of that list (which is <a href="https://docs.python.org/3/howto/sorting.html#the-old-way-using-decorate-sort-undecorate">discussed in the docs</a>).</p>

<p>The <code>sorted</code> function isn&rsquo;t the only place where tuple ordering can come in handy.
Any place where you see a <code>key</code> function might be a candidates for relying on tuple ordering.
For example the <code>min</code> and <code>max</code> functions:</p>

<pre><code>&gt;&gt;&gt; min(fruits, key=str.casefold)
'Cherimoya'
&gt;&gt;&gt; max(fruits, key=str.casefold)
'Loquat'
</code></pre>

<p>Anywhere Python does an ordering operation might be a place you could rely on the deep ordering of Python&rsquo;s data structures.</p>

<h2>Deep hashability (and unhashability)</h2>

<p>Python has both deep equality and deep orderability.
But Python&rsquo;s deep comparisons don&rsquo;t stop there: there&rsquo;s also deep hashability.</p>

<p>This is something that mostly comes up with tuples.
Tuples can be used as a key in a dictionary (as we saw earlier), and they can be used in sets:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2), (3, 4)]}
&gt;&gt;&gt; points = {(1, 2), (2, 1), (3, 4)}
</code></pre>

<p>But this only works for tuples that contain immutable values:</p>

<pre><code class="python">&gt;&gt;&gt; things = {(["dress", "truck"], "yellow"), (["ball", "plane"], "purple")}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>

<p>Tuples with lists in them aren&rsquo;t hashable because lists aren&rsquo;t hashable: each object inside a tuple must be hashable for the tuple itself to be hashable.</p>

<p>So while tuples containing lists aren&rsquo;t hashable, tuples containing tuples <em>are</em> hashable:</p>

<pre><code class="python">&gt;&gt;&gt; things = {(("dress", "truck"), "yellow"), (("ball", "plane"), "purple")}
&gt;&gt;&gt; things
{(('dress', 'truck'), 'yellow'), (('ball', 'plane'), 'purple')}
</code></pre>

<p>Tuples compute their hash values by delegating to the hash values of the items they contain:</p>

<pre><code class="python">&gt;&gt;&gt; x = (1, 2)
&gt;&gt;&gt; y = (1, 2)
&gt;&gt;&gt; hash(x)
3713081631934410656
&gt;&gt;&gt; hash(x) == hash(y)
True
</code></pre>

<p>While hashability is a big subject, this is really all I&rsquo;m going to say about it.
You don&rsquo;t really need to know how hashing works in Python so if you found this section confusing, that&rsquo;s okay!</p>

<p>The takeaway here is that Python supports <strong>deep hashability</strong> which is <strong>the reason we can use tuples as dictionary keys</strong> and the reason we can use tuples in sets.</p>

<h2>Deep comparisons are a tool to remember</h2>

<p>When you have code that compares two objects based on subparts in a particular order:</p>

<pre><code class="python">d1 = (1999, 12, 31)
d2 = (1999, 12, 1)
if d1[0] &gt; d2[0]:
    greater = d1
elif d1[0] &lt; d2[0]:
    greater = d2
elif d1[1] &gt; d2[1]:
    greater = d1
elif d1[1] &lt; d2[1]:
    greater = d2
elif d1[2] &gt; d2[2]:
    greater = d1
else:
    greater = d2
</code></pre>

<p>You could probably rely on tuple ordering instead:</p>

<pre><code class="python">d1 = (1999, 12, 31)
d2 = (1999, 12, 1)
if d1 &lt; d2:
    greater = d1
else:
    greater = d2
</code></pre>

<p>If you are comparing many different things as equal:</p>

<pre><code class="python">&gt;&gt;&gt; d1 = (1999, 12, 31)
&gt;&gt;&gt; d2 = (1999, 12, 1)
&gt;&gt;&gt; d1[0] == d2[0] and d1[1] == d2[1] and d1[2] == d2[2]
False
</code></pre>

<p>You could probably rely on deep equality instead:</p>

<pre><code class="python">&gt;&gt;&gt; d1 = (1999, 12, 31)
&gt;&gt;&gt; d2 = (1999, 12, 1)
&gt;&gt;&gt; d1 == d2
False
</code></pre>

<p>And if you need to use a dictionary that has a key made up of multiple parts, if those parts are each hashable, you could probably use a tuple:</p>

<pre><code class="python">&gt;&gt;&gt; points = {}
&gt;&gt;&gt; points[1, 2] = 'red'
&gt;&gt;&gt; points
{(1, 2): 'red'}
</code></pre>

<p><strong>Python&rsquo;s support for lexicographical ordering and deep comparisons is often overlooked by folks moving from other programming languages</strong>.
Remember these features: you may not need them today, but they&rsquo;ll almost certainly come in handy at some point.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Overusing lambda expressions in Python]]></title>
    <link href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/"/>
    <updated>2018-09-27T07:30:00-07:00</updated>
    <id>https://treyhunner.com/2018/09/stop-writing-lambda-expressions</id>
    <content type="html"><![CDATA[<p><strong>Note</strong>: This post was originally titled &ldquo;Stop writing lambda expressions in Python&rdquo; but I&rsquo;ve changed the title after deciding that it was a little too extreme.</p>

<p>It&rsquo;s hard for me to teach an in-depth Python class without discussing lambda expressions.
I almost always get questions about them.
My students tend to see them in code on StackOverflow or they see them in a coworker&rsquo;s code (which, realistically, may have also come from StackOverflow).</p>

<p>I get a lot of questions about lambda, I&rsquo;m hesitant to recommend my students embrace Python&rsquo;s lambda expressions.
I have had an aversion to lambda expressions for many years, and since I started teaching Python more regularly a few years ago, my aversion to lambda expressions has only grown stronger.</p>

<p>I&rsquo;m going to explain how I see lambda expressions and why I tend to recommend my students avoid using them.</p>

<ul data-toc=".entry-content"></ul>


<h2>Lambda expressions in Python: what are they?</h2>

<p>Lambda expressions a special syntax in Python for creating <a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous functions</a>.
I&rsquo;ll call the <code>lambda</code> syntax itself a <strong>lambda expression</strong> and the function you get back from this I&rsquo;ll call a <strong>lambda function</strong>.</p>

<p>Python&rsquo;s lambda expressions allow a function to be created and passed around (often into another function) all in one line of code.</p>

<p>Lambda expressions allow us to take this code:</p>

<pre><code class="python">colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])

def normalize_case(string):
    return string.casefold()

normalized_colors = map(normalize_case, colors)
</code></pre>

<p>And turn it into this code:</p>

<pre><code class="python">colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])

normalized_colors = map(lambda s: s.casefold(), colors)
</code></pre>

<p>Lambda expressions are just a special syntax for making functions.
They can only have one statement in them and they return the result of that statement automatically.</p>

<p>The inherent limitations of lambda expressions are actually part of their appeal.
When an experienced Python programmer sees a lambda expression they know that they&rsquo;re working with a function that is <strong>only used in one place</strong> and does <strong>just one thing</strong>.</p>

<p>If you&rsquo;ve ever used anonymous functions in JavaScript before, you can think of Python&rsquo;s lambda expressions as the same, except they have more restrictions and use a very different syntax than the traditional function syntax.</p>

<h2>Where they&rsquo;re usually used</h2>

<p>You&rsquo;ll typically see <code>lambda</code> expressions used when calling functions (or classes) that accept a function as an argument.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function accepts a function as its <code>key</code> argument.  This <em>key function</em> is used to compute a comparison key when determining the sorting order of items.</p>

<p>So <code>sorted</code> is a great example of a place that lambda expressions are often used:</p>

<pre><code class="python">&gt;&gt;&gt; colors = ["Goldenrod", "purple", "Salmon", "turquoise", "cyan"]
&gt;&gt;&gt; sorted(colors, key=lambda s: s.casefold())
['cyan', 'Goldenrod', 'purple', 'Salmon', 'turquoise']
</code></pre>

<p>The above code returns the given colors sorted in a case-insensitive way.</p>

<p>The <code>sorted</code> function isn&rsquo;t the only use of lambda expressions, but it&rsquo;s a common one.</p>

<h2>The pros and cons of lambda</h2>

<p>I frame my thinking around lambda expressions as a constant comparison to using <code>def</code> to define functions.
Both of these tools give us functions, but they each have different limitations and use a different syntax.</p>

<p>The main ways lambda expressions are different from <code>def</code>:</p>

<ol>
<li>They can be immediately passed around (no variable needed)</li>
<li>They can only have a single line of code within them</li>
<li>They return automatically</li>
<li>They can&rsquo;t have a docstring and they don&rsquo;t have a name</li>
<li>They use a different and unfamiliar syntax</li>
</ol>


<p>The fact that lambda expressions can be passed around is their biggest benefit.  Returning automatically is neat but not a big benefit in my mind.  I find the &ldquo;single line of code&rdquo; limitation is neither good nor bad overall.  The fact that lambda functions can&rsquo;t have docstrings and don&rsquo;t have a name is unfortunate and their unfamiliar syntax can be troublesome for newer Pythonistas.</p>

<p>Overall I feel the cons slightly outweigh the pros of lambda expressions, but my biggest complaint about them is that I find that they tend to be both misused and overused.</p>

<h2>Lambda is both misused and overused</h2>

<p>When I see a lambda expression in unfamiliar code I immediately become skeptical.
When I encounter a lambda expression in the wild, I often find that removing it improves code readability.</p>

<p>Sometimes the issue is that lambda expressions are being misused, meaning they&rsquo;re <strong>used in a way that is nearly always unideal</strong>.
Other times lambda expressions are simply being overused, meaning they&rsquo;re acceptable but I&rsquo;d personally <strong>prefer to see the code written a different way</strong>.</p>

<p>Let&rsquo;s take a look at the various ways lambda expressions are misused and overused.</p>

<h2>Misuse: naming lambda expressions</h2>

<p>PEP8, the official Python style guide, advises never to write code like this:</p>

<pre><code class="python">normalize_case = lambda s: s.casefold()
</code></pre>

<p>The above statement makes an anonymous function and then assigns it to a variable.
The above code ignores the reason lambda functions are useful: <strong>lambda functions can be passed around without needing to be assigned to a variable first</strong>.</p>

<p>If you want to create a one-liner function and store it in a variable, you should use <code>def</code> instead:</p>

<pre><code class="python">def normalize_case(s): return s.casefold()
</code></pre>

<p>PEP8 recommends this because named functions are a common and easily understood thing.
This also has the benefit of giving our function a proper name, which could make debugging easier.
Unlike functions defined with <code>def</code>, lambda functions never have a name (it&rsquo;s always <code>&lt;lambda&gt;</code>):</p>

<pre><code class="python">&gt;&gt;&gt; normalize_case = lambda s: s.casefold()
&gt;&gt;&gt; normalize_case
&lt;function &lt;lambda&gt; at 0x7f264d5b91e0&gt;
&gt;&gt;&gt; def normalize_case(s): return s.casefold()
...
&gt;&gt;&gt; normalize_case
&lt;function normalize_case at 0x7f247f68fea0&gt;
</code></pre>

<p><strong>If you want to create a function and store it in a variable, define your function using <code>def</code></strong>.
That&rsquo;s exactly what it&rsquo;s for.
It doesn&rsquo;t matter if your function is a single line of code or if you&rsquo;re defining a function inside of another function, <code>def</code> works just fine for those use cases.</p>

<h2>Misuse: needless function calls</h2>

<p>I frequently see lambda expressions used to wrap around a function that was already appropriate for the problem at hand.</p>

<p>For example take this code:</p>

<pre><code class="python">sorted_numbers = sorted(numbers, key=lambda n: abs(n))
</code></pre>

<p>The person who wrote this code likely learned that lambda expressions are used for making a function that can be passed around.
But they missed out on a slightly bigger picture idea: <strong>all functions in Python (not just lambda functions) can be passed around</strong>.</p>

<p>Since <code>abs</code> (which returns the absolute value of a number) is a function and all functions can be passed around, we could actually have written the above code like this:</p>

<pre><code class="python">sorted_numbers = sorted(numbers, key=abs)
</code></pre>

<p>Now this example might feel contrived, but it&rsquo;s not terribly uncommon to overuse lambda expressions in this way.  Here&rsquo;s another example I&rsquo;ve seen:</p>

<pre><code class="python">pairs = [(4, 11), (8, 8), (5, 7), (11, 3)]
sorted_by_smallest = sorted(pairs, key=lambda items: min(items))
</code></pre>

<p>Because we&rsquo;re accepting exactly the same arguments as we&rsquo;re passing into <code>min</code>, we don&rsquo;t need that extra function call.  We can just pass the <code>min</code> function to <code>key</code> instead:</p>

<pre><code class="python">pairs = [(4, 11), (8, 8), (5, 7), (11, 3)]
sorted_by_smallest = sorted(pairs, key=min)
</code></pre>

<p>You don&rsquo;t need a lambda function if you already have another function that does what you want.</p>

<h2>Overuse: simple, but non-trivial functions</h2>

<p>It&rsquo;s common to see lambda expressions used to make a function that returns a couple of values in a tuple:</p>

<pre><code class="python">colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])
colors_by_length = sorted(colors, key=lambda c: (len(c), c.casefold()))
</code></pre>

<p>That <code>key</code> function here is helping us sort these colors by their length followed by their case-normalized name.</p>

<p>This code is the same as the above code, but I find it more readable:</p>

<pre><code class="python">def length_and_alphabetical(string):
    """Return sort key: length first, then case-normalized string."""
    return (len(string), string.casefold())

colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])
colors_by_length = sorted(colors, key=length_and_alphabetical)
</code></pre>

<p>This code is quite a bit more verbose, but I find the name of that key function makes it clearer what we&rsquo;re sorting by.
We&rsquo;re not just sorting by the length and we&rsquo;re not just sorting by the color: we&rsquo;re sorting by both.</p>

<p><strong>If a function is important, it deserves a name</strong>.
You could argue that most functions that are used in a lambda expression are so trivial that they don&rsquo;t deserve a name, but there&rsquo;s often little downside to naming functions and I find it usually makes my code more readable overall.</p>

<p>Naming functions often makes code more readable, the same way <a href="http://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">using tuple unpacking to name variables</a> instead of using arbitrary index-lookups often makes code more readable.</p>

<h2>Overuse: when multiple lines would help</h2>

<p>Sometimes the &ldquo;just one line&rdquo; aspect of lambda expressions cause us to write code in convoluted ways.  For example take this code:</p>

<pre><code class="python">points = [((1, 2), 'red'), ((3, 4), 'green')]
points_by_color = sorted(points, key=lambda p: p[1])
</code></pre>

<p>We&rsquo;re hard-coding an index lookup here to sort points by their color.
If we used a named function we could have used <a href="http://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">tuple unpacking</a> to make this code more readable:</p>

<pre><code class="python">def color_of_point(point):
    """Return the color of the given point."""
    (x, y), color = point
    return color

points = [((1, 2), 'red'), ((3, 4), 'green')]
points_by_color = sorted(points, key=color_of_point)
</code></pre>

<p>Tuple unpacking can improve readability over using hard-coded index lookups.
<strong>Using lambda expressions often means sacrificing some Python language features</strong>, specifically those that require multiple lines of code (like an extra assignment statement).</p>

<h2>Overuse: lambda with map and filter</h2>

<p>Python&rsquo;s map and filter functions are almost always paired with lambda expressions.  It&rsquo;s common to see StackOverflow questions asking &ldquo;what is lambda&rdquo; answered with code examples like this:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; squared_numbers = map(lambda n: n**2, numbers)
&gt;&gt;&gt; odd_numbers = filter(lambda n: n % 2 == 1, numbers)
</code></pre>

<p>I find these examples a bit confusing because <strong>I almost never use map and filter in my code</strong>.</p>

<p>Python&rsquo;s <code>map</code> and <code>filter</code> functions are used for looping over an iterable and making a new iterable that either slightly changes each element or filters the iterable down to only elements that match a certain condition.
We can accomplish both of those tasks just as well with list comprehensions or generator expressions:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; squared_numbers = (n**2 for n in numbers)
&gt;&gt;&gt; odd_numbers = (n for n in numbers if n % 2 == 1)
</code></pre>

<p>Personally, I&rsquo;d prefer to see the above generator expressions written over multiple lines of code (<a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">see my article on comprehensions</a>) but I find even these one-line generator expressions more readable than those <code>map</code> and <code>filter</code> calls.</p>

<p>The general operations of mapping and filtering are useful, but we really don&rsquo;t need the <code>map</code> and <code>filter</code> functions themselves.
Generator expressions are a special syntax that exists just for the tasks of mapping and filtering.
So my advice is to <strong>use generator expressions instead of the <code>map</code> and <code>filter</code> functions</strong>.</p>

<h2>Misuse: sometimes you don&rsquo;t even need to pass a function</h2>

<p>What about cases where you need to pass around a function that performs a single operation?</p>

<p>Newer Pythonistas who are keen on functional programming sometimes write code like this:</p>

<pre><code class="python">from functools import reduce

numbers = [2, 1, 3, 4, 7, 11, 18]
total = reduce(lambda x, y: x + y, numbers)
</code></pre>

<p>This code adds all the numbers in the <code>numbers</code> list.
There&rsquo;s an even better way to do this:</p>

<pre><code class="python">numbers = [2, 1, 3, 4, 7, 11, 18]
total = sum(numbers)
</code></pre>

<p>Python&rsquo;s built-in <code>sum</code> function was made just for this task.</p>

<p>The <code>sum</code> function, along with a number of other specialized Python tools, are easy to overlook.
But I&rsquo;d encourage you to seek out the more specialized tools when you need them because they often make for more readable code.</p>

<p>Instead of passing functions into other functions, <strong>look into whether there is a more specialized way to solve your problem instead</strong>.</p>

<h2>Overuse: using lambda for very simple operations</h2>

<p>Let&rsquo;s say instead of adding numbers up, we&rsquo;re multiply numbers together:</p>

<pre><code class="python">from functools import reduce

numbers = [2, 1, 3, 4, 7, 11, 18]
product = reduce(lambda x, y: x * y, numbers, 1)
</code></pre>

<p>The above lambda expression is necessary because we&rsquo;re not allowed to pass the <code>*</code> operator around as if it were a function.
If there was a function that was equivalent to <code>*</code>, we could pass it into the <code>reduce</code> function instead.</p>

<p>Python&rsquo;s standard library actually has a whole module meant to address this problem:</p>

<pre><code class="python">from functools import reduce
from operator import mul

numbers = [2, 1, 3, 4, 7, 11, 18]
product = reduce(mul, numbers, 1)
</code></pre>

<p>Python&rsquo;s <a href="https://docs.python.org/3/library/operator.html">operator module</a> exists to make various Python operators easy to use as functions.
If you&rsquo;re practicing functional(ish) programming, <strong>Python&rsquo;s <code>operator</code> module is your friend</strong>.</p>

<p>In addition to providing functions corresponding to Python&rsquo;s many operators, the <code>operator</code> module provides a couple common higher level functions for accessing items and attributes and calling methods.</p>

<p>There&rsquo;s <code>itemgetter</code> for accessing indexes of a list/sequence or keys of a dictionary/mapping:</p>

<pre><code class="python"># Without operator: accessing a key/index
rows_sorted_by_city = sorted(rows, key=lambda row: row['city'])

# With operator: accessing a key/index
from operator import itemgetter
rows_sorted_by_city = sorted(rows, key=itemgetter('city'))
</code></pre>

<p>There&rsquo;s also <code>attrgetter</code> for accessing attributes on an object:</p>

<pre><code class="python"># Without operator: accessing an attribute
products_by_quantity = sorted(products, key=lambda p: p.quantity)

# With operator: accessing an attribute
from operator import attrgetter
products_by_quantity = sorted(products, key=attrgetter('quantity'))
</code></pre>

<p>And <code>methodcaller</code> for calling methods on an object:</p>

<pre><code class="python"># Without operator: calling a method
sorted_colors = sorted(colors, key=lambda s: s.casefold())

# With operator: calling a method
from operator import methodcaller
sorted_colors = sorted(colors, key=methodcaller('casefold'))
</code></pre>

<p>I <em>usually</em> find that <strong>using the functions in the <code>operator</code> module makes my code clearer</strong> than if I&rsquo;d used an equivalent lambda expression.</p>

<h2>Overuse: when higher order functions add confusion</h2>

<p>A function that accepts a function as an argument is called a <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher order function</a>.  Higher order functions are the kinds of functions that we tend to pass lambda functions to.</p>

<p>The use of higher order functions is common when practicing functional programming.  Functional programming isn&rsquo;t the only way to use Python though: Python is a multi-paradigm language so we can mix and match coding disciplines to make our code more readable.</p>

<p>Compare this:</p>

<pre><code class="python">from functools import reduce

numbers = [2, 1, 3, 4, 7, 11, 18]
product = reduce(lambda x, y: x * y, numbers, 1)
</code></pre>

<p>To this:</p>

<pre><code class="python">def multiply_all(numbers):
    """Return the product of the given numbers."""
    product = 1
    for n in numbers:
        product *= n
    return product

numbers = [2, 1, 3, 4, 7, 11, 18]
product = multiply_all(numbers)
</code></pre>

<p>The second code is longer, but folks without a functional programming background will often find it easier to understand.</p>

<p>Anyone who has gone through one of my Python training courses can probably understand what that <code>multiply_all</code> function does, whereas that <code>reduce</code>/<code>lambda</code> combination is likely a bit more cryptic for many Python programmers.</p>

<p>In general, <strong>passing one function into another function, tends to make code more complex, which can hurt readability</strong>.</p>

<h2>Should you ever use lambda expressions?</h2>

<p>So I find the use of lambda expressions problematic because:</p>

<ul>
<li>lambda expressions are an odd and unfamiliar syntax to many Python programmers</li>
<li>lambda functions inherently lack a name or documentation, meaning reading their code is the only way to figure out what they do</li>
<li>lambda expressions can have only one statement in them so certain language features that improve readability, like tuple unpacking, can&rsquo;t be used with them</li>
<li>lambda functions can often be replaced with already existing functions in the standard library or built-in to Python</li>
</ul>


<p>Lambda expressions are rarely more immediately readable than a well-named function.
While a <code>def</code> statement is often more understandable, <strong>Python also has a number of features that can be used to replace lambda expressions</strong>, including special syntaxes (comprehensions), built-in functions (sum), and standard library functions (in the <code>operators</code> module).</p>

<p>I&rsquo;d say that using lambda expressions is acceptable only if your situation meets all four of these criteria:</p>

<ol>
<li>The operation you&rsquo;re doing is trivial: the function doesn&rsquo;t deserve a name</li>
<li>Having a lambda expression makes your code more understandable than the function names you can think of</li>
<li>You&rsquo;re pretty sure there&rsquo;s not already a function that does what you&rsquo;re looking for</li>
<li>Everyone on your team understands lambda expressions and you&rsquo;ve all agreed to use them</li>
</ol>


<p>If any of those four statements don&rsquo;t fit your situation, I&rsquo;d recommend <strong>writing a new function using <code>def</code></strong> and (whenever possible) <strong>embracing a function that already exists within Python</strong> that already does what you&rsquo;re looking for.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple assignment and tuple unpacking improve Python code readability]]></title>
    <link href="https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/"/>
    <updated>2018-03-07T16:30:00-08:00</updated>
    <id>https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability</id>
    <content type="html"><![CDATA[<p>Whether I&rsquo;m teaching new Pythonistas or long-time Python programmers, I frequently find that <strong>Python programmers underutilize multiple assignment</strong>.</p>

<p>Multiple assignment (also known as tuple unpacking or iterable unpacking) allows you to assign multiple variables at the same time in one line of code.
This feature often seems simple after you&rsquo;ve learned about it, but <strong>it can be tricky to recall multiple assignment when you need it most</strong>.</p>

<p>In this article we&rsquo;ll see what multiple assignment is, we&rsquo;ll take a look at common uses of multiple assignment, and then we&rsquo;ll look at a few uses for multiple assignment that are often overlooked.</p>

<p>Note that in this article I will be using <a href="https://cito.github.io/blog/f-strings/">f-strings</a> which are a Python 3.6+ feature.
If you&rsquo;re on an older version of Python, you&rsquo;ll need to mentally translate those to use the string <code>format</code> method.</p>

<ul data-toc=".entry-content"></ul>


<h2>How multiple assignment works</h2>

<p>I&rsquo;ll be using the words <strong>multiple assignment</strong>, <strong>tuple unpacking</strong>, and <strong>iterable unpacking</strong> interchangeably in this article.
They&rsquo;re all just different words for the same thing.</p>

<p>Python&rsquo;s multiple assignment looks like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = 10, 20
</code></pre>

<p>Here we&rsquo;re setting <code>x</code> to <code>10</code> and <code>y</code> to <code>20</code>.</p>

<p>What&rsquo;s happening at a lower level is that we&rsquo;re creating a tuple of <code>10, 20</code> and then looping over that tuple and taking each of the two items we get from looping and assigning them to <code>x</code> and <code>y</code> in order.</p>

<p>This syntax might make that a bit more clear:</p>

<pre><code class="pycon">&gt;&gt;&gt; (x, y) = (10, 20)
</code></pre>

<p>Parenthesis are optional around tuples in Python and they&rsquo;re also optional in multiple assignment (which uses a tuple-like syntax).
All of these are equivalent:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = 10, 20
&gt;&gt;&gt; x, y = (10, 20)
&gt;&gt;&gt; (x, y) = 10, 20
&gt;&gt;&gt; (x, y) = (10, 20)
</code></pre>

<p>Multiple assignment is often called &ldquo;tuple unpacking&rdquo; because it&rsquo;s frequently used with tuples.
But we can use multiple assignment with any iterable, not just tuples.
Here we&rsquo;re using it with a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = [10, 20]
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>

<p>And with a string:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = 'hi'
&gt;&gt;&gt; x
'h'
&gt;&gt;&gt; y
'i'
</code></pre>

<p>Anything that can be looped over can be &ldquo;unpacked&rdquo; with tuple unpacking / multiple assignment.</p>

<p>Here&rsquo;s another example to demonstrate that multiple assignment works with any number of items and that it works with variables as well as objects we&rsquo;ve just created:</p>

<pre><code class="pycon">&gt;&gt;&gt; point = 10, 20, 30
&gt;&gt;&gt; x, y, z = point
&gt;&gt;&gt; print(x, y, z)
10 20 30
&gt;&gt;&gt; (x, y, z) = (z, y, x)
&gt;&gt;&gt; print(x, y, z)
30 20 10
</code></pre>

<p>Note that on that last line we&rsquo;re actually swapping variable names, which is something multiple assignment allows us to do easily.</p>

<p>Alright, let&rsquo;s talk about how multiple assignment can be used.</p>

<h2>Unpacking in a for loop</h2>

<p>You&rsquo;ll commonly see multiple assignment used in <code>for</code> loops.</p>

<p>Let&rsquo;s take a dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; person_dictionary = {'name': "Trey", 'company': "Truthful Technology LLC"}
</code></pre>

<p>Instead of looping over our dictionary like this:</p>

<pre><code class="python">for item in person_dictionary.items():
    print(f"Key {item[0]} has value {item[1]}")
</code></pre>

<p>You&rsquo;ll often see Python programmers use multiple assignment by writing this:</p>

<pre><code class="python">for key, value in person_dictionary.items():
    print(f"Key {key} has value {value}")
</code></pre>

<p>When you write the <code>for X in Y</code> line of a for loop, you&rsquo;re telling Python that it should do an assignment to <code>X</code> for each iteration of your loop.
Just like in an assignment using the <code>=</code> operator, we can use multiple assignment here.</p>

<p>This:</p>

<pre><code class="python">for key, value in person_dictionary.items():
    print(f"Key {key} has value {value}")
</code></pre>

<p>Is essentially the same as this:</p>

<pre><code class="python">for item in person_dictionary.items():
    key, value = item
    print(f"Key {key} has value {value}")
</code></pre>

<p>We&rsquo;re just not doing an unnecessary extra assignment in the first example.</p>

<p>So multiple assignment is great for unpacking dictionary items into key-value pairs, but it&rsquo;s helpful in many other places too.</p>

<p>It&rsquo;s great when paired with the built-in <code>enumerate</code> function:</p>

<pre><code class="python">for i, line in enumerate(my_file):
    print(f"Line {i}: {line}")
</code></pre>

<p>And the <code>zip</code> function:</p>

<pre><code class="python">for color, ratio in zip(colors, ratios):
    print(f"It's {ratio*100}% {color}.")
</code></pre>



<pre><code class="python">for (product, price, color) in zip(products, prices, colors):
    print(f"{product} is {color} and costs ${price:.2f}")
</code></pre>

<p>If you&rsquo;re unfamiliar with <code>enumerate</code> or <code>zip</code>, see my article on <a href="http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">looping with indexes in Python</a>.</p>

<p>Newer Pythonistas often see multiple assignment in the context of <code>for</code> loops and sometimes assume it&rsquo;s tied to loops.  Multiple assignment works for any assignment though, not just loop assignments.</p>

<h2>An alternative to hard coded indexes</h2>

<p>It&rsquo;s not uncommon to see hard coded indexes (e.g. <code>point[0]</code>, <code>items[1]</code>, <code>vals[-1]</code>) in code:</p>

<pre><code class="python">print(f"The first item is {items[0]} and the last item is {items[-1]}")
</code></pre>

<p>When you see Python code that uses hard coded indexes there&rsquo;s often a way to <strong>use multiple assignment to make your code more readable</strong>.</p>

<p>Here&rsquo;s some code that has three hard coded indexes:</p>

<pre><code class="python">def reformat_date(mdy_date_string):
    """Reformat MM/DD/YYYY string into YYYY-MM-DD string."""
    date = mdy_date_string.split('/')
    return f"{date[2]}-{date[0]}-{date[1]}"
</code></pre>

<p>We can make this code much more readable by using multiple assignment to assign separate month, day, and year variables:</p>

<pre><code class="python">def reformat_date(mdy_date_string):
    """Reformat MM/DD/YYYY string into YYYY-MM-DD string."""
    month, day, year = mdy_date_string.split('/')
    return f"{year}-{month}-{day}"
</code></pre>

<p>Whenever you see hard coded indexes in your code, stop to consider whether you could use multiple assignment to make your code more readable.</p>

<h2>Multiple assignment is very strict</h2>

<p>Multiple assignment is actually fairly strict when it comes to unpacking the iterable we give to it.</p>

<p>If we try to unpack a larger iterable into a smaller number of variables, we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = (10, 20, 30)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)
</code></pre>

<p>If we try to unpack a smaller iterable into a larger number of variables, we&rsquo;ll also get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y, z = (10, 20)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: not enough values to unpack (expected 3, got 2)
</code></pre>

<p>This strictness is pretty great.
If we&rsquo;re working with an item that has a different size than we expected, the multiple assignment will fail loudly and we&rsquo;ll hopefully now know about a bug in our program that we weren&rsquo;t yet aware of.</p>

<p>Let&rsquo;s look at an example.
Imagine that we have a short command line program that parses command-line arguments in a rudimentary way, like this:</p>

<pre><code class="python">import sys

new_file = sys.argv[1]
old_file = sys.argv[2]
print(f"Copying {new_file} to {old_file}")
</code></pre>

<p>Our program is supposed to accept 2 arguments, like this:</p>

<pre><code class="bash">$ my_program.py file1.txt file2.txt
Copying file1.txt to file2.txt
</code></pre>

<p>But if someone called our program with three arguments, they will not see an error:</p>

<pre><code class="bash">$ my_program.py file1.txt file2.txt file3.txt
Copying file1.txt to file2.txt
</code></pre>

<p>There&rsquo;s no error because we&rsquo;re not validating that we&rsquo;ve received exactly 2 arguments.</p>

<p>If we use multiple assignment instead of hard coded indexes, the assignment will verify that we receive exactly the expected number of arguments:</p>

<pre><code class="python">import sys

_, new_file, old_file = sys.argv
print(f"Copying {new_file} to {old_file}")
</code></pre>

<p><strong>Note</strong>: we&rsquo;re using the variable name <code>_</code> to note that we don&rsquo;t care about <code>sys.argv[0]</code> (the name of our program).
Using <code>_</code> for variables you don&rsquo;t care about is just a convention.</p>

<h2>An alternative to slicing</h2>

<p>So multiple assignment can be used for avoiding hard coded indexes and it can be used to ensure we&rsquo;re strict about the size of the tuples/iterables we&rsquo;re working with.</p>

<p>Multiple assignment can be used to replace hard coded slices too!</p>

<p>Slicing is a handy way to grab a specific portion of the items in lists and other sequences.</p>

<p>Here are some slices that are &ldquo;hard coded&rdquo; in that they only use numeric indexes:</p>

<pre><code class="python">all_after_first = items[1:]
all_but_last_two = items[:-2]
items_with_ends_removed = items[1:-1]
</code></pre>

<p>Whenever you see slices that don&rsquo;t use any variables in their slice indexes, you can often use multiple assignment instead.
To do this we have to talk about a feature that I haven&rsquo;t mentioned yet: the <code>*</code> operator.</p>

<p>In Python 3.0, the <code>*</code> operator was added to the multiple assignment syntax, allowing us to capture remaining items after an unpacking into a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; first, *rest = numbers
&gt;&gt;&gt; rest
[2, 3, 4, 5, 6]
&gt;&gt;&gt; first
1
</code></pre>

<p>The <code>*</code> operator allows us to replace hard coded slices near the ends of sequences.</p>

<p>These two lines are equivalent:</p>

<pre><code class="pycon">&gt;&gt;&gt; beginning, last = numbers[:-1], numbers[-1]
&gt;&gt;&gt; *beginning, last = numbers
</code></pre>

<p>These two lines are equivalent also:</p>

<pre><code class="pycon">&gt;&gt;&gt; head, middle, tail = numbers[0], numbers[1:-1], numbers[-1]
&gt;&gt;&gt; head, *middle, tail = numbers
</code></pre>

<p>With the <code>*</code> operator and multiple assignment you can replace things like this:</p>

<pre><code class="python">main(sys.argv[0], sys.argv[1:])
</code></pre>

<p>With more descriptive code, like this:</p>

<pre><code class="python">program_name, *arguments = sys.argv
main(program_name, arguments)
</code></pre>

<p>So if you see hard coded slice indexes in your code, consider whether you could use multiple assignment to clarify what those slices really represent.</p>

<h2>Deep unpacking</h2>

<p>This next feature is something that long-time Python programmers often overlook.
It doesn&rsquo;t come up quite as often as the other uses for multiple assignment that I&rsquo;ve discussed, but it can be very handy to know about when you do need it.</p>

<p>We&rsquo;ve seen multiple assignment for unpacking tuples and other iterables.
We haven&rsquo;t yet seen that this is can be done <em>deeply</em>.</p>

<p>I&rsquo;d say that the following multiple assignment is <em>shallow</em> because it unpacks one level deep:</p>

<pre><code class="pycon">&gt;&gt;&gt; color, point = ("red", (1, 2, 3))
&gt;&gt;&gt; color
'red'
&gt;&gt;&gt; point
(1, 2, 3)
</code></pre>

<p>And I&rsquo;d say that this multiple assignment is <em>deep</em> because it unpacks the previous <code>point</code> tuple further into <code>x</code>, <code>y</code>, and <code>z</code> variables:</p>

<pre><code class="pycon">&gt;&gt;&gt; color, (x, y, z) = ("red", (1, 2, 3))
&gt;&gt;&gt; color
'red'
&gt;&gt;&gt; x
1
&gt;&gt;&gt; y
2
</code></pre>

<p>If it seems confusing what&rsquo;s going on above, maybe using parenthesis consistently on both sides of this assignment will help clarify things:</p>

<pre><code class="pycon">&gt;&gt;&gt; (color, (x, y, z)) = ("red", (1, 2, 3))
</code></pre>

<p>We&rsquo;re unpacking one level deep to get two objects, but then we take the second object and unpack it also to get 3 more objects.
Then we assign our first object and our thrice-unpacked second object to our new variables (<code>color</code>, <code>x</code>, <code>y</code>, and <code>z</code>).</p>

<p>Take these two lists:</p>

<pre><code class="python">start_points = [(1, 2), (3, 4), (5, 6)]
end_points = [(-1, -2), (-3, 4), (-6, -5)]
</code></pre>

<p>Here&rsquo;s an example of code that works with these lists by using shallow unpacking:</p>

<pre><code class="python">for start, end in zip(start_points, end_points):
    if start[0] == -end[0] and start[1] == -end[1]:
        print(f"Point {start[0]},{start[1]} was negated.")
</code></pre>

<p>And here&rsquo;s the same thing with deeper unpacking:</p>

<pre><code class="python">for (x1, y1), (x2, y2) in zip(start_points, end_points):
    if x1 == -x2 and y1 == -y2:
        print(f"Point {x1},{y1} was negated.")
</code></pre>

<p>Note that in this second case, it&rsquo;s much more clear what type of objects we&rsquo;re working with.
The deep unpacking makes it apparent that we&rsquo;re receiving two 2-itemed tuples each time we loop.</p>

<p>Deep unpacking often comes up when nesting looping utilities that each provide multiple items.
For example, you may see deep multiple assignments when using <code>enumerate</code> and <code>zip</code> together:</p>

<pre><code class="python">items = [1, 2, 3, 4, 2, 1]
for i, (first, last) in enumerate(zip(items, reversed(items))):
    if first != last:
        raise ValueError(f"Item {i} doesn't match: {first} != {last}")
</code></pre>

<p>I said before that multiple assignment is strict about the size of our iterables as we unpack them.
With deep unpacking we can also be <strong>strict about the shape of our iterables</strong>.</p>

<p>This works:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2), (-1, -2))
&gt;&gt;&gt; points[0][0] == -points[1][0] and points[0][1] == -points[1][1]
True
</code></pre>

<p>But this buggy code works too:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))
&gt;&gt;&gt; points[0][0] == -points[1][0] and points[0][1] == -points[1][1]
True
</code></pre>

<p>Whereas this works:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2), (-1, -2))
&gt;&gt;&gt; (x1, y1), (x2, y2) = points
&gt;&gt;&gt; x1 == -x2 and y1 == -y2
True
</code></pre>

<p>But this does not:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))
&gt;&gt;&gt; (x1, y1), (x2, y2) = points
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)
</code></pre>

<p>With multiple assignment we&rsquo;re assigning variables while also making particular assertions about the size and shape of our iterables.
Multiple assignment will help you clarify your code to both humans (for <strong>better code readability</strong>) and to computers (for <strong>improved code correctness</strong>).</p>

<h2>Using a list-like syntax</h2>

<p>I noted before that multiple assignment uses a tuple-like syntax, but it works on any iterable.
That tuple-like syntax is the reason it&rsquo;s commonly called &ldquo;tuple unpacking&rdquo; even though it might be more clear to say &ldquo;iterable unpacking&rdquo;.</p>

<p>I didn&rsquo;t mention before that multiple assignment also works with <strong>a list-like syntax</strong>.</p>

<p>Here&rsquo;s a multiple assignment with a list-like syntax:</p>

<pre><code class="pycon">&gt;&gt;&gt; [x, y, z] = 1, 2, 3
&gt;&gt;&gt; x
1
</code></pre>

<p>This might seem really strange. What&rsquo;s the point of allowing both list-like and tuple-like syntaxes?</p>

<p>I use this feature rarely, but I find it helpful for <strong>code clarity</strong> in specific circumstances.</p>

<p>Let&rsquo;s say I have code that used to look like this:</p>

<pre><code class="python">def most_common(items):
    return Counter(items).most_common(1)[0][0]
</code></pre>

<p>And our well-intentioned coworker has decided to use deep multiple assignment to refactor our code to this:</p>

<pre><code class="python">def most_common(items):
    (value, times_seen), = Counter(items).most_common(1)
    return value
</code></pre>

<p>See that trailing comma on the left-hand side of the assignment?
It&rsquo;s easy to miss and it makes this code look sort of weird.
What is that comma even doing in this code?</p>

<p>That trailing comma is there to make a single item tuple.
We&rsquo;re doing deep unpacking here.</p>

<p>Here&rsquo;s another way we could write the same code:</p>

<pre><code class="python">def most_common(items):
    ((value, times_seen),) = Counter(items).most_common(1)
    return value
</code></pre>

<p>This might make that deep unpacking a little more obvious but I&rsquo;d prefer to see this instead:</p>

<pre><code class="python">def most_common(items):
    [(value, times_seen)] = Counter(items).most_common(1)
    return value
</code></pre>

<p>The list-syntax in our assignment makes it more clear that we&rsquo;re unpacking a one-item iterable and then unpacking that single item into <code>value</code> and <code>times_seen</code> variables.</p>

<p>When I see this, I also think <em>I bet we&rsquo;re unpacking a single-item list</em>.
And that is in fact what we&rsquo;re doing.
We&rsquo;re using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter</a> object from the collections module here.
The <code>most_common</code> method on <code>Counter</code> objects allows us to limit the length of the list returned to us.
We&rsquo;re limiting the list we&rsquo;re getting back to just a single item.</p>

<p>When you&rsquo;re unpacking structures that often hold lots of values (like lists) and structures that often hold a very specific number of values (like tuples) you may decide that your code appears more <em>semantically accurate</em> if you use a list-like syntax when unpacking those list-like structures.</p>

<p>If you&rsquo;d like you might even decide to adopt a convention of always using a list-like syntax when unpacking list-like structures (frequently the case when using <code>*</code> in multiple assignment):</p>

<pre><code class="pycon">&gt;&gt;&gt; [first, *rest] = numbers
</code></pre>

<p>I don&rsquo;t usually use this convention myself, mostly because I&rsquo;m just not in the habit of using it.
But if you find it helpful, you might consider using this convention in your own code.</p>

<p>When using multiple assignment in your code, consider when and where a list-like syntax might make your code more descriptive and more clear.
This can sometimes improve readability.</p>

<h2>Don&rsquo;t forget about multiple assignment</h2>

<p>Multiple assignment can improve both the readability of your code and the correctness of your code.
It can make your code <strong>more descriptive</strong> while also making implicit assertions about the <strong>size and shape</strong> of the iterables you&rsquo;re unpacking.</p>

<p>The use for multiple assignment that I often see forgotten is its ability to <strong>replace hard coded indexes</strong>, including <strong>replacing hard coded slices</strong> (using the <code>*</code> syntax).
It&rsquo;s also common to overlook the fact that multiple assignment works <em>deeply</em> and can be used with both a <em>tuple-like</em> syntax and a <em>list-like</em> syntax.</p>

<p>It&rsquo;s tricky to recognize and remember all the cases that multiple assignment can come in handy.
Please feel free to use this article as your personal reference guide to multiple assignment.</p>

<h2>Get practice with multiple assignment</h2>

<p>You don&rsquo;t learn by reading articles like this one, <strong>you learn by writing code</strong>.</p>

<p>To get practice writing some readable code using tuple unpacking, sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a> using the form below.
If you sign up to Python Morsels using this form, I&rsquo;ll immediately send you an exercise that involves tuple unpacking.</p>

<form method="post" action="https://www.pythonmorsels.com/accounts/signup/">
  <input type="email" name="email" placeholder="Your email" class="subscribe-email form-big" required>
  <input type="hidden" name="exercise_track" value="beginner">
  <input type="hidden" name="form_id" value="tuple unpacking">
  <button type="submit" class="subscribe-btn form-big">Get my tuple unpacking exercise</button>
<br>

<small>
  I won't share you info with others (see the <a href="https://www.pythonmorsels.com/privacy/">Python Morsels Privacy Policy</a> for details).<br>
  This form is reCAPTCHA protected (Google <a href="https://policies.google.com/privacy">Privacy Policy</a> &amp; <a href="https://policies.google.com/terms">TOS</a>)
</small>

</form>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Craft Your Python Like Poetry]]></title>
    <link href="https://treyhunner.com/2017/07/craft-your-python-like-poetry/"/>
    <updated>2017-07-23T10:00:00-07:00</updated>
    <id>https://treyhunner.com/2017/07/craft-your-python-like-poetry</id>
    <content type="html"><![CDATA[<p>Line length is a big deal&hellip; programmers argue about it quite a bit.  PEP 8, the Python style guide, recommends a <a href="http://pep8.org/#maximum-line-length">79 character maximum line length</a> but concedes that a line length up to 100 characters is acceptable for teams that agree to use a specific longer line length.</p>

<p>So 79 characters is recommended&hellip; but isn&rsquo;t line length completely obsolete?  After all, programmers are no longer restricted by <a href="https://en.wikipedia.org/wiki/Punched_card">punch cards</a>, <a href="https://en.wikipedia.org/wiki/Teletype_Corporation">teletypes</a>, and 80 column <a href="https://en.wikipedia.org/wiki/Computer_terminal">terminals</a>.  The laptop screen I&rsquo;m typing this on can fit about 200 characters per line.</p>

<h2>Line length is not obsolete</h2>

<p>Line length is not a technical limitation: it&rsquo;s a human-imposed limitation.  Many programmers prefer short lines because <strong>long lines are hard to read</strong>.  This is true in typography and it&rsquo;s true in programming as well.</p>

<p>Short lines are easier to read.</p>

<p>In the typography world, a line length of 55 characters per line is recommended for electronic text (see <a href="https://en.wikipedia.org/wiki/Line_length">line length on Wikipedia</a>).  That doesn&rsquo;t mean we should use a 55 character limit though; typography and programming are different.</p>

<h2>Python isn&rsquo;t prose</h2>

<p>Python code isn&rsquo;t structured like prose.  English prose is structured in flowing sentences: each line wraps into the next line.  In Python, <strong>statements</strong> are somewhat like <strong>sentences</strong>, meaning each sentence begins at the <em>start</em> of each line.</p>

<p>Python code is more like poetry than prose.  Poets and Python programmers don&rsquo;t wrap lines once they hit an arbitrary length; they wrap lines when they make sense for readability and beauty.</p>

<pre><code>I stand amid the roar Of a surf-tormented shore, And I hold within my hand
Grains of the golden sand How few! yet how they creep Through my fingers to
the deep, While I weepwhile I weep! O God! can I not grasp Them with a
tighter clasp? O God! can I not save One from the pitiless wave? Is all that we
see or seem But a dream within a dream?
</code></pre>

<p>Don&rsquo;t wrap lines arbitrarily. Craft each line with care to help readers <strong>experience your code exactly the way you intended</strong>.</p>

<pre><code>I stand amid the roar
Of a surf-tormented shore,
And I hold within my hand
Grains of the golden sand
How few! yet how they creep
Through my fingers to the deep,
While I weepwhile I weep!
O God! can I not grasp
Them with a tighter clasp?
O God! can I not save
One from the pitiless wave?
Is all that we see or seem
But a dream within a dream?
</code></pre>

<h2>Examples</h2>

<p>It&rsquo;s not possible to make a single rule for when and how to wrap lines of code.  <a href="http://pep8.org/#indentation">PEP8 discusses line wrapping briefly</a>, but it only discusses one case of line wrapping and three different acceptable styles are provided, leaving the reader to choose which is best.</p>

<p>Line wrapping is best discussed through examples.  Let&rsquo;s look at a few examples of long lines and few variations for line wrapping for each.</p>

<h3>Example: Wrapping a Comprehension</h3>

<p>This line of code is over 79 characters long:</p>

<pre><code class="python">employee_hours = [schedule.earliest_hour for employee in self.public_employees for schedule in employee.schedules]
</code></pre>

<p>Here we&rsquo;ve wrapped that line of code so that it&rsquo;s two shorter lines of code:</p>

<pre><code class="python">employee_hours = [schedule.earliest_hour for employee in
                  self.public_employees for schedule in employee.schedules]
</code></pre>

<p>We&rsquo;re able to insert that line break in this line because we have an <strong>unclosed square bracket</strong>.  This is called an <strong>implicit line continuation</strong>.  Python knows we&rsquo;re continuing a line of code whenever there&rsquo;s a line break inside unclosed square brackets, curly braces, or parentheses.</p>

<p>This code still isn&rsquo;t very easy to read because the line break was inserted arbitrarily.  We simply wrapped this line just before a specific line length.  We were thinking about line length here, but we completely neglected to think about readability.</p>

<p>This code is the same as above, but we&rsquo;ve inserted line breaks in very particular places:</p>

<pre><code class="python">employee_hours = [schedule.earliest_hour
                  for employee in self.public_employees
                  for schedule in employee.schedules]
</code></pre>

<p>We have two lines breaks here and we&rsquo;ve purposely inserted them before our <code>for</code> clauses in this list comprehension.</p>

<p>Statements have logical components that make up a whole, the same way sentences have clauses that make up the whole.  We&rsquo;ve chosen to break up this list comprehension by inserting line breaks <strong>between these logical components</strong>.</p>

<p>Here&rsquo;s another way to break up this statement:</p>

<pre><code class="python">employee_hours = [
    schedule.earliest_hour
    for employee in self.public_employees
    for schedule in employee.schedules
]
</code></pre>

<p>Which of these methods you prefer is up to you.  It&rsquo;s important to make sure you break up the logical components though.  And whichever method you choose, <strong>be consistent</strong>!</p>

<h3>Example: Function Calls</h3>

<p>This is a Django model field with a whole bunch of arguments being passed to it:</p>

<pre><code class="python">default_appointment = models.ForeignKey(othermodel='AppointmentType',
                                        null=True, on_delete=models.SET_NULL,
                                        related_name='+')
</code></pre>

<p>We&rsquo;re already using an implicit line continuation to wrap these lines of code, but again we&rsquo;re wrapping this code at an arbitrary line length.</p>

<p>Here&rsquo;s the same Django model field with one argument specific per line:</p>

<pre><code class="python">default_appointment = models.ForeignKey(othermodel='AppointmentType',
                                        null=True,
                                        on_delete=models.SET_NULL,
                                        related_name='+')
</code></pre>

<p>We&rsquo;re breaking up the component parts (the arguments) of this statement onto separate lines.</p>

<p>We could also wrap this line by indenting each argument instead of aligning them:</p>

<pre><code class="python">default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+'
)
</code></pre>

<p>Notice we&rsquo;re also leaving that closing parenthesis on its own line.  We could additionally add a trailing comma if we wanted:</p>

<pre><code class="python">default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+',
)
</code></pre>

<p><strong>Which of these is the best way to wrap this line?</strong></p>

<p>Personally for this line I prefer that last approach: each argument on its own line, the closing parenthesis on its own line, and a comma after each argument.</p>

<p>It&rsquo;s important to decide what you prefer, reflect on why you prefer it, and always maintain consistency within each project/file you create.  And keep in mind that consistence of your personal style is less important than <strong>consistency within a single project</strong>.</p>

<h3>Example: Chained Function Calls</h3>

<p>Here&rsquo;s a long line of chained Django queryset methods:</p>

<pre><code class="python">    books = Book.objects.filter(author__in=favorite_authors).select_related('author', 'publisher').order_by('title')
</code></pre>

<p>Notice that there aren&rsquo;t parenthesis around this whole statement, so the only place we can currently wrap our lines is inside those parenthesis.  We could do something like this:</p>

<pre><code class="python">    books = Book.objects.filter(
        author__in=favorite_authors
    ).select_related(
        'author', 'publisher'
    ).order_by('title')
</code></pre>

<p>But that looks kind of weird and it doesn&rsquo;t really improve readability.</p>

<p>We could add backslashes at the end of each line to allow us to wrap at arbitrary places:</p>

<pre><code class="python">    books = Book.objects\
        .filter(author__in=favorite_authors)\
        .select_related('author', 'publisher')\
        .order_by('title')
</code></pre>

<p>This works, but <a href="http://pep8.org/#maximum-line-length">PEP8 recommends against this</a>.</p>

<p>We could wrap the whole statement in parenthesis, allowing us to use implicit line continuation wherever we&rsquo;d like:</p>

<pre><code class="python">    books = (Book.objects
        .filter(author__in=favorite_authors)
        .select_related('author', 'publisher')
        .order_by('title'))
</code></pre>

<p>It&rsquo;s not uncommon to see extra parenthesis added in Python code to allow implicit line continuations.</p>

<p>That indentation style is a little odd though.  We could align our code with the parenthesis instead:</p>

<pre><code class="python">    books = (Book.objects
             .filter(author__in=favorite_authors)
             .select_related('author', 'publisher')
             .order_by('title'))
</code></pre>

<p>Although I&rsquo;d probably prefer to align the dots in this case:</p>

<pre><code class="python">    books = (Book.objects
                 .filter(author__in=favorite_authors)
                 .select_related('author', 'publisher')
                 .order_by('title'))
</code></pre>

<p>A fully indentation-based style works too (we&rsquo;ve also moved <code>objects</code> to its own line here):</p>

<pre><code class="python">    books = (
        Book
        .objects
        .filter(author__in=favorite_authors)
        .select_related('author', 'publisher')
        .order_by('title')
    )
</code></pre>

<p>There are yet more ways to resolve this problem.  For example we could try to use intermediary variables to avoid line wrapping entirely.</p>

<p>Chained methods pose a different problem for line wrapping than single method calls and require a different solution.  Focus on readability when picking a preferred solution and be consistent with the solution you pick.  <strong>Consistency lies at the heart of readability</strong>.</p>

<h3>Example: Dictionary Literals</h3>

<p>I often define long dictionaries and lists defined in Python code.</p>

<p>Here&rsquo;s a dictionary definition that has been over multiple lines, with line breaks inserted as a maximum line length is approached:</p>

<pre><code class="python">MONTHS = {'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5,
          'June': 6, 'July': 7, 'August': 8, 'September': 9, 'October': 10,
          'November': 11, 'December': 12}
</code></pre>

<p>Here&rsquo;s the same dictionary with each key-value pair on its own line, aligned with the first key-value pair:</p>

<pre><code class="python">MONTHS = {'January': 1,
          'February': 2,
          'March': 3,
          'April': 4,
          'May': 5,
          'June': 6,
          'July': 7,
          'August': 8,
          'September': 9,
          'October': 10,
          'November': 11,
          'December': 12}
</code></pre>

<p>And the same dictionary again, with each key-value pair indented instead of aligned (with a trailing comma on the last line as well):</p>

<pre><code class="python">MONTHS = {
    'January': 1,
    'February': 2,
    'March': 3,
    'April': 4,
    'May': 5,
    'June': 6,
    'July': 7,
    'August': 8,
    'September': 9,
    'October': 10,
    'November': 11,
    'December': 12,
}
</code></pre>

<p>This is the strategy I prefer for wrapping long dictionaries and lists.  I very often wrap short dictionaries and lists this way as well, for the sake of readability.</p>

<h2>Python is Poetry</h2>

<p>The moment of <strong>peak readability</strong> is <strong>the moment just after you write a line of code</strong>.  Your code will be far less readable to you one day, one week, and one month after you&rsquo;ve written it.</p>

<p>When crafting Python code, use spaces and line breaks to split up the logical components of each statement.  Don&rsquo;t write a statement on a single line unless it&rsquo;s already <em>very</em> clear.  If you break each line over multiple lines for clarity, lines length shouldn&rsquo;t be a major concern because your lines of code will mostly be far shorter than 79 characters already.</p>

<p>Make sure to craft your code carefully as you write it because your future self will have a much more difficult time cleaning it up than you will <strong>right now</strong>.  So take that line of code you just wrote and carefully add line breaks to it.</p>

<p>If you found this article interesting, you might want to watch my <a href="https://youtu.be/knMg6G9_XCg?t=59s">Readability Counts</a> talk or read some of the <a href="https://treyhunner.com/blog/categories/readability/">other articles I&rsquo;ve written on code readability</a>.</p>
]]></content>
  </entry>
  
</feed>
