<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="https://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://treyhunner.com/"/>
  <updated>2020-01-14T07:44:25-08:00</updated>
  <id>https://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Passing a function as an argument to another function in Python]]></title>
    <link href="https://treyhunner.com/2020/01/passing-functions-as-arguments/"/>
    <updated>2020-01-14T08:00:00-08:00</updated>
    <id>https://treyhunner.com/2020/01/passing-functions-as-arguments</id>
    <content type="html"><![CDATA[<p>One of the more hair-raising facts we learn in my introductory Python trainings is that <strong>you can pass functions into other functions</strong>.
You can pass functions around because in Python, <strong>functions are objects</strong>.</p>

<p>You likely don&rsquo;t need to know about this in your first week of using Python, but as you dive deeper into Python you&rsquo;ll find that it can be quite convenient to understand how to pass a function into another function.</p>

<p>This is part 1 of what I expect to be a series on the various properties of &ldquo;function objects&rdquo;.
This article focuses on what a new Python programmer should know and appreciate about <strong>the object-nature of Python&rsquo;s functions</strong>.</p>

<ul data-toc=".entry-content"></ul>


<h2>Functions can be referenced</h2>

<p>If you try to use a function without putting parentheses after it Python won&rsquo;t complain but it also won&rsquo;t do anything useful:</p>

<pre><code class="pycon">&gt;&gt;&gt; def greet():
...     print("Hello world!")
...
&gt;&gt;&gt; greet
&lt;function greet at 0x7ff246c6d9d0&gt;
</code></pre>

<p>This applies to methods as well (<a href="https://docs.python.org/3/glossary.html#term-method">methods</a> are functions which live on objects):</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; numbers.pop
&lt;built-in method pop of list object at 0x7ff246c76a80&gt;
</code></pre>

<p>Python is allowing us to <em>refer</em> to these <em>function objects</em>, the same way we might refer to a string, a number, or a <code>range</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; "hello"
'hello'
&gt;&gt;&gt; 2.5
2.5
&gt;&gt;&gt; range(10)
range(0, 10)
</code></pre>

<p>Since we can refer to functions like any other object, we can point a variable to a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; gimme = numbers.pop
</code></pre>

<p>That <code>gimme</code> variable now points to the <code>pop</code> method on our <code>numbers</code> list.
So if we call <code>gimme</code>, it&rsquo;ll do the same thing that calling <code>numbers.pop</code> would have done:</p>

<pre><code class="pycon">&gt;&gt;&gt; gimme()
29
&gt;&gt;&gt; numbers
[2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; gimme(0)
2
&gt;&gt;&gt; numbers
[1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; gimme()
18
</code></pre>

<p>Note that we <strong>didn&rsquo;t make a new function</strong>.
We&rsquo;ve just pointed the <code>gimme</code> variable name to the <code>numbers.pop</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; gimme
&lt;built-in method pop of list object at 0x7ff246c76bc0&gt;
&gt;&gt;&gt; numbers.pop
&lt;built-in method pop of list object at 0x7ff246c76bc0&gt;
</code></pre>

<p>You can even store functions inside data structures and then reference them later:</p>

<pre><code class="pycon">&gt;&gt;&gt; def square(n): return n**2
...
&gt;&gt;&gt; def cube(n): return n**3
...
&gt;&gt;&gt; operations = [square, cube]
&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; for i, n in enumerate(numbers):
...     action = operations[i % 2]
...     print(f"{action.__name__}({n}):", action(n))
...
square(2): 4
cube(1): 1
square(3): 9
cube(4): 64
square(7): 49
cube(11): 1331
square(18): 324
cube(29): 24389
</code></pre>

<p>It&rsquo;s not very common to take a function and give it another name or to store it inside a data structure, but Python allows us to do these things because <strong>functions can be passed around, just like any other object</strong>.</p>

<h2>Functions can be passed into other functions</h2>

<p>Functions, like any other object, can be passed as an argument to another function.</p>

<p>For example we could define a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; def greet(name="world"):
...     """Greet a person (or the whole world by default)."""
...     print(f"Hello {name}!")
...
&gt;&gt;&gt; greet("Trey")
Hello Trey!
</code></pre>

<p>And then pass it into the built-in <code>help</code> function to see what it does:</p>

<pre><code class="pycon">&gt;&gt;&gt; help(greet)
Help on function greet in module __main__:

greet(name='world')
    Greet a person (or the whole world by default).
</code></pre>

<p>And we can pass the function into itself (yes this is weird), which converts it to a string here:</p>

<pre><code class="pycon">&gt;&gt;&gt; greet(greet)
Hello &lt;function greet at 0x7f93416be8b0&gt;!
</code></pre>

<p>There are actually quite a few functions built-in to Python that are specifically meant to accept other functions as arguments.</p>

<p>The built-in <code>filter</code> function accepts two things as an argument: a <code>function</code> and an <code>iterable</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; help(filter)

 |  filter(function or None, iterable) --&gt; filter object
 |
 |  Return an iterator yielding those items of iterable for which function(item)
 |  is true. If function is None, return the items that are true.
</code></pre>

<p>The given iterable (list, tuple, string, etc.) is looped over and the given function is called on each item in that iterable: whenever the function returns <code>True</code> (or another truthy value) the item is included in the <code>filter</code> output.</p>

<p>So if we pass <code>filter</code> an <code>is_odd</code> function (which returns <code>True</code> when given an odd number) and a list of numbers, we&rsquo;ll get back all of the numbers we gave it which are odd.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; def is_odd(n): return n % 2 == 1
...
&gt;&gt;&gt; filter(is_odd, numbers)
&lt;filter object at 0x7ff246c8dc40&gt;
&gt;&gt;&gt; list(filter(is_odd, numbers))
[1, 3, 7, 11, 29]
</code></pre>

<p>The object returned from <code>filter</code> is <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">a lazy iterator</a> so we needed to convert it to a <code>list</code> to actually see its output.</p>

<p>Since functions can be passed into functions, that also means that functions can accept another function as an argument.
The <code>filter</code> function assumes its first argument is a function.
You can think of the <code>filter</code> function as pretty much the same as this function:</p>

<pre><code class="python">def filter(predicate, iterable):
    return (
        item
        for item in iterable
        if predicate(item)
    )
</code></pre>

<p>This function expects the <code>predicate</code> argument to be a function (technically it could be any <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/">callable</a>).
When we call that function (with <code>predicate(item)</code>), we pass a single argument to it and then check the truthiness of its return value.</p>

<h2>Lambda functions are an example of this</h2>

<p>A lambda expression is a special syntax in Python for creating an <a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous function</a>.
When you evaluate a <strong>lambda expression</strong> the object you get back is called a <strong>lambda function</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; is_odd = lambda n: n % 2 == 1
&gt;&gt;&gt; is_odd(3)
True
&gt;&gt;&gt; is_odd(4)
False
</code></pre>

<p>Lambda functions are pretty much just like regular Python functions, with a few caveats.</p>

<p>Unlike other functions, lambda functions don&rsquo;t have a name (their name shows up as <code>&lt;lambda&gt;</code>).
They also can&rsquo;t have docstrings and they can only contain a single Python expression.</p>

<pre><code class="pycon">&gt;&gt;&gt; add = lambda x, y: x + y
&gt;&gt;&gt; add(2, 3)
5
&gt;&gt;&gt; add
&lt;function &lt;lambda&gt; at 0x7ff244852f70&gt;
&gt;&gt;&gt; add.__doc__
</code></pre>

<p>You can think of a lambda expression as a shortcut for making a function which will evaluate a single Python expression and return the result of that expression.</p>

<p>So defining a lambda expression doesn&rsquo;t actually evaluate that expression: it returns a function that can evaluate that expression later.</p>

<pre><code class="pycon">&gt;&gt;&gt; greet = lambda name="world": print(f"Hello {name}")
&gt;&gt;&gt; greet("Trey")
Hello Trey
&gt;&gt;&gt; greet()
Hello world
</code></pre>

<p>I&rsquo;d like to note that all three of the above examples of <code>lambda</code> are poor examples.
If you want a variable name to point to a function object that you can use later, you should use <code>def</code> to define a function: that&rsquo;s the <em>usual</em> way to define a function.</p>

<pre><code class="pycon">&gt;&gt;&gt; def is_odd(n): return n % 2 == 1
...
&gt;&gt;&gt; def add(x, y): return x + y
...
&gt;&gt;&gt; def greet(name="world"): print(f"Hello {name}")
...
</code></pre>

<p>Lambda expressions are for when we&rsquo;d like to define a function and <strong>pass it into another function immediately</strong>.</p>

<p>For example here we&rsquo;re using <code>filter</code> to get even numbers, but we&rsquo;re using a lambda expression so we don&rsquo;t have to define an <code>is_even</code> function before we use it:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers
[2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; list(filter(lambda n: n % 2 == 0, numbers))
[2, 4, 18]
</code></pre>

<p>This is <em>the most appropriate</em> use of lambda expressions: passing a function into another function while defining that passed function all on one line of code.</p>

<p>As I&rsquo;ve written about in <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/">Overusing lambda expressions</a>, I&rsquo;m not a fan of Python&rsquo;s lambda expression syntax.
Whether or not you like this syntax, you should know that this syntax is just a shortcut for creating a function.</p>

<p>Whenever you see <code>lambda</code> expressions, keep in mind that:</p>

<ol>
<li>A lambda expression is a special syntax for creating a function and passing it to another function all on one line of code</li>
<li>Lambda functions are just like all other function objects: neither is more special than the other and both can be passed around</li>
</ol>


<p>All functions in Python can be passed as an argument to another function (that just happens to be the <em>sole</em> purpose of lambda functions).</p>

<h2>A common example: key functions</h2>

<p>Besides the built-in <code>filter</code> function, where will you ever see a function passed into another function?
Probably the most common place you&rsquo;ll see this in Python itself is with a <strong>key function</strong>.</p>

<p>It&rsquo;s a common convention for functions which accept an iterable-to-be-sorted/ordered to also accept a <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">named argument</a> called <code>key</code>.
This <code>key</code> argument should be a function <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/">or another callable</a>.</p>

<p>The <a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/#sorted">sorted</a>, <a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/#min_and_max">min</a>, and <a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/#min_and_max">max</a> functions all follow this convention of accepting a <code>key</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; def normalize_case(s): return s.casefold()
...
&gt;&gt;&gt; sorted(fruits, key=normalize_case)
['Cherimoya', 'jujube', 'kumquat', 'longan', 'Loquat']
&gt;&gt;&gt; min(fruits, key=normalize_case)
'Cherimoya'
&gt;&gt;&gt; max(fruits, key=normalize_case)
'Loquat'
</code></pre>

<p>That <a href="https://docs.python.org/3/glossary.html#term-key-function">key function</a> is called for each value in the given iterable and the return value is used to order/sort each of the iterable items.
You can think of this key function as computing <strong>a comparison key</strong> for each item in the iterable.</p>

<p>In the above example our comparison key returns a lowercased string, so each string is compared by its lowercased version (which results in a case-insensitive ordering).</p>

<p>We used a <code>normalize_case</code> function to do this, but the same thing could be done using <code>str.casefold</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; sorted(fruits, key=str.casefold)
['Cherimoya', 'jujube', 'kumquat', 'longan', 'Loquat']
</code></pre>

<p><strong>Note</strong>: That <code>str.casefold</code> trick is a bit odd if you aren&rsquo;t familiar with how classes work.
Classes store the <em>unbound methods</em> that will accept an instance of that class when called.
We normally type <code>my_string.casefold()</code> but <code>str.casefold(my_string)</code> is what Python translates that to.
That&rsquo;s a story for another time.</p>

<p>Here we&rsquo;re finding the string with the most letters in it:</p>

<pre><code class="pycon">&gt;&gt;&gt; max(fruits, key=len)
'Cherimoya'
</code></pre>

<p>If there are multiple maximums or minimums, the earliest one <em>wins</em> (that&rsquo;s how <code>min</code>/<code>max</code> work):</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; min(fruits, key=len)
'Loquat'
&gt;&gt;&gt; sorted(fruits, key=len)
['Loquat', 'longan', 'jujube', 'kumquat', 'Cherimoya']
</code></pre>

<p>Here&rsquo;s a function which will return a 2-item tuple containing the length of a given string and the case-normalized version of that string:</p>

<pre><code class="python">def length_and_alphabetical(string):
    """Return sort key: length first, then case-normalized string."""
    return (len(string), string.casefold())
</code></pre>

<p>We could pass this <code>length_and_alphabetical</code> function as the <code>key</code> argument to <code>sorted</code> to sort our strings by their length first and then by their case-normalized representation:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; fruits_by_length = sorted(fruits, key=length_and_alphabetical)
&gt;&gt;&gt; fruits_by_length
['jujube', 'longan', 'Loquat', 'kumquat', 'Cherimoya']
</code></pre>

<p>This relies on the fact that <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/">Python&rsquo;s ordering operators do deep comparisons</a>.</p>

<h2>Other examples of passing a function as an argument</h2>

<p>The <code>key</code> argument accepted by <code>sorted</code>, <code>min</code>, and <code>max</code> is just one common example of passing functions into functions.</p>

<p>Two more function-accepting Python built-ins are <code>map</code> and <code>filter</code>.</p>

<p>We&rsquo;ve already seen that <code>filter</code> will <em>filter</em> our list based on a given function&rsquo;s return value.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers
[2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; def is_odd(n): return n % 2 == 1
...
&gt;&gt;&gt; list(filter(is_odd, numbers))
[1, 3, 7, 11, 29]
</code></pre>

<p>The <code>map</code> function will call the given function on each item in the given iterable and use the result of that function call as the new item:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(map(is_odd, numbers))
[False, True, True, False, True, True, False, True]
</code></pre>

<p>For example here we&rsquo;re converting numbers to strings and squaring numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(map(str, numbers))
['2', '1', '3', '4', '7', '11', '18', '29']
&gt;&gt;&gt; list(map(lambda n: n**2, numbers))
[4, 1, 9, 16, 49, 121, 324, 841]
</code></pre>

<p><strong>Note</strong>: as I noted in my article on overusing lambda, I personally prefer to <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/#Overuse:_lambda_with_map_and_filter">use generator expressions instead of the <code>map</code> and <code>filter</code> functions</a>.</p>

<p>Similar to <code>map</code>, and <code>filter</code>, there&rsquo;s also <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile">takewhile</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile">dropwhile</a> from the <code>itertools</code> module.
The first one is like <code>filter</code> except it stops once it finds a value for which the <em>predicate function</em> is false.
The second one does the opposite: it only includes values after the predicate function has become false.</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import takewhile, dropwhile
&gt;&gt;&gt; colors = ['red', 'green', 'orange', 'purple', 'pink', 'blue']
&gt;&gt;&gt; def short_length(word): return len(word) &lt; 6
...
&gt;&gt;&gt; list(takewhile(short_length, colors))
['red', 'green']
&gt;&gt;&gt; list(dropwhile(short_length, colors))
['orange', 'purple', 'pink', 'blue']
</code></pre>

<p>And there&rsquo;s <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate">itertools.accumulate</a>, which both call a 2-argument function to accumulate values as they loop:</p>

<pre><code class="pycon">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from itertools import accumulate
&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; def product(x, y): return x * y
...
&gt;&gt;&gt; reduce(product, numbers)
168
&gt;&gt;&gt; list(accumulate(numbers, product))
[2, 2, 6, 24, 168]
</code></pre>

<p>The <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">defaultdict</a> class in the <code>collections</code> module is another example.
The <code>defaultdict</code> class creates dictionary-like objects which will never raise a <code>KeyError</code> when a missing key is accessed, but will instead add a new value to the dictionary automatically.</p>

<pre><code class="pycon">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; counts = defaultdict(int)
&gt;&gt;&gt; counts['jujubes']
0
&gt;&gt;&gt; counts
defaultdict(&lt;class 'int'&gt;, {'jujubes': 0})
</code></pre>

<p>This <code>defaultdict</code> class accepts a <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/">callable</a> (function or class) that will be called to create a default value whenever a missing key is accessed.</p>

<p>The above code worked because <code>int</code> returns <code>0</code> when called with no arguments:</p>

<pre><code class="pycon">&gt;&gt;&gt; int()
0
</code></pre>

<p>Here the default value is <code>list</code>, which returns a new list when called with no arguments.</p>

<pre><code class="pycon">&gt;&gt;&gt; things_by_color = defaultdict(list)
&gt;&gt;&gt; things_by_color['purple'].append('socks')
&gt;&gt;&gt; things_by_color['purple'].append('shoes')
&gt;&gt;&gt; things_by_color
defaultdict(&lt;class 'list'&gt;, {'purple': ['socks', 'shoes']})
</code></pre>

<p>The <a href="https://docs.python.org/3/library/functools.html#functools.partial">partial</a> function in the <code>functools</code> module is another example.
<code>partial</code> accepts a function and any number of arguments and returns a new function (technically it returns a <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#Callable_objects">callable object</a>).</p>

<p>Here&rsquo;s an example of <code>partial</code> used to &ldquo;bind&rdquo; the <code>sep</code> keyword argument to the <code>print</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; print_each = partial(print, sep='\n')
</code></pre>

<p>The <code>print_each</code> function returned now does the same thing as if <code>print</code> was called with <code>sep='\n'</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; print(1, 2, 3)
1 2 3
&gt;&gt;&gt; print(1, 2, 3, sep='\n')
1
2
3
&gt;&gt;&gt; print_each(1, 2, 3)
1
2
3
</code></pre>

<p>You&rsquo;ll also find functions-that-accept-functions in third-party libraries, like <a href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#default">in Django</a>, and <a href="https://numpy.org/doc/1.17/reference/generated/numpy.fromfunction.html">in numpy</a>.
Anytime you see a class or a function with documentation stating that one of its arguments should be a <strong>callable</strong> or a <strong>callable object</strong>, that means &ldquo;you could pass in a function here&rdquo;.</p>

<h2>A topic I&rsquo;m skipping over: nested functions</h2>

<p>Python also supports nested functions (functions defined inside of other functions).
Nested functions power Python&rsquo;s <a href="https://docs.python.org/3/glossary.html#term-decorator">decorator</a> syntax.</p>

<p>I&rsquo;m not going to discuss nested functions in this article because nested functions warrant exploration of <a href="https://en.wikipedia.org/wiki/Non-local_variable">non-local variables</a>, <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a>, and other weird corners of Python that you don&rsquo;t need to know when you&rsquo;re first getting started with treating functions as objects.</p>

<p>I plan to write a follow-up article on this topic and link to it here later.
In the meantime, if you&rsquo;re interested in nested functions in Python, a search for <a href="https://duckduckgo.com/?q=higher-order+functions+in+Python">higher order functions in Python</a> may be helpful.</p>

<h2>Treating functions as objects is normal</h2>

<p>Python has <a href="https://en.wikipedia.org/wiki/First-class_function">first-class functions</a>, which means:</p>

<ol>
<li>You can assign functions to variables</li>
<li>You can store functions in lists, dictionaries, or other data structures</li>
<li>You can pass functions into other functions</li>
<li>You can write functions that return functions</li>
</ol>


<p>It might seem odd to treat functions as objects, but it&rsquo;s not that unusual in Python.
By my count, about 15% of the Python built-ins are meant to accept functions as arguments (<code>min</code>, <code>max</code>, <code>sorted</code>, <code>map</code>, <code>filter</code>, <code>iter</code>, <code>property</code>, <code>classmethod</code>, <code>staticmethod</code>, <code>callable</code>).</p>

<p>The most important uses of Python&rsquo;s first-class functions are:</p>

<ol>
<li>Passing a <code>key</code> function to the built-in <code>sorted</code>, <code>min</code>, and <code>max</code> functions</li>
<li>Passing functions into looping helpers like <code>filter</code> and <code>itertools.dropwhile</code></li>
<li>Passing a &ldquo;default-value generating factory function&rdquo; to classes like <code>defaultdict</code></li>
<li>&ldquo;Partially-evaluating&rdquo; functions by passing them into <code>functools.partial</code></li>
</ol>


<p>This topics goes <em>much deeper</em> than what I&rsquo;ve discussed here, but until you find yourself writing decorator functions, you probably don&rsquo;t need to explore this topic any further.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cyber Monday Python Sales]]></title>
    <link href="https://treyhunner.com/2019/12/cyber-monday-python-sales/"/>
    <updated>2019-12-02T02:00:00-08:00</updated>
    <id>https://treyhunner.com/2019/12/cyber-monday-python-sales</id>
    <content type="html"><![CDATA[<p>I&rsquo;m running <a href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/">a sale</a> that ends in 24 hours, but I&rsquo;m not the only one.
This post is a compilation of the different Cyber Monday deals I&rsquo;ve found related to Python and Python learning.</p>

<h3>Python Morsels, weekly skill-building for professional Pythonistas</h3>

<p><a href="https://www.pythonmorsels.com/">Python Morsels</a> is my weekly Python skill-building service.</p>

<p>I&rsquo;m offering something sort of like a &ldquo;buy one get one free&rdquo; sale this year.</p>

<p>You can pay $200 to get 2 redemption codes, each worth 12 months of Python Morsels.</p>

<p>You can use one code for yourself and give one to a friend.
Or you could be extra generous and give them both away to two friends.
Either way, 2 people are each getting one year&rsquo;s worth of weekly Python training.</p>

<p>You can find <a href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/">more details on this sale here</a>.</p>

<h3>Data School&rsquo;s Machine Learning course</h3>

<p>Kevin Markham of Data School is selling his &ldquo;Machine Learning with Text in Python&rdquo; course for $195 (it&rsquo;s usually $295).
You can find more details on this sale <a href="https://www.dataschool.io/black-friday/">on the Data School Black Friday post</a>.</p>

<h3>Talk Python Course Bundle</h3>

<p>Michael Kennedy is selling a bundle that includes <a href="https://training.talkpython.fm/black-friday-2019">every Talk Python course for $250</a>.</p>

<p>There are 20 courses included in this bundle.
If you&rsquo;re into Python and you don&rsquo;t already own most of these courses, this bundle could be a really good deal for you.</p>

<h3>Reuven Lerner&rsquo;s Python courses</h3>

<p>Reuven Lerner is offering a <a href="https://lerner.co.il/2019/11/28/my-black-friday-sale-is-live-take-50-off-any-course-in-python-or-data-science/">50% off sale on his courses</a>.
Reuven has courses on Python, Git, and regular expressions.</p>

<p>This sale also includes Reuven&rsquo;s <a href="https://store.lerner.co.il/wpe?coupon=BF2019">Weekly Python Exercise</a>, which is similar to <a href="https://www.pythonmorsels.com/">Python Morsels</a>, but has its own flavor.
You could sign up for both if you want double the weekly learning.</p>

<h3>Real Python courses</h3>

<p>Real Python is also offering <a href="https://realpython.com/account/join/?c=blackfriday2019">$40 off their annual memberships</a>.
Real Python has many tutorials and courses as well.</p>

<h3>PyBites Code Challenges</h3>

<p>Bob and Julian of PyBites are offering their a <a href="https://gumroad.com/l/Xhxeo/teachingpython">40% discount off their Newbie Bites</a> on their PyBites Code Challenges platform.</p>

<p>If you&rsquo;re new to Python and programming, check out their newbie bites.</p>

<h3>Automate the Boring Stuff Course (for free!)</h3>

<p>Al Sweigart is offering <a href="https://www.udemy.com/course/automate/?couponCode=DEC2019FREE">free lifetime access to his Automate the Boring Stuff with Python course</a> on Udemy until Wednesday.
It&rsquo;s hard to beat free!</p>

<h3>Other Cyber Monday deals?</h3>

<p>If you have questions about the <a href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/">Python Morsels sale</a>, <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a>.</p>

<p>The Python Morsels sale and likely all the other sales above will end in the next 24 hours, probably sooner depending on when you&rsquo;re reading this.</p>

<p>So go check them out!</p>

<p>Did I miss a deal that you know about?
Link to it in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Black Friday Sale: Gift Python Morsels to a Friend]]></title>
    <link href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/"/>
    <updated>2019-11-29T15:00:00-08:00</updated>
    <id>https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend</id>
    <content type="html"><![CDATA[<p>From today until the end of Monday December 2nd, I&rsquo;m <a href="http://trey.io/sale2019">selling bundles</a> of two 52-week Python Morsels redemption codes.</p>

<p>You can buy 12 months of Python Morsels for yourself and <strong>gift 12 months of Python Morsels to a friend for free</strong>!</p>

<p>Or, if you&rsquo;re extra generous, you can buy two redemption codes (for the price of one) and gift them both to <em>two friends</em>.</p>

<h3>What is Python Morsels?üêçüç™</h3>

<p><a href="https://pythonmorsels.com">Python Morsels</a> is a weekly Python skill-building service for professional Python developers.
Subscribers receive one Python exercise every week in the Python skill level of their choosing (novice, intermediate, advanced).</p>

<p>Each exercise is designed to help you <strong>think the way Python thinks</strong>, so you can write your code less like a C/Java/Perl developer would and more like a fluent Pythonista would.
  Each programming language has its own unique ways of looking at the world: Python Morsels will help you embrace Python&rsquo;s.</p>

<p>One year&rsquo;s worth of Python Morsels will help even experienced Python developers <strong>deepen their Python skills</strong> and <strong>find new insights about Python</strong> to incorporate into their day-to-day work.</p>

<h3>How does this work? ü§î</h3>

<p>Normally a 12 month Python Morsels subscription costs $200.
For $200, I&rsquo;m instead selling two redemption codes, each of which can be used for 12 months (52 weeks) of Python Morsels exercises.</p>

<p>With this sale, you&rsquo;ll get two 12-month redemption codes for the price of one.
So you&rsquo;ll get 1 year of Python Morsels for 2 friends for just $200.</p>

<p>These codes can be used at any time and users of these codes will always maintain access to the 52 exercises received over the 12 month period. You can use one of these codes to extend your current subscription, but new users can also use this redemption code without signing up for an ongoing subscription.</p>

<p>Only one of these codes can be used per account (though you can purchase as many as you&rsquo;d like to gift to others).</p>

<h3>What will I (and my friends) get with Python Morsels? üéÅ</h3>

<p>With Python Morsels you&rsquo;ll get:</p>

<ul>
<li><strong>An email every Monday</strong> which includes a detailed problem to solve using Python</li>
<li>Multiple bonuses for almost every problem (most have 3 bonuses, almost all have 2) so you can <strong>re-adjust your difficulty level on a weekly basis</strong></li>
<li>Hints for each problem which you can use when you get stuck</li>
<li>An online progress tracking tool to keep track of which exercises you&rsquo;ve solved and how many bonuses you solved for each exercise</li>
<li><strong>Automated tests</strong> (to ensure correctness) which you can run locally and which also run automatically when you submit your solutions</li>
<li>An email every Wednesday with a <strong>detailed walkthrough of various solutions (usually 5-10)</strong> for each problem, including walkthroughs of each bonus and a discussion of why some solutions may be better than others</li>
<li>A skill level selection tool (novice, intermediate, advanced) which you can adjust based on your Python experience</li>
<li>A web interface you can come back to even after your 12 months are over</li>
</ul>


<h3>Okay, I&rsquo;m interested. Now what? ‚ú®</h3>

<p>First of all, don&rsquo;t wait. This buy-one-get-one-free sale ends Monday!</p>

<p>You can sign up and purchase 2 redemption codes by visiting <a href="http://trey.io/sale2019">http://trey.io/sale2019</a></p>

<p>Note that you need to create a Python Morsels account to purchase the redemption codes.
You don&rsquo;t need to have an on-going subscription, you just need an account.</p>

<p>If you have any questions about this sale, please don&rsquo;t hesitate to <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a>.</p>

<p><a href="http://trey.io/sale2019">Go get your Python Morsels redemption codes</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Loop Better: a deeper look at iteration in Python]]></title>
    <link href="https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python/"/>
    <updated>2019-06-18T09:15:00-07:00</updated>
    <id>https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python</id>
    <content type="html"><![CDATA[<p>Python&rsquo;s <code>for</code> loops don&rsquo;t work the way <code>for</code> loops do in other languages.  In this article we&rsquo;re going to dive into Python&rsquo;s <code>for</code> loops to take a look at how they work under the hood and why they work the way they do.</p>

<ol data-toc=".entry-content" data-toc-headings="h2"></ol>


<p><strong>Note</strong>: This article is based on my <a href="https://youtu.be/JYuE8ZiDPl4">Loop Better talk</a>.
It was originally published <a href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python">on opensource.com</a>.</p>

<h2>Looping Gotchas</h2>

<p>We&rsquo;re going to start off our journey by taking a look at some &ldquo;gotchas&rdquo;.  After we&rsquo;ve learned how looping works in Python, we&rsquo;ll take another look at these gotchas and explain what&rsquo;s going on.</p>

<h3>Gotcha 1: Looping Twice</h3>

<p>Let&rsquo;s say we have a list of numbers and a generator that will give us the squares of those numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>We can pass our generator object to the <code>tuple</code> constructor to make a tuple out of it:</p>

<pre><code class="pycon">&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre>

<p>If we then take the same generator object and pass it to the <code>sum</code> function we might expect that we&rsquo;d get the sum of these numbers, which would be 88.</p>

<pre><code class="pycon">&gt;&gt;&gt; sum(squares)
0
</code></pre>

<p>Instead we get <code>0</code>.</p>

<h3>Gotcha 2: Containment Checking</h3>

<p>Let&rsquo;s take the same list of numbers and the same generator object:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we ask whether <code>9</code> is in our <code>squares</code> generator, Python will tell us that 9 <em>is</em> in <code>squares</code>.  But if we ask the <em>same question again</em>, Python will tell us that 9 <em>is not</em> in <code>squares</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; 9 in squares
False
</code></pre>

<p>We asked the same question twice and Python gave us two different answers.</p>

<h3>Gotcha 3: Unpacking</h3>

<p>This dictionary has two key-value pairs:</p>

<pre><code class="pycon">&gt;&gt;&gt; counts = {'apples': 2, 'oranges': 1}
</code></pre>

<p>Let&rsquo;s unpack this dictionary using multiple assignment:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = counts
</code></pre>

<p>You might expect that when unpacking this dictionary, we&rsquo;ll get key-value pairs or maybe that we&rsquo;ll get an error.</p>

<p>But unpacking dictionaries doesn&rsquo;t raise errors and it doesn&rsquo;t return key-value pairs.  When you unpack dictionaries you get keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; x
'apples'
</code></pre>

<p>We&rsquo;ll come back to these gotchas after we&rsquo;ve learned a bit about the logic that powers these Python snippets.</p>

<h2>Review: Python&rsquo;s for loop</h2>

<p>Python doesn&rsquo;t have traditional <code>for</code> loops.  To explain what I mean, let&rsquo;s take a look at a <code>for</code> loop in another programming language.</p>

<p>This is a traditional C-style <code>for</code> loop written in JavaScript:</p>

<pre><code class="javascript">let numbers = [1, 2, 3, 5, 7];
for (let i = 0; i &lt; numbers.length; i += 1) {
    print(numbers[i])
}
</code></pre>

<p>JavaScript, C, C++, Java, PHP, and a whole bunch of other programming languages all have this kind of <code>for</code> loop.  <strong>But Python doesn&rsquo;t</strong>.</p>

<p>Python <strong>does not</strong> have traditional C-style <code>for</code> loops.  We do have something that we <em>call</em> a <code>for</code> loop in Python, but it works like a <a href="https://en.wikipedia.org/wiki/Foreach">foreach loop</a>.</p>

<p>This is Python&rsquo;s flavor of <code>for</code> loop:</p>

<pre><code class="python">numbers = [1, 2, 3, 5, 7]
for n in numbers:
    print(n)
</code></pre>

<p>Unlike traditional C-style <code>for</code> loops, Python&rsquo;s <code>for</code> loops don&rsquo;t have index variables.  There&rsquo;s no index initializing, bounds checking, or index incrementing.  Python&rsquo;s <code>for</code> loops do <em>all the work</em> of looping over our <code>numbers</code> list for us.</p>

<p>So while we do have <code>for</code> loops in Python, we do not have have traditional C-style <code>for</code> loops.  The thing that <em>we</em> call a <code>for</code> loop works very differently.</p>

<h2>Definitions: Iterables and Sequences</h2>

<p>Now that we&rsquo;ve addressed the index-free <code>for</code> loop in our Python room, let&rsquo;s get some definitions out of the way now.</p>

<p>An <strong>iterable</strong> is anything you can loop over with a <code>for</code> loop in Python.
Iterables can be looped over and anything that can be looped over is an iterable.</p>

<pre><code class="python">for item in some_iterable:
    print(item)
</code></pre>

<p>Sequences are a very common type of iterable.
Lists, tuples, and strings are all sequences.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = "hello there"
</code></pre>

<p>Sequences are iterables which have a specific set of features.
They can be indexed starting from <code>0</code> and ending at one less than the length of the sequence, they have a length, and they can be sliced.
Lists, tuples, strings and <em>all other</em> sequences work this way.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers[0]
1
&gt;&gt;&gt; coordinates[2]
7
&gt;&gt;&gt; words[4]
'o'
</code></pre>

<p>Lots of things in Python are iterables, but not all iterables are sequences.  Sets, dictionaries, files, and generators are all iterables but none of these things are sequences.</p>

<pre><code class="pycon">&gt;&gt;&gt; my_set = {1, 2, 3}
&gt;&gt;&gt; my_dict = {'k1': 'v1', 'k2': 'v2'}
&gt;&gt;&gt; my_file = open('some_file.txt')
&gt;&gt;&gt; squares = (n**2 for n in my_set)
</code></pre>

<p>So anything that can be looped over with a <code>for</code> loop is an iterable and sequences are one type of iterable but Python has many other kinds of iterables as well.</p>

<h2>Python&rsquo;s for loops don&rsquo;t use indexes</h2>

<p>You might think that under the hood, Python&rsquo;s <code>for</code> loops use indexes to loop.
Here we&rsquo;re manually looping over an iterable using a <code>while</code> loop and indexes:</p>

<pre><code class="python">numbers = [1, 2, 3, 5, 7]
i = 0
while i &lt; len(numbers):
    print(numbers[i])
    i += 1
</code></pre>

<p>This works for lists, but it won&rsquo;t work for everything.  This way of looping <strong>only works for sequences</strong>.</p>

<p>If we try to manually loop over a set using indexes, we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon', 'apple', 'orange', 'watermelon'}
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; len(fruits):
...     print(fruits[i])
...     i += 1
...
Traceback (most recent call last):
File "&lt;stdin&gt;", line 2, in &lt;module&gt;
TypeError: 'set' object does not support indexing
</code></pre>

<p>Sets are not sequences so they don&rsquo;t support indexing.</p>

<p>We <em>cannot</em> manually loop over every iterable in Python by using indexes.
This simply won&rsquo;t work for iterables that aren&rsquo;t sequences.</p>

<h2>Iterators power for loops</h2>

<p>So we&rsquo;ve seen that Python&rsquo;s <code>for</code> loops must not be using indexes under the hood.
Instead, Python&rsquo;s <code>for</code> loops use <strong>iterators</strong>.</p>

<p>Iterators are the things that power iterables.
You can get an iterator from <em>any</em> iterable.
And you can use an iterator to manually loop over the iterable it came from.</p>

<p>Let&rsquo;s take a look at how that works.</p>

<p>Here are three iterables: a set, a tuple, and a string.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = {1, 2, 3, 5, 7}
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = "hello there"
</code></pre>

<p>We can ask each of these iterables for an <em>iterator</em> using Python&rsquo;s built-in <code>iter</code> function.
Passing an iterable to the <code>iter</code> function will always give us back an iterator, no matter what type of iterable we&rsquo;re working with.</p>

<pre><code class="pycon">&gt;&gt;&gt; iter(numbers)
&lt;set_iterator object at 0x7f2b9271c860&gt;
&gt;&gt;&gt; iter(coordinates)
&lt;tuple_iterator object at 0x7f2b9271ce80&gt;
&gt;&gt;&gt; iter(words)
&lt;str_iterator object at 0x7f2b9271c860&gt;
</code></pre>

<p>Once we have an iterator, the one thing we can do with it is get its next item by passing it to the built-in <code>next</code> function.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; my_iterator = iter(numbers)
&gt;&gt;&gt; next(my_iterator)
1
&gt;&gt;&gt; next(my_iterator)
2
</code></pre>

<p>Iterators are stateful, meaning once you&rsquo;ve consumed an item from them it&rsquo;s gone.</p>

<p>If you ask for the <code>next</code> item from an iterator and there are no more items, you&rsquo;ll get a <code>StopIteration</code> exception:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
3
&gt;&gt;&gt; next(iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>So you can get an iterator from every iterable.
And the only thing that you can do with iterators is ask them for their next item using the <code>next</code> function.
And if you pass them to <code>next</code> but they don&rsquo;t have a next item, a <code>StopIteration</code> exception will be raised.</p>

<p><img src="/images/hello-kitty-pez.jpg" width="512" height="384" title="&ldquo;Hello Kitty PEZ dispenser&rdquo;" ></p>

<p><a href="https://www.flickr.com/photos/30223382@N06/4151828376">Hello Kitty PEZ dispenser photo</a> by Deborah Austin / <a href="https://creativecommons.org/licenses/by/2.0/">CC BY</a></p>

<p>You can think of iterators as like Hello Kitty PEZ dispensers that cannot be reloaded.
You can take PEZ out, but once a PEZ is removed it can&rsquo;t be put back and once the dispenser is empty, it&rsquo;s useless.</p>

<h2>Looping without a for loop</h2>

<p>Now that we&rsquo;ve learned about iterators and the <code>iter</code> and <code>next</code> functions, we&rsquo;re going to try manually looping over an iterable without using a <code>for</code> loop.</p>

<p>We&rsquo;ll do so by attempting to turn this <code>for</code> loop into a <code>while</code> loop:</p>

<pre><code class="python">def funky_for_loop(iterable, action_to_do):
    for item in iterable:
        action_to_do(item)
</code></pre>

<p>To do this we&rsquo;ll:</p>

<ol>
<li>Get an iterator from the given iterable</li>
<li>Repeatedly get the next item from the iterator</li>
<li>Execute the body of the <code>for</code> loop if we successfully got the next item</li>
<li>Stop our loop if we got a <code>StopIteration</code> exception while getting the next item</li>
</ol>


<pre><code class="python">def funky_for_loop(iterable, action_to_do):
    iterator = iter(iterable)
    done_looping = False
    while not done_looping:
        try:
            item = next(iterator)
        except StopIteration:
            done_looping = True
        else:
            action_to_do(item)
</code></pre>

<p>We&rsquo;ve just re-invented a <code>for</code> loop by using a <code>while</code> loop and iterators.</p>

<p>The above code pretty much defines the way looping works under the hood in Python.  If you understand the way the built-in <code>iter</code> and <code>next</code> functions work for looping over things, you understand how Python&rsquo;s <code>for</code> loops work.</p>

<p>In fact you&rsquo;ll understand a little bit more than just how <code>for</code> loops work in Python.  All forms of looping over iterables work this way.</p>

<p><strong>The iterator protocol</strong> is a fancy way of saying &ldquo;how looping over iterables works in Python&rdquo;.
It&rsquo;s essentially the definition of the way the <code>iter</code> and <code>next</code> functions work in Python.
All forms of iteration in Python are powered by the iterator protocol.</p>

<p>The iterator protocol is used by <code>for</code> loops (as we&rsquo;ve already seen):</p>

<pre><code class="python">for n in numbers:
    print(n)
</code></pre>

<p>Multiple assignment also uses the iterator protocol:</p>

<pre><code class="python">x, y, z = coordinates
</code></pre>

<p>Star expressions use the iterator protocol:</p>

<pre><code class="python">a, b, *rest = numbers
print(*numbers)
</code></pre>

<p>And many built-in functions rely on the iterator protocol:</p>

<pre><code class="python">unique_numbers = set(numbers)
</code></pre>

<p>Anything in Python that works with an <em>iterable</em> probably uses the iterator protocol in some way.
Any time you&rsquo;re looping over an iterable in Python, you&rsquo;re relying on the iterator protocol.</p>

<h2>Generators are iterators</h2>

<p>So you might be thinking: iterators seem cool, but they also just seem like an implementation detail and we might not need to <em>care</em> about them as users of Python.</p>

<p>I have news for you: it&rsquo;s very common to work directly with iterators in Python.</p>

<p>The <code>squares</code> object here is a generator:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>And generators are iterators, meaning you can call <code>next</code> on a generator to get its next item:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(squares)
1
&gt;&gt;&gt; next(squares)
4
</code></pre>

<p>But if you&rsquo;ve ever used a generator before, you probably know that you can also loop over generators:</p>

<pre><code class="pycon">&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; for n in squares:
...     print(n)
...
1
4
9
</code></pre>

<p>If you can loop over something in Python, it&rsquo;s an <strong>iterable</strong>.</p>

<p>So <strong>generators are iterators</strong>, but generators are also iterables.  What&rsquo;s going on here?</p>

<h2>I lied to you</h2>

<p>So when I explained how iterators worked earlier, I skipped over an important detail about them.</p>

<p><strong>Iterators are iterables</strong>.</p>

<p>I&rsquo;ll say that again: every iterator in Python is also an iterable, which means you can loop over iterators.</p>

<p>Because iterators are also iterables, you can get an iterator from an iterator using the built-in <code>iter</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; iterator1 = iter(numbers)
&gt;&gt;&gt; iterator2 = iter(iterator1)
</code></pre>

<p>Remember that iterables give us iterators when we call <code>iter</code> on them.</p>

<p>When we call <code>iter</code> on an iterator it will always give us itself back:</p>

<pre><code class="pycon">&gt;&gt;&gt; iterator1 is iterator2
True
</code></pre>

<p>Iterators are iterables and all iterators are their own iterators.</p>

<pre><code class="python">def is_iterator(iterable):
    return iter(iterable) is iterable
</code></pre>

<p>Confused yet?</p>

<p>Let&rsquo;s recap these terms.</p>

<p>An iter<strong>able</strong> is something you&rsquo;re able to iterate over.
An iter<strong>ator</strong> is the agent that actually does the iterating over an iterable.</p>

<p>Additionally, in Python iterators are also iterables and they act as <em>their own</em> iterators.</p>

<p>So iterators are iterables, but they don&rsquo;t have the variety of features that some iterables have.</p>

<p>Iterators have no length and they can&rsquo;t be indexed:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; iterator = iter(numbers)
&gt;&gt;&gt; len(iterator)
TypeError: object of type 'list_iterator' has no len()
&gt;&gt;&gt; iterator[0]
TypeError: 'list_iterator' object is not subscriptable
</code></pre>

<p>From our perspective as Python programmers, the only useful things you can do with an iterator are pass it to the built-in <code>next</code> function or loop over it:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
1
&gt;&gt;&gt; list(iterator)
[2, 3, 5, 7]
</code></pre>

<p>And if we loop over an iterator a second time, we&rsquo;ll get nothing back:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(iterator)
[]
</code></pre>

<p>You can think of iterators are <strong>lazy iterables</strong> that are <strong>single-use</strong>, meaning they can be looped over one time only.</p>

<table>
<thead>
<tr>
<th> Object    </th>
<th> Iterable?        </th>
<th> Iterator?        </th>
</tr>
</thead>
<tbody>
<tr>
<td> Iterable  </td>
<td> &#x2714;&#xfe0f; </td>
<td>         &#x2753; </td>
</tr>
<tr>
<td> Iterator  </td>
<td> &#x2714;&#xfe0f; </td>
<td> &#x2714;&#xfe0f; </td>
</tr>
<tr>
<td> Generator </td>
<td> &#x2714;&#xfe0f; </td>
<td> &#x2714;&#xfe0f; </td>
</tr>
<tr>
<td> List      </td>
<td> &#x2714;&#xfe0f; </td>
<td>         &#x274c; </td>
</tr>
</tbody>
</table>


<p>As you can see in the truth table above, iterables are not always iterators but iterators are always iterables:</p>

<h2>The iterator protocol, in full</h2>

<p>Let&rsquo;s define how iterators work from Python&rsquo;s perspective.</p>

<p>Iterables can be passed to the <code>iter</code> function to get an iterator for them.</p>

<p>Iterators:</p>

<ol>
<li>Can be passed to the <code>next</code> function which will give their next item or raise a <code>StopIteration</code> exception if there are no more items</li>
<li>Can be passed to the <code>iter</code> function and will return themselves back</li>
</ol>


<p>The inverse of these statements also hold true:</p>

<ol>
<li>Anything that can be passed to <code>iter</code> without a <code>TypeError</code> is an iterable</li>
<li>Anything that can be passed to <code>next</code> without a <code>TypeError</code> is an iterator</li>
<li>Anything that returns itself when passed to <code>iter</code> is an iterator</li>
</ol>


<p>That&rsquo;s the iterator protocol in Python.</p>

<h2>Iterators enable laziness</h2>

<p>Iterators allow us to both work with and create <strong>lazy iterables</strong> that don&rsquo;t do any work until we ask them for their next item.
Because we can create lazy iterables, we can make infinitely long iterables.
And we can create iterables that are conservative with system resources, that can save us memory and can save us CPU time.</p>

<h2>Iterators are everywhere</h2>

<p>You&rsquo;ve already seen lots of iterators in Python.
I&rsquo;ve already mentioned that generators are iterators.
Many of Python&rsquo;s built-in classes are iterators also.
For example Python&rsquo;s <code>enumerate</code> and <code>reversed</code> objects are iterators.</p>

<pre><code class="pycon">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; e = enumerate(letters)
&gt;&gt;&gt; e
&lt;enumerate object at 0x7f112b0e6510&gt;
&gt;&gt;&gt; next(e)
(0, 'a')
</code></pre>

<p>In Python 3, <code>zip</code>, <code>map</code>, and <code>filter</code> objects are iterators too.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; z = zip(numbers, letters)
&gt;&gt;&gt; z
&lt;zip object at 0x7f112cc6ce48&gt;
&gt;&gt;&gt; next(z)
(1, 'a')
</code></pre>

<p>And file objects in Python are iterators also.</p>

<pre><code class="pycon">&gt;&gt;&gt; next(open('hello.txt'))
'hello world\n'
</code></pre>

<p>There are lots of iterators bult-in to Python, in the standard library, and in third-party Python libraries.
These iterators all act like lazy iterables by delaying work until the moment you ask them for their next item.</p>

<h2>Creating your own iterator</h2>

<p>It&rsquo;s useful to know that you&rsquo;re already using iterators, but I&rsquo;d like you to also know that you can create your own iterators and your own lazy iterables.</p>

<p>This class makes an iterator that accepts an iterable of numbers and provides squares of each of the numbers as it&rsquo;s looped over.</p>

<pre><code class="python">class square_all:
    def __init__(self, numbers):
        self.numbers = iter(numbers)
    def __next__(self):
        return next(self.numbers) ** 2
    def __iter__(self):
        return self
</code></pre>

<p>But no work will be done until we start looping over an instance of this class.</p>

<p>Here we have an infinitely long iterable <code>count</code> and you can see that <code>square_all</code> accepts <code>count</code> without fully looping over this infinitely long iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; numbers = count(5)
&gt;&gt;&gt; squares = square_all(numbers)
&gt;&gt;&gt; next(squares)
25
&gt;&gt;&gt; next(squares)
36
</code></pre>

<p>This iterator class works, but we don&rsquo;t usually make iterators this way.
Usually when we want to make a custom iterator, we make a generator function:</p>

<pre><code class="python">def square_all(numbers):
    for n in numbers:
        yield n**2
</code></pre>

<p>This generator function is equivalent to the class we made above and it works essentially the same way.</p>

<p>That <code>yield</code> statement probablys seem magical, but it is very powerful: <code>yield</code> allows us to put our generator function on pause between calls from the <code>next</code> function.
The <code>yield</code> statement is the thing that separates generator functions from regular functions.</p>

<p>Another way we could implement this same iterator is with a generator expression.</p>

<pre><code class="python">def square_all(numbers):
    return (n**2 for n in numbers)
</code></pre>

<p>This does the same thing as our generator function but it uses a syntax that looks <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">like a list comprehension</a>.
If you need to make a lazy iterable in your code, think of iterators and consider making a generator function or a generator expression.</p>

<h2>How iterators can improve your code</h2>

<p>Once you&rsquo;ve embraced the idea of using lazy iterables in your code, you&rsquo;ll find that there are lots of possibilities for discovering or creating helper functions that assist you in looping over iterables and processing data.</p>

<h3>Laziness and summing</h3>

<p>This is a <code>for</code> loop that sums up all billable hours in a Django queryset:</p>

<pre><code class="python">hours_worked = 0
for event in events:
    if event.is_billable():
        hours_worked += event.duration
</code></pre>

<p>Here is code that does the same thing using a generator expression for lazy evaluation:</p>

<pre><code class="python">billable_times = (
    event.duration
    for event in events
    if event.is_billable()
)

hours_worked = sum(billable_times)
</code></pre>

<p>Notice that the shape of our code has changed dramatically.</p>

<p>Turning our billable times into a lazy iterable has allowed us to name something (<code>billable_times</code>) that was previously unnamed.
This has also allowed us to use the <code>sum</code> function.  We couldn&rsquo;t have used <code>sum</code> before because we didn&rsquo;t even have an iterable to pass to it.
Iterators allow you to fundamentally change the way you structure your code.</p>

<h3>Laziness and breaking out of loops</h3>

<p>This code prints out the first ten lines of a log file:</p>

<pre><code class="python">for i, line in enumerate(log_file):
    if i &gt;= 10:
        break
    print(line)
</code></pre>

<p>This code does the same thing, but we&rsquo;re using the <code>itertools.islice</code> function to lazily grab the first 10 lines of our file as we loop:</p>

<pre><code class="python">from itertools import islice

first_ten_lines = islice(log_file, 10)
for line in first_ten_lines:
    print(line)
</code></pre>

<p>The <code>first_ten_lines</code> variable we&rsquo;ve made is an iterator.
Again using an iterator allowed us to give a name to something (first ten lines) that was previously unnamed.
Naming things can make our code more descriptive and more readable.</p>

<p>As a bonus we also removed the need for a <code>break</code> statement in our loop because the <code>islice</code> utility handles the breaking for us.</p>

<p>You can find many more iteration helper functions in <a href="https://docs.python.org/3/library/itertools.html">itertools</a> in the standard library as well as in third-party libraries such as <a href="https://boltons.readthedocs.io">boltons</a> and <a href="https://more-itertools.readthedocs.io">more-itertools</a>.</p>

<h3>Creating your own iteration helpers</h3>

<p>You can find helper functions for looping in the standard library and in third-party libraries, but you can also make your own!</p>

<p>This code makes a list of the differences between consecutive values in a sequence.</p>

<pre><code class="python">current = readings[0]
for next_item in readings[1:]:
    differences.append(next_item - current)
    current = next_item
</code></pre>

<p>Notice that this code has an extra variable that we need to assign each time we loop.
Also note that this code only works with things we can slice, like sequences.  If <code>readings</code> were a generator, a zip object, or any other type of iterator this code would fail.</p>

<p>Let&rsquo;s write a helper function to fix our code.</p>

<p>This is a generator function that gives us the current item and the item following it for every item in a given iterable:</p>

<pre><code class="python">def with_next(iterable):
    """Yield (current, next_item) tuples for each item in iterable."""
    iterator = iter(iterable)
    current = next(iterator)
    for next_item in iterator:
        yield current, next_item
        current = next_item
</code></pre>

<p>We&rsquo;re manually getting an iterator from our iterable, calling <code>next</code> on it to grab the first item, and then looping over our iterator to get all subsequent items, keeping track of our last item along the way.
This function works not just with sequences, but with any type of iterable</p>

<p>This is the same code but we&rsquo;re using our helper function instead of manually keeping track of <code>next_item</code>:</p>

<pre><code class="python">differences = []
for current, next_item in with_next(readings):
    differences.append(next_item - current)
</code></pre>

<p>Notice that this code doesn&rsquo;t have awkward assignments to <code>next_item</code> hanging around our loop.
The <code>with_next</code> generator function handles the work of keeping track of <code>next_item</code> for us.</p>

<p>Also note that this code has been compacted enough that we could even <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-paste our way into a list comprehension</a> if we wanted to.</p>

<pre><code class="python">differences = [
    (next_item - current)
    for current, next_item in with_next(readings)
]
</code></pre>

<h2>Looping Gotchas: Revisited</h2>

<p>At this point we&rsquo;re ready to jump back to those odd examples we saw earlier and try to figure out what was going on.</p>

<h3>Gotcha 1: Exhausting an Iterator</h3>

<p>Here we have a generator object, <code>squares</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we pass this generator to the <code>tuple</code> constructor, we&rsquo;ll get a tuple of its items back:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre>

<p>If we then try to compute the <code>sum</code> of the numbers in this generator, we&rsquo;ll get <code>0</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; sum(squares)
0
</code></pre>

<p>This generator is now empty: we&rsquo;ve exhausted it.
If we try to make a tuple out of it again, we&rsquo;ll get an empty tuple:</p>

<pre><code class="pycon">&gt;&gt;&gt; tuple(squares)
()
</code></pre>

<p>Generators are iterators.
And iterators are single-use iterables.
They&rsquo;re like Hello Kitty PEZ dispensers that cannot be reloaded.</p>

<h3>Gotcha 2: Partially-Consuming an Iterator</h3>

<p>Again we have a generator object, <code>squares</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we ask whether <code>9</code> is in this <code>squares</code> generator, we&rsquo;ll get <code>True</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
True
</code></pre>

<p>But if we ask the same question again, we&rsquo;ll get <code>False</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
False
</code></pre>

<p>When we ask whether <code>9</code> is in this generator, Python has to loop over this generator to find <code>9</code>.
If we kept looping over it after checking for <code>9</code>, we&rsquo;ll only get the last two numbers because we&rsquo;ve already consumed the numbers before this point:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; list(squares)
[25, 49]
</code></pre>

<p>Asking whether something is <em>contained</em> in an iterator will partially consume the iterator.
There is no way to know whether something is in an iterator without starting to loop over it.</p>

<h3>Gotcha 3: Unpacking is iteration</h3>

<p>When you <em>loop</em> over dictionaries you get keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; counts = {'apples': 2, 'oranges': 1}
&gt;&gt;&gt; for key in counts:
...     print(key)
...
apples
oranges
</code></pre>

<p>You also get keys when you unpack a dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = counts
&gt;&gt;&gt; x, y
('apples', 'oranges')
</code></pre>

<p>Looping relies on the iterator protocol.
Iterable unpacking also relies on the iterator protocol.
Unpacking a dictionary is really the same as looping over the dictionary.
Both use the iterator protocol, so you get the same result in both cases.</p>

<h2>Recap and related resources</h2>

<p>Sequences are iterables, but not all iterables are sequences.
When someone says the word &ldquo;iterable&rdquo; you can only assume they mean &ldquo;something that you can iterate over&rdquo;.  Don&rsquo;t assume iterables can be looped over twice, asked for their length, or indexed.</p>

<p>Iterators are the most rudimentary form of iterables in Python.
If you&rsquo;d like to make a lazy iterable in your code think of iterators and consider making a generator function or a generator expression.</p>

<p>And finally, remember that every type of iteration in Python relies on the iterator protocol so understanding the iterator protocol is the key to understanding quite a bit about looping in Python in general.</p>

<p>Here are some related articles and videos I recommend:</p>

<ul>
<li><a href="https://nedbatchelder.com/text/iter.html">Loop Like a Native</a>, Ned Batchelder&rsquo;s PyCon 2013 talk</li>
<li><a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">Loop Better</a>, the talk this article is based on</li>
<li><a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">The Iterator Protocol: How For Loops Work</a>, a short article I wrote on the iterator protocol</li>
<li><a href="https://www.youtube.com/watch?v=5_cJIcgM7rw">Comprehensible Comprehensions</a>, my talk on comprehensions and generator expressions</li>
<li><a href="http://treyhunner.com/2018/02/python-range-is-not-an-iterator/">Python: range is not an iterator</a>, my article on range and iterators</li>
<li><a href="https://www.youtube.com/watch?v=u8g9scXeAcI">Looping Like a Pro in Python</a>, DB&rsquo;s PyCon 2017 talk</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python built-ins worth learning]]></title>
    <link href="https://treyhunner.com/2019/05/python-builtins-worth-learning/"/>
    <updated>2019-05-21T08:40:00-07:00</updated>
    <id>https://treyhunner.com/2019/05/python-builtins-worth-learning</id>
    <content type="html"><![CDATA[<p>In every Intro to Python class I teach, there&rsquo;s always at least one &ldquo;how can we be expected to know all this&rdquo; question.</p>

<p>It&rsquo;s usually along the lines of either:</p>

<ol>
<li>Python has so many functions in it, what&rsquo;s the best way to remember all these?</li>
<li>What&rsquo;s the best way to learn the functions we&rsquo;ll need day-to-day like <code>enumerate</code> and <code>range</code>?</li>
<li>How do you know about all the ways to solve problems in Python?  Do you memorize them?</li>
</ol>


<p>There are dozens of built-in functions and classes, hundreds of tools bundled in Python&rsquo;s <a href="https://docs.python.org/3/library/index.html">standard library</a>, and thousands of third-party libraries on PyPI.
There&rsquo;s no way anyone could ever memorize all of these things.</p>

<p>I recommend triaging your knowledge:</p>

<ol>
<li>Things I should memorize such that I know them well</li>
<li>Things I should know <em>about</em> so I can look them up more effectively later</li>
<li>Things I shouldn&rsquo;t bother with at all until/unless I need them one day</li>
</ol>


<p>We&rsquo;re going to look through the <a href="https://docs.python.org/3/library/functions.html">Built-in Functions page</a> in the Python documentation with this approach in mind.</p>

<p>This will be a very long article, so I&rsquo;ve linked to 5 sub-sections and 20 specific built-in functions in the next section so you can jump ahead if you&rsquo;re pressed for time or looking for one built-in in particular.</p>

<div style="display: none;"><ol data-toc=".entry-content" data-toc-headings="h2,h3,h4"></ol></div>


<h2>Which built-ins should you know about?</h2>

<p>I estimate <strong>most Python developers will only ever need about 30 built-in functions</strong>, but which 30 depends on what you&rsquo;re actually doing with Python.</p>

<p>We&rsquo;re going to take a look at all 69 of Python&rsquo;s built-in functions, in a birds eye view sort of way.</p>

<p>I&rsquo;ll attempt to categorize these built-ins into five categories:</p>

<ol>
<li><strong><a href="#10_Commonly_known_built-in_functions">Commonly known</a></strong>: most newer Pythonistas get exposure to these built-ins pretty quickly out of necessity</li>
<li><strong><a href="#Built-ins_overlooked_by_new_Pythonistas">Overlooked by beginners</a></strong>: these functions are useful to know about, but they&rsquo;re easy to overlook when you&rsquo;re newer to Python</li>
<li><strong><a href="#Learn_it_later">Learn it later</a></strong>: these built-ins are generally useful to know about, but you&rsquo;ll find them when/if you need them</li>
<li><strong><a href="#Maybe_learn_it_eventually">Maybe learn it eventually</a></strong>: these can come in handy, but only in specific circumstances</li>
<li><strong><a href="#You_likely_don%E2%80%99t_need_these">You likely don&rsquo;t need these</a></strong>: you&rsquo;re unlikely to need these unless you&rsquo;re doing something fairly specialized</li>
</ol>


<p>The built-in functions in categories 1 and 2 are the <strong>essential built-ins</strong> that nearly all Python programmers should eventually learn about.
The built-ins in categories 3 and 4 are the <strong>specialized built-ins</strong>, which are often very useful but your need for them will vary based on your use for Python.
And category 5 are <strong>arcane built-ins</strong>, which might be very handy when you need them but which many Python programmers are likely to never need.</p>

<p><strong>Note for pedantic Pythonistas</strong>: I will be referring to all of these built-ins as <strong>functions</strong>, even though 27 of them <strong>aren&rsquo;t actually functions</strong> (as discussed in my <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#The_distinction_between_functions_and_classes_often_doesn%E2%80%99t_matter">functions and callables article</a>).</p>

<p>The commonly known built-in functions (which you likely already know about):</p>

<ol>
<li><a href="#print">print</a></li>
<li><a href="#len">len</a></li>
<li><a href="#str">str</a></li>
<li><a href="#int">int</a></li>
<li><a href="#float">float</a></li>
<li><a href="#list">list</a></li>
<li><a href="#tuple">tuple</a></li>
<li><a href="#dict">dict</a></li>
<li><a href="#set">set</a></li>
<li><a href="#range">range</a></li>
</ol>


<p>The built-in functions which are often overlooked by newer Python programmers:</p>

<ol>
<li><a href="#sum">sum</a></li>
<li><a href="#enumerate">enumerate</a></li>
<li><a href="#zip">zip</a></li>
<li><a href="#bool">bool</a></li>
<li><a href="#reversed">reversed</a></li>
<li><a href="#sorted">sorted</a></li>
<li><a href="#min_and_max">min</a></li>
<li><a href="#min_and_max">max</a></li>
<li><a href="#any_and_all">any</a></li>
<li><a href="#any_and_all">all</a></li>
</ol>


<p>There are also <a href="#The_5_debugging_functions">5 commonly overlooked built-ins</a> which I recommend knowing about solely because they make debugging easier: <code>dir</code>, <code>vars</code>, <code>breakpoint</code>, <code>type</code>, <code>help</code>.</p>

<p>In addition to the 25 built-in functions above, we&rsquo;ll also briefly see the other 44 built-ins in the <a href="#Learn_it_later">learn it later</a> <a href="#Maybe_learn_it_eventually">maybe learn it eventually</a> and <a href="#You_likely_don%E2%80%99t_need_these">you likely don&rsquo;t need these</a> sections.</p>

<h2>10 Commonly known built-in functions</h2>

<p>If you&rsquo;ve been writing Python code, these built-ins are likely familiar already.</p>

<h3>print</h3>

<p>You already know the <code>print</code> function.
Implementing <a href="https://en.wikipedia.org/wiki/Hello_world_program">hello world</a> requires <code>print</code>.</p>

<p>You may not know about the various <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">keyword arguments</a> accepted by <code>print</code> though:</p>

<pre><code class="pycon">&gt;&gt;&gt; words = ["Welcome", "to", "Python"]
&gt;&gt;&gt; print(words)
['Welcome', 'to', 'Python']
&gt;&gt;&gt; print(*words, end="!\n")
Welcome to Python!
&gt;&gt;&gt; print(*words, sep="\n")
Welcome
to
Python
</code></pre>

<p>You can look up <code>print</code> on your own.</p>

<h3>len</h3>

<p>In Python, we don&rsquo;t write things like <code>my_list.length()</code> or <code>my_string.length</code>;
instead we strangely (for new Pythonistas at least) say <code>len(my_list)</code> and <code>len(my_string)</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; words = ["Welcome", "to", "Python"]
&gt;&gt;&gt; len(words)
3
</code></pre>

<p>Regardless of whether you like this operator-like <code>len</code> function, you&rsquo;re stuck with it so you&rsquo;ll need to get used to it.</p>

<h3>str</h3>

<p>Unlike many other programming languages, you cannot concatenate strings and numbers in Python.</p>

<pre><code class="pycon">&gt;&gt;&gt; version = 3
&gt;&gt;&gt; "Python " + version
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate str (not "int") to str
</code></pre>

<p>Python refuses to coerce that <code>3</code> integer to a string, so we need to manually do it ourselves, using the built-in <code>str</code> function (class technically, but as I said, I&rsquo;ll be calling these all functions):</p>

<pre><code class="pycon">&gt;&gt;&gt; version = 3
&gt;&gt;&gt; "Python " + str(version)
'Python 3'
</code></pre>

<h3>int</h3>

<p>Do you have user input and need to convert it to a number?
You need the <code>int</code> function!</p>

<p>The <code>int</code> function can convert strings to integers:</p>

<pre><code class="pycon">&gt;&gt;&gt; program_name = "Python 3"
&gt;&gt;&gt; version_number = program_name.split()[-1]
&gt;&gt;&gt; int(version_number)
3
</code></pre>

<p>You can also use <code>int</code> to truncate a floating point number to an integer:</p>

<pre><code class="pycon">&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; sqrt(28)
5.291502622129181
&gt;&gt;&gt; int(sqrt(28))
5
</code></pre>

<p>Note that if you need to truncate while dividing, the <code>//</code> operator is likely more appropriate (though this works differently with negative numbers): <code>int(3 / 2) == 3 // 2</code>.</p>

<h3>float</h3>

<p>Is the string you&rsquo;re converting to a number not actually an integer?
Then you&rsquo;ll want to use <code>float</code> instead of <code>int</code> for this conversion.</p>

<pre><code class="pycon">&gt;&gt;&gt; program_name = "Python 3"
&gt;&gt;&gt; version_number = program_name.split()[-1]
&gt;&gt;&gt; float(version_number)
3.0
&gt;&gt;&gt; pi_digits = '3.141592653589793238462643383279502884197169399375'
&gt;&gt;&gt; len(pi_digits)
50
&gt;&gt;&gt; float(pi_digits)
3.141592653589793
</code></pre>

<p>You can also use <code>float</code> to convert integers to floating point numbers.</p>

<p>In Python 2, we used to use <code>float</code> to convert integers to floating point numbers to force float division instead of integer division.
&ldquo;Integer division&rdquo; isn&rsquo;t a thing anymore in Python 3 (unless you&rsquo;re specifically using the <code>//</code> operator), so we don&rsquo;t need <code>float</code> for that purpose anymore.
So if you ever see <code>float(x) / y</code> in your Python 3 code, you can change that to just <code>x / y</code>.</p>

<h3>list</h3>

<p>Want to make a list out of some other iterable?</p>

<p>The <code>list</code> function does that:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 5, 8]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; squares
&lt;generator object &lt;genexpr&gt; at 0x7fd52dbd5930&gt;
&gt;&gt;&gt; list_of_squares = list(squares)
&gt;&gt;&gt; list_of_squares
[4, 1, 9, 25, 64]
</code></pre>

<p>If you know you&rsquo;re working with a list, you could use the <code>copy</code> method to make a new copy of a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; copy_of_squares = list_of_squares.copy()
</code></pre>

<p>But if you don&rsquo;t know what the iterable you&rsquo;re working with is, the <code>list</code> function is the more general way to loop over an iterable and copy it:</p>

<pre><code class="pycon">&gt;&gt;&gt; copy_of_squares = list(list_of_squares)
</code></pre>

<p>You could also use a list comprehension for this, <a href="https://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python/#Using_comprehensions_when_a_more_specific_tool_exists">but I wouldn&rsquo;t recommend it</a>.</p>

<p>Note that when you want to make an empty list, using the <em>list literal syntax</em> (those <code>[]</code> brackets) is recommended:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_list = list()  # Don't do this
&gt;&gt;&gt; my_list = []  # Do this instead
</code></pre>

<p>Using <code>[]</code> is considered more idiomatic since those square brackets (<code>[]</code>) actually <em>look</em> like a Python list.</p>

<h3>tuple</h3>

<p>The <code>tuple</code> function is pretty much just like the <code>list</code> function, except it makes tuples instead:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; tuple(numbers)
(2, 1, 3, 4, 7)
</code></pre>

<p>If you need a tuple instead of a list, because you&rsquo;re trying to make a <a href="https://lerner.co.il/2015/04/03/is-it-hashable-fun-and-games-with-hashing-in-python/">hashable</a> collection for use in a dictionary key for example, you&rsquo;ll want to reach for <code>tuple</code> over <code>list</code>.</p>

<h3>dict</h3>

<p>The <code>dict</code> function makes a new dictionary.</p>

<p>Similar to like <code>list</code> and <code>tuple</code>, the <code>dict</code> function is equivalent to looping over an iterable of key-value pairs and making a dictionary from them.</p>

<p>Given a list of two-item tuples:</p>

<pre><code class="python">&gt;&gt;&gt; color_counts = [('red', 2), ('green', 1), ('blue', 3), ('purple', 5)]
</code></pre>

<p>This:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors = {}
&gt;&gt;&gt; for color, n in color_counts:
...     colors[color] = n
...
&gt;&gt;&gt; colors
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
</code></pre>

<p>Can instead be done with the <code>dict</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors = dict(color_counts)
&gt;&gt;&gt; colors
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
</code></pre>

<p>The <code>dict</code> function accepts two types of arguments:</p>

<ol>
<li><strong>another dictionary</strong> (<a href="https://docs.python.org/3/glossary.html#term-mapping">mapping</a> is the generic term), in which case that dictionary will be copied</li>
<li><strong>a list of key-value tuples</strong> (more correctly, an iterable of two-item iterables), in which case a new dictionary will be constructed from these</li>
</ol>


<p>So this works as well:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
&gt;&gt;&gt; new_dictionary = dict(colors)
&gt;&gt;&gt; new_dictionary
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
</code></pre>

<p>The <code>dict</code> function can also accept keyword arguments to make a dictionary with string-based keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; person = dict(name='Trey Hunner', profession='Python Trainer')
&gt;&gt;&gt; person
{'name': 'Trey Hunner', 'profession': 'Python Trainer'}
</code></pre>

<p>But I very much prefer to use a dictionary literal instead:</p>

<pre><code class="pycon">&gt;&gt;&gt; person = {'name': 'Trey Hunner', 'profession': 'Python Trainer'}
&gt;&gt;&gt; person
{'name': 'Trey Hunner', 'profession': 'Python Trainer'}
</code></pre>

<p>The dictionary literal syntax is more flexible and <a href="https://doughellmann.com/blog/2012/11/12/the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2/">a bit faster</a> but most importantly I find that it more clearly conveys the fact that we are creating a dictionary.</p>

<p>Like with <code>list</code> and <code>tuple</code>, an empty dictionary should be made using the literal syntax as well:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_list = dict()  # Don't do this
&gt;&gt;&gt; my_list = {}  # Do this instead
</code></pre>

<p>Using <code>{}</code> is slightly more CPU efficient, but more importantly it&rsquo;s more idiomatic: it&rsquo;s common to see curly braces (<code>{}</code>) used for making dictionaries but <code>dict</code> is seen much less frequently.</p>

<h3>set</h3>

<p>The <code>set</code> function makes a new set.
It takes an iterable of <a href="https://lerner.co.il/2015/04/03/is-it-hashable-fun-and-games-with-hashing-in-python/">hashable</a> values (strings, numbers, or other immutable types) and returns a <code>set</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 1, 2, 3, 5, 8]
&gt;&gt;&gt; set(numbers)
{1, 2, 3, 5, 8}
</code></pre>

<p>There&rsquo;s no way to make an empty set with the <code>{}</code> set literal syntax (plain <code>{}</code> makes a dictionary), so the <code>set</code> function is the only way to make an empty set:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = set()
&gt;&gt;&gt; numbers
set()
</code></pre>

<p>Actually that&rsquo;s a lie because we have this:</p>

<pre><code class="pycon">&gt;&gt;&gt; {*()}  # This makes an empty set
set()
</code></pre>

<p>But that syntax is confusing (it relies on <a href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/#Asterisks_in_list_literals">a lesser-used feature of the <code>*</code> operator</a>), so I don&rsquo;t recommend it.</p>

<h3>range</h3>

<p>The <code>range</code> function gives us a <code>range</code> object, which represents a range of numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(10_000)
range(0, 10000)
&gt;&gt;&gt; range(-1_000_000_000, 1_000_000_000)
range(-1000000000, 1000000000)
</code></pre>

<p>The resulting range of numbers includes the start number but excludes the stop number (<code>range(0, 10)</code> does not include <code>10</code>).</p>

<p>The <code>range</code> function is useful when you&rsquo;d like to loop over numbers.</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in range(0, 50, 10):
...     print(n)
...
0
10
20
30
40
</code></pre>

<p>A common use case is to do an operation <code>n</code> times (that&rsquo;s a <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">list comprehension</a> by the way):</p>

<pre><code class="python">first_five = [get_things() for _ in range(5)]
</code></pre>

<p>Python 2&rsquo;s <code>range</code> function returned a list, which means the expressions above would make very very large lists.
Python 3&rsquo;s <code>range</code> works like Python 2&rsquo;s <code>xrange</code> (though they&rsquo;re <a href="https://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/">a bit different</a>) in that numbers are <strong>computed lazily</strong> as we loop over these <code>range</code> objects.</p>

<h2>Built-ins overlooked by new Pythonistas</h2>

<p>If you&rsquo;ve been programming Python for a bit or if you just taken an introduction to Python class, you probably already knew about the built-in functions above.</p>

<p>I&rsquo;d now like to show off 15 built-in functions that are very handy to know about, but are more frequently overlooked by new Pythonistas.</p>

<p>The first 10 of these functions you&rsquo;ll find floating around in Python code, but the last 5 you&rsquo;ll most often use while debugging.</p>

<h3>bool</h3>

<p>The <code>bool</code> function checks the <strong>truthiness</strong> of a Python object.</p>

<p>For numbers, truthiness is a question of non-zeroness:</p>

<pre><code class="pycon">&gt;&gt;&gt; bool(5)
True
&gt;&gt;&gt; bool(-1)
True
&gt;&gt;&gt; bool(0)
False
</code></pre>

<p>For collections, truthiness is usually a question of non-emptiness (whether the collection has a length greater than <code>0</code>):</p>

<pre><code class="pycon">&gt;&gt;&gt; bool('hello')
True
&gt;&gt;&gt; bool('')
False
&gt;&gt;&gt; bool(['a'])
True
&gt;&gt;&gt; bool([])
False
&gt;&gt;&gt; bool({})
False
&gt;&gt;&gt; bool({1: 1, 2: 4, 3: 9})
True
&gt;&gt;&gt; bool(range(5))
True
&gt;&gt;&gt; bool(range(0))
False
&gt;&gt;&gt; bool(None)
False
</code></pre>

<p>Truthiness (called <a href="https://docs.python.org/3/library/stdtypes.html#truth">truth value testing</a> in the docs) is kind of a big deal in Python.</p>

<p>Instead of asking questions about the length of a container, many Pythonistas ask questions about truthiness instead:</p>

<pre><code class="python"># Instead of doing this
if len(numbers) == 0:
    print("The numbers list is empty")

# Many of us do this
if not numbers:
    print("The numbers list is empty")
</code></pre>

<p>You likely won&rsquo;t see <code>bool</code> used often, but on the occasion that you need to coerce a value to a boolean to ask about its truthiness, you&rsquo;ll want to know about <code>bool</code>.</p>

<h3>enumerate</h3>

<p>Whenever you need to count upward, one number at a time, while looping over an iterable at the same time, the <code>enumerate</code> function will come in handy.</p>

<p>That might seem like a very niche task, but it comes up quite often.</p>

<p>For example we might want to keep track of the line number in a file:</p>

<pre><code class="python">&gt;&gt;&gt; with open('hello.txt', mode='rt') as my_file:
...     for n, line in enumerate(my_file, start=1):
...         print(f"{n:03}", line)
...
001 This is the first line of the file
002 This is the second line
003 This is the last line of the file
</code></pre>

<p>The <code>enumerate</code> function is also very commonly used to keep track of the <em>index</em> of items in a sequence.</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    for i, item in enumerate(sequence):
        if item != sequence[-(i+1)]:
            return False
    return True
</code></pre>

<p>Note that you may see newer Pythonistas use <code>range(len(sequence))</code> in Python.
If you ever see code with <code>range(len(...))</code>, you&rsquo;ll almost always want to use <code>enumerate</code> instead.</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    for i in range(len(sequence)):
        if sequence[i] != sequence[-(i+1)]:
            return False
    return True
</code></pre>

<p>If <code>enumerate</code> is news to you (or if you often use <code>range(len(...))</code>), see my article on <a href="https://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">looping with indexes in Python</a>.</p>

<h3>zip</h3>

<p>The <code>zip</code> function is even more specialized than <code>enumerate</code>.</p>

<p>The <code>zip</code> function is used for looping over multiple iterables at the same time.</p>

<pre><code class="python">&gt;&gt;&gt; one_iterable = [2, 1, 3, 4, 7, 11]
&gt;&gt;&gt; another_iterable = ['P', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; for n, letter in zip(one_iterable, another_iterable):
...     print(letter, n)
...
P 2
y 1
t 3
h 4
o 7
n 11
</code></pre>

<p>If you ever have to loop over two lists (or any other iterables) at the same time, <code>zip</code> is preferred over <code>enumerate</code>.
The <code>enumerate</code> function is handy when you need indexes while looping, but <code>zip</code> is great when we care specifically about looping over two iterables at once.</p>

<p>If you&rsquo;re new to <code>zip</code>, I also talk about it in my <a href="https://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/#What_if_we_need_to_loop_over_multiple_things?">looping with indexes</a> article.</p>

<p>Both <code>enumerate</code> and <code>zip</code> return iterators to us.
Iterators are the lazy iterables that <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">power <code>for</code> loops</a>.
I have <a href="https://youtu.be/JYuE8ZiDPl4">a whole talk on iterators</a> as well as a somewhat advanced article on <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">how to make your own iterators</a>.</p>

<p>By the way, if you need to use <code>zip</code> on iterables of different lengths, you may want to look up <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest">itertools.zip_longest</a> in the Python standard library.</p>

<h3>reversed</h3>

<p>The <code>reversed</code> function, like <code>enumerate</code> and <code>zip</code>, returns an <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">iterator</a>.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; reversed(numbers)
&lt;list_reverseiterator object at 0x7f3d4452f8d0&gt;
</code></pre>

<p>The only thing we can do with this iterator is loop over it (but only once):</p>

<pre><code class="pycon">&gt;&gt;&gt; reversed_numbers = reversed(numbers)
&gt;&gt;&gt; list(reversed_numbers)
[7, 4, 3, 1, 2]
&gt;&gt;&gt; list(reversed_numbers)
[]
</code></pre>

<p>Like <code>enumerate</code> and <code>zip</code>, <code>reversed</code> is a sort of <strong>looping helper function</strong>.
You&rsquo;ll pretty much see <code>reversed</code> used exclusively in the <code>for</code> part of a <code>for</code> loop:</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in reversed(numbers):
...     print(n)
...
7
4
3
1
2
</code></pre>

<p>There are some other ways to reverse Python lists besides the <code>reversed</code> function:</p>

<pre><code class="python"># Slicing syntax
for n in numbers[::-1]:
    print(n)

# In-place reverse method
numbers.reverse()
for n in numbers:
    print(n)
</code></pre>

<p>But the <code>reversed</code> function is <strong>usually the best way to reverse any iterable</strong> in Python.</p>

<p>Unlike the list <code>reverse</code> method (e.g. <code>numbers.reverse()</code>), <code>reversed</code> doesn&rsquo;t mutate the list (it returns an iterator of the reversed items instead).</p>

<p>Unlike the <code>numbers[::-1]</code> slice syntax, <code>reversed(numbers)</code> doesn&rsquo;t build up a whole new list: the lazy iterator it returns retrieves the next item in reverse as we loop.
Also <code>reversed(numbers)</code> is a lot more readable than <code>numbers[::-1]</code> (which just looks weird if you&rsquo;ve never seen that particular use of slicing before).</p>

<p>If we combine the non-copying nature of the <code>reversed</code> and <code>zip</code> functions, we can rewrite the <code>palindromic</code> function (from <a href="#enumerate">enumerate</a> above) without taking any extra memory (no copying of lists is done here):</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    for n, m in zip(sequence, reversed(sequence)):
        if n != m:
            return False
    return True
</code></pre>

<h3>sum</h3>

<p>The <code>sum</code> function takes an iterable of numbers and returns the sum of those numbers.</p>

<pre><code class="pycon">&gt;&gt;&gt; sum([2, 1, 3, 4, 7])
17
</code></pre>

<p>There&rsquo;s not much more to it than that.</p>

<p>Python has lots of helper functions that <strong>do the looping for you</strong>, partly because they pair nicely with generator expressions:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; sum(n**2 for n in numbers)
524
</code></pre>

<p>If you&rsquo;re curious about generator expressions, I discuss them in my <a href="https://youtu.be/5_cJIcgM7rw">Comprehensible Comprehensions</a> talk (and my <a href="https://pycon2018.trey.io">3 hour tutorial on comprehensions and generator expressions</a>).</p>

<h3>min and max</h3>

<p>The <code>min</code> and <code>max</code> functions do what you&rsquo;d expect: they give you the minimum and maximum items in an iterable.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; min(numbers)
1
&gt;&gt;&gt; max(numbers)
18
</code></pre>

<p>The <code>min</code> and <code>max</code> functions compare the items given to them by using the <code>&lt;</code> operator.
So all values need to be orderable and comparable to each other (fortunately <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/">many objects are orderable in Python</a>).</p>

<p>The <code>min</code> and <code>max</code> functions also accept <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/#Sorting_by_multiple_attributes_at_once">a <code>key</code> function</a> to allow customizing what &ldquo;minimum&rdquo; and &ldquo;maximum&rdquo; really mean for specific objects.</p>

<h3>sorted</h3>

<p>The <code>sorted</code> function takes any iterable and returns a new list of all the values in that iterable in sorted order.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 8, 2, 13, 5, 3, 1]
&gt;&gt;&gt; words = ["python", "is", "lovely"]
&gt;&gt;&gt; sorted(words)
['is', 'lovely', 'python']
&gt;&gt;&gt; sorted(numbers, reverse=True)
[13, 8, 5, 3, 2, 1, 1]
</code></pre>

<p>The <code>sorted</code> function, like <code>min</code> and <code>max</code>, compares the items given to it by using the <code>&lt;</code> operator, so all values given to it need so to be orderable.</p>

<p>The <code>sorted</code> function also allows customization of its sorting via <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/#Sorting_by_multiple_attributes_at_once">a <code>key</code> function</a> (just like <code>min</code> and <code>max</code>).</p>

<p>By the way, if you&rsquo;re curious about <code>sorted</code> versus the <code>list.sort</code> method, Florian Dahlitz wrote <a href="https://blog.usejournal.com/list-sort-vs-sorted-list-aab92c00e17">an article comparing the two</a>.</p>

<h3>any and all</h3>

<p>The <code>any</code> and <code>all</code> functions can be paired with a generator expression to determine whether <em>any</em> or <em>all</em> items in an iterable <strong>match a given condition</strong>.</p>

<p>Our <code>palindromic</code> function from earlier checked whether <em>all</em> items were equal to their corresponding item in the reversed sequence (is the first value equal to the last, second to the second from last, etc.).</p>

<p>We could rewrite <code>palindromic</code> using <code>all</code> like this:</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    return all(
        n == m
        for n, m in zip(sequence, reversed(sequence))
    )
</code></pre>

<p>Negating the condition and the return value from <code>all</code> would allow us to use <code>any</code> equivalently (though this is more confusing in this example):</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    return not any(
        n != m
        for n, m in zip(sequence, reversed(sequence))
    )
</code></pre>

<p>If the <code>any</code> and <code>all</code> functions are new to you, you may want to read my article on them: <a href="https://treyhunner.com/2016/11/check-whether-all-items-match-a-condition-in-python/">Checking Whether All Items Match a Condition in Python</a>.</p>

<h3>The 5 debugging functions</h3>

<p>The following 5 functions will be useful for debugging and troubleshooting code.</p>

<h4>breakpoint</h4>

<p>Need to pause the execution of your code and drop into a Python command prompt?
You need <code>breakpoint</code>!</p>

<p>Calling the <code>breakpoint</code> function will drop you into <a href="https://pymotw.com/3/pdb/">pdb</a>, the Python debugger.
There are many tutorials and talks out there on PDB: here&rsquo;s <a href="https://pyvideo.org/pybay-2017/introduction-to-pdb.html">a short one</a> and here&rsquo;s <a href="https://www.youtube.com/watch?v=P0pIW5tJrRM&amp;feature=player_embedded">a long one</a>.</p>

<p>This built-in function was <strong>added in Python 3.7</strong>, but if you&rsquo;re on older versions of Python you can get the same behavior with <code>import pdb ; pdb.set_trace()</code>.</p>

<h4>dir</h4>

<p>The <code>dir</code> function can be used for two things:</p>

<ol>
<li>Seeing a list of all your local variables</li>
<li>Seeing a list of all attributes on a particular object</li>
</ol>


<p>Here we can see that our local variables, right after starting a new Python shell and then after creating a new variable <code>x</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; dir()
['__annotations__', '__doc__', '__name__', '__package__']
&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; dir()
['__annotations__', '__doc__', '__name__', '__package__', 'x']
</code></pre>

<p>If we pass that <code>x</code> list into <code>dir</code> we can see all the attributes it has:</p>

<pre><code class="pycon">&gt;&gt;&gt; dir(x)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre>

<p>We can see the typical list methods, <code>append</code>, <code>pop</code>, <code>remove</code>, and more as well as many dunder methods for operator overloading.</p>

<h4>vars</h4>

<p>The <a href="https://docs.python.org/3/library/functions.html#vars">vars</a> function is sort of a mashup of two related things: checking <code>locals()</code> and testing the <code>__dict__</code> attribute of objects.</p>

<p>When <code>vars</code> is called with no arguments, it&rsquo;s equivalent to calling the <code>locals()</code> built-in function (which shows a dictionary of all local variables and their values).</p>

<pre><code class="python">&gt;&gt;&gt; vars()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;}
</code></pre>

<p>When it&rsquo;s called with an argument, it accesses the <code>__dict__</code> attribute on that object (which on many objects represents a dictionary of all instance attributes).</p>

<pre><code class="python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; vars(chain)
mappingproxy({'__getattribute__': &lt;slot wrapper '__getattribute__' of 'itertools.chain' objects&gt;, '__iter__': &lt;slot wrapper '__iter__' of 'itertools.chain' objects&gt;, '__next__': &lt;slot wrapper '__next__' of 'itertools.chain' objects&gt;, '__new__': &lt;built-in method __new__ of type object at 0x5611ee76fac0&gt;, 'from_iterable': &lt;method 'from_iterable' of 'itertools.chain' objects&gt;, '__reduce__': &lt;method '__reduce__' of 'itertools.chain' objects&gt;, '__setstate__': &lt;method '__setstate__' of 'itertools.chain' objects&gt;, '__doc__': 'chain(*iterables) --&gt; chain object\n\nReturn a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.'})
</code></pre>

<p>If you ever try to use <code>my_object.__dict__</code>, you can use <code>vars</code> instead.</p>

<p>I usually reach for <code>dir</code> just before using <code>vars</code>.</p>

<h4>type</h4>

<p>The <code>type</code> function will tell you the type of the object you pass to it.</p>

<p>The type of a class instance is the class itself:</p>

<pre><code class="pycon">&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; type(x)
&lt;class 'list'&gt;
</code></pre>

<p>The type of a class is its metaclass, which is usually <code>type</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; type(list)
&lt;class 'type'&gt;
&gt;&gt;&gt; type(type(x))
&lt;class 'type'&gt;
</code></pre>

<p>If you ever see someone reach for <code>__class__</code>, know that they could reach for the higher-level <code>type</code> function instead:</p>

<pre><code class="pycon">&gt;&gt;&gt; x.__class__
&lt;class 'list'&gt;
&gt;&gt;&gt; type(x)
&lt;class 'list'&gt;
</code></pre>

<p>The <code>type</code> function is sometimes helpful in actual code (especially object-oriented code with inheritance and custom string representations), but it&rsquo;s also useful when debugging.</p>

<p>Note that when <em>type checking</em>, the <code>isinstance</code> function is usually used instead of <code>type</code> (also note that we tend not to type check in Python because we prefer to practice <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>).</p>

<h4>help</h4>

<p>If you&rsquo;re in an interactive Python shell (the Python <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> as I usually call it), maybe debugging code using <code>breakpoint</code>, and you&rsquo;d like to know how a certain object, method, or attribute works, the <code>help</code> function will come in handy.</p>

<p>Realistically, you&rsquo;ll likely resort to getting help from your favorite search engine more often than using <code>help</code>.
But if you&rsquo;re already in a Python REPL, it&rsquo;s quicker to call <code>help(list.insert)</code> than it would be to look up the <code>list.insert</code> method documentation in Google.</p>

<h2>Learn it later</h2>

<p>There are quite a few built-in functions you&rsquo;ll likely want <em>eventually</em>, but you may not need <em>right now</em>.</p>

<p>I&rsquo;m going to mention 14 more built-in functions which are handy to know about, but not worth learning until you actually need to use them.</p>

<h3>open</h3>

<p>Need to open a file in Python?
You need the <code>open</code> function!</p>

<p>Don&rsquo;t work with files directly?
Then you likely don&rsquo;t need the <code>open</code> function!</p>

<p>You might think it&rsquo;s odd that I&rsquo;ve put <code>open</code> in this section because working with files is so common.
While most programmers will read or write to files using <code>open</code> at some point, some Python programmers, such as Django developers, may not use the <code>open</code> function very much (if at all).</p>

<p>Once you need to work with files, you&rsquo;ll learn about <code>open</code>.
Until then, don&rsquo;t worry about it.</p>

<p>By the way, you might want to <a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/">look into pathlib</a> (which is in the Python standard library) as an alternative to using <code>open</code>.
I love the <code>pathlib</code> module so much I&rsquo;ve considered teaching files in Python by mentioning <code>pathlib</code> first and the built-in <code>open</code> function later.</p>

<h3>input</h3>

<p>The <code>input</code> function prompts the user for input, waits for them to hit the Enter key, and then returns the text they typed.</p>

<p>Reading from <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)">standard input</a> (which is what the <code>input</code> function does) is one way to get inputs into your Python program, but there are so many other ways too!
You could accept command-line arguments, read from a configuration file, read from a database, and much more.</p>

<p>You&rsquo;ll learn this once you need to prompt the user of a command-line program for input.
Until then, you won&rsquo;t need it.
And if you&rsquo;ve been writing Python for a while and don&rsquo;t know about this function, you may simply never need it.</p>

<h3>repr</h3>

<p>Need the programmer-readable representation of an object?
You need the <code>repr</code> function!</p>

<p>For many objects, the <code>str</code> and <code>repr</code> representations are the same:</p>

<pre><code class="pycon">&gt;&gt;&gt; str(4), repr(4)
('4', '4')
&gt;&gt;&gt; str([]), repr([])
('[]', '[]')
</code></pre>

<p>But for some objects, they&rsquo;re different:</p>

<pre><code class="pycon">&gt;&gt;&gt; str('hello'), repr("hello")
('hello', "'hello'")
&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; str(date(2020, 1, 1)), repr(date(2020, 1, 1))
('2020-01-01', 'datetime.date(2020, 1, 1)')
</code></pre>

<p>The string representation we see at the Python REPL uses <code>repr</code>, while the <code>print</code> function relies on <code>str</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; date(2020, 1, 1)
datetime.date(2020, 1, 1)
&gt;&gt;&gt; "hello!"
'hello!'
&gt;&gt;&gt; print(date(2020, 1, 1))
2020-01-01
&gt;&gt;&gt; print("hello!")
hello!
</code></pre>

<p>You&rsquo;ll see <code>repr</code> used when logging, handling exceptions, and implementing dunder methods.</p>

<h3>super</h3>

<p>If you create classes in Python, you&rsquo;ll likely need to use <code>super</code>.
The <code>super</code> function is pretty much essential whenever you&rsquo;re inheriting from another Python class.</p>

<p>Many Python users rarely create classes.
Creating classes isn&rsquo;t an <em>essential</em> part of Python, though many types of programming require it.
For example, you can&rsquo;t really use the <a href="https://djangoproject.com/">Django</a> web framework without creating classes.</p>

<p>If you don&rsquo;t already know about <code>super</code>, you&rsquo;ll end up learning this if and when you need it.</p>

<h3>property</h3>

<p>The <code>property</code> function is a <a href="https://docs.python.org/3/glossary.html#term-decorator">decorator</a> and a <a href="https://docs.python.org/3/glossary.html#term-descriptor">descriptor</a> (only click those weird terms if you&rsquo;re extra curious) and it&rsquo;ll likely seem somewhat magical when you first learn about it.</p>

<p>This decorator allows us to create an attribute which will always seem to contain the return value of a particular function call.
It&rsquo;s easiest to understand with an example.</p>

<p>Here&rsquo;s a class that uses <code>property</code>:</p>

<pre><code class="python">class Circle:

    def __init__(self, radius=1):
        self.radius = radius

    @property
    def diameter(self):
        return self.radius * 2
</code></pre>

<p>Here&rsquo;s an access of that <code>diameter</code> attribute on a <code>Circle</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; circle = Circle()
&gt;&gt;&gt; circle.diameter
2
&gt;&gt;&gt; circle.radius = 5
&gt;&gt;&gt; circle.diameter
10
</code></pre>

<p>If you&rsquo;re doing object-oriented Python programming (you&rsquo;re making classes a whole bunch), you&rsquo;ll likely want to learn about <code>property</code> at some point.
Unlike other object-oriented programming languages, <strong>we use properties instead of getter methods and setter methods</strong>.</p>

<h3>issubclass and isinstance</h3>

<p>The <code>issubclass</code> function checks whether a class is a subclass of one or more other classes.</p>

<pre><code class="pycon">&gt;&gt;&gt; issubclass(int, bool)
False
&gt;&gt;&gt; issubclass(bool, int)
True
&gt;&gt;&gt; issubclass(bool, object)
True
</code></pre>

<p>The <code>isinstance</code> function checks whether an object is an instance of one or more classes.</p>

<pre><code class="pycon">&gt;&gt;&gt; isinstance(True, str)
False
&gt;&gt;&gt; isinstance(True, bool)
True
&gt;&gt;&gt; isinstance(True, int)
True
&gt;&gt;&gt; isinstance(True, object)
True
</code></pre>

<p>You can think of <code>isinstance</code> as delegating to <code>issubclass</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; issubclass(type(True), str)
False
&gt;&gt;&gt; issubclass(type(True), bool)
True
&gt;&gt;&gt; issubclass(type(True), int)
True
&gt;&gt;&gt; issubclass(type(True), object)
True
</code></pre>

<p>If you&rsquo;re <a href="https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations">overloading operators</a> (e.g. customizing what the <code>+</code> operator does on your class) you might need to use <code>isinstance</code>, but in general we try to avoid strong type checking in Python so we don&rsquo;t see these much.</p>

<p>In Python we usually prefer duck typing over type checking.
These functions actually do a bit more than the strong type checking I noted above (<a href="https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks">the behavior of both can be customized</a>) so it&rsquo;s actually possible to practice a sort of <code>isinstance</code>-powered duck typing with abstract base classes like <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable">collections.abc.Iterable</a>.
But this isn&rsquo;t seen much either (partly because we tend to practice exception-handling and <a href="https://docs.python.org/3/glossary.html#term-eafp">EAFP</a> a bit more than condition-checking and <a href="https://docs.python.org/3/glossary.html#term-lbyl">LBYL</a> in Python).</p>

<p>The last two paragraphs were filled with confusing jargon that I may explain more thoroughly in a future serious of articles if there&rsquo;s enough interest.</p>

<h3>hasattr, getattr, setattr, and delattr</h3>

<p>Need to work with an attribute on an object but the attribute name is dynamic?
You need <code>hasattr</code>, <code>getattr</code>, <code>setattr</code>, and <code>delattr</code>.</p>

<p>Say we have some <code>thing</code> object we want to check for a particular value on:</p>

<pre><code class="pycon">&gt;&gt;&gt; class Thing: pass
...
&gt;&gt;&gt; thing = Thing()
</code></pre>

<p>The <code>hasattr</code> function allows us to check whether the object <em>has</em> a certain attribute (note that <code>hasattr</code> <a href="https://hynek.me/articles/hasattr/">has some quirks</a>, though most have been ironed out in Python 3):</p>

<pre><code class="pycon">&gt;&gt;&gt; hasattr(thing, 'x')
False
&gt;&gt;&gt; thing.x = 4
&gt;&gt;&gt; hasattr(thing, 'x')
True
</code></pre>

<p>The <code>getattr</code> function allows us to retrieve the value of that attribute (with an optional default if the attribute doesn&rsquo;t exist):</p>

<pre><code class="pycon">&gt;&gt;&gt; getattr(thing, 'x')
4
&gt;&gt;&gt; getattr(thing, 'x', 0)
4
&gt;&gt;&gt; getattr(thing, 'y', 0)
0
</code></pre>

<p>The <code>setattr</code> function allows for setting the value:</p>

<pre><code class="pycon">&gt;&gt;&gt; setattr(thing, 'x', 5)
&gt;&gt;&gt; thing.x
5
</code></pre>

<p>And <code>delattr</code> deletes the attribute:</p>

<pre><code class="pycon">&gt;&gt;&gt; delattr(thing, 'x')
&gt;&gt;&gt; thing.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Thing' object has no attribute 'x'
</code></pre>

<p>These functions allow for a specific flavor of <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> and you likely won&rsquo;t see them often.</p>

<h3>classmethod and staticmethod</h3>

<p>The <code>classmethod</code> and <code>staticmethod</code> decorators are somewhat magical in the same way the <code>property</code> decorator is somewhat magical.</p>

<p>If you have a method that should be callable on either an instance or a class, you want the <code>classmethod</code> decorator.
Factory methods (alternative constructors) are a common use case for this:</p>

<pre><code class="python">class RomanNumeral:

    """A Roman numeral, represented as a string and numerically."""

    def __init__(self, number):
        self.value = number

    @classmethod
    def from_string(cls, string):
        return cls(roman_to_int(string))  # function doesn't exist yet
</code></pre>

<p>It&rsquo;s a bit harder to come up with a good use for <code>staticmethod</code>, since you can pretty much always use a module-level function instead of a static method.</p>

<pre><code class="python">class RomanNumeral:

    """A Roman numeral, represented as a string and numerically."""

    SYMBOLS = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}

    def __init__(self, number):
        self.value = number

    @classmethod
    def from_string(cls, string):
        return cls(cls.roman_to_int(string))

    @staticmethod
    def roman_to_int(numeral):
        total = 0
        for symbol, next_symbol in zip_longest(numeral, numeral[1:]):
            value = RomanNumeral.SYMBOLS[symbol]
            next_value = RomanNumeral.SYMBOLS.get(next_symbol, 0)
            if value &lt; next_value:
                value = -value
            total += value
        return total
</code></pre>

<p>The above <code>roman_to_int</code> function doesn&rsquo;t require access to the instance <em>or</em> the class, so it doesn&rsquo;t even need to be a <code>@classmethod</code>.
There&rsquo;s no actual need to make this function a <code>staticmethod</code> (instead of a <code>classmethod</code>): <code>staticmethod</code> is just more restrictive to signal the fact that we&rsquo;re not reliant on the class our function lives on.</p>

<p>I find that learning these causes folks to <em>think</em> they need them when they often don&rsquo;t.
You can go looking for these if you really need them eventually.</p>

<h3>next</h3>

<p>The <code>next</code> function returns the <em>next</em> item in an iterator.</p>

<p>I&rsquo;ve written about iterators before (<a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">how for loops work</a> and <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">how to make an iterator</a>) but a very quick summary of iterators you&rsquo;ll likely run into includes:</p>

<ul>
<li><code>enumerate</code> objects</li>
<li><code>zip</code> objects</li>
<li>the return value of the <code>reversed</code> function</li>
<li>files (the thing you get back from the <code>open</code> function)</li>
<li><code>csv.reader</code> objects</li>
<li>generator expressions</li>
<li>generator functions</li>
</ul>


<p>You can think of <code>next</code> as a way to manually loop over an iterator to get a single item and then break.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; next(squares)
4
&gt;&gt;&gt; for n in squares:
...     break
...
&gt;&gt;&gt; n
1
&gt;&gt;&gt; next(squares)
9
</code></pre>

<h2>Maybe learn it eventually</h2>

<p>We&rsquo;ve already covered nearly half of the built-in functions.</p>

<p>The rest of Python&rsquo;s built-in functions definitely aren&rsquo;t useless, but they&rsquo;re a bit more special-purposed.</p>

<p>The 15 built-ins I&rsquo;m mentioning in this section are things you may eventually need to learn, but it&rsquo;s also very possible you&rsquo;ll never reach for these in your own code.</p>

<ul>
<li><strong><a href="https://docs.python.org/3/library/functions.html#iter">iter</a></strong>: get an iterator from an iterable: this function <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">powers <code>for</code> loops</a> and it can be very useful when you&rsquo;re making helper functions for looping lazily</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#callable">callable</a></strong>: return <code>True</code> if the argument is a callable (I talked about this a bit in my article <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#Callable_objects">functions and callables</a>)</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#filter">filter</a></strong> and <strong><a href="https://docs.python.org/3/library/functions.html#map">map</a></strong>: as I discuss in my article on <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/">overusing lambda functions</a>, I recommend using generator expressions over the built-in <code>map</code> and <code>filter</code> functions</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#id">id</a></strong>, <strong><a href="https://docs.python.org/3/library/functions.html#locals">locals</a></strong>, and <strong><a href="https://docs.python.org/3/library/functions.html#globals">globals</a></strong>: these are great tools for teaching Python and you may have already seen them, but you won&rsquo;t see these much in real Python code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#round">round</a></strong>: you&rsquo;ll look this up if you need to round a number</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#divmod">divmod</a></strong>: this function does a floor division (<code>//</code>) and a modulo operation (<code>%</code>) at the same time</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#bin">bin</a></strong>, <strong><a href="https://docs.python.org/3/library/functions.html#oct">oct</a></strong>, and <strong><a href="https://docs.python.org/3/library/functions.html#hex">hex</a></strong>: if you need to display a number as a string in binary, octal, or hexadecimal form, you&rsquo;ll want these functions</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#abs">abs</a></strong>: when you need the absolute value of a number, you&rsquo;ll look this up</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#hash">hash</a></strong>: dictionaries and sets rely on the <code>hash</code> function to test for <a href="https://lerner.co.il/2015/04/03/is-it-hashable-fun-and-games-with-hashing-in-python/">hashability</a>, but you likely won&rsquo;t need it unless you&rsquo;re implementing a clever de-duplication algorithm</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#object">object</a></strong>: this function (yes it&rsquo;s a class) is useful for making <a href="https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/">unique default values and sentinel values</a>, if you ever need those</li>
</ul>


<p>You&rsquo;re unlikely to need all the above built-ins, but if you write Python code for long enough you&rsquo;re likely to see nearly all of them.</p>

<h2>You likely don&rsquo;t need these</h2>

<p>You&rsquo;re unlikely to need these built-ins.
There are sometimes really appropriate uses for a few of these, but you&rsquo;ll likely be able to get away with never learning about these.</p>

<ul>
<li><strong><a href="https://docs.python.org/3/library/functions.html#ord">ord</a></strong> and <strong><a href="https://docs.python.org/3/library/functions.html#chr">chr</a></strong>: these are fun for teaching ASCII tables and unicode code points, but I&rsquo;ve never really found a use for them in my own code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#exec">exec</a></strong> and <strong><a href="https://docs.python.org/3/library/functions.html#eval">eval</a></strong>: for evaluating a string as if it was code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#compile">compile</a></strong>: this is related to <code>exec</code> and <code>eval</code></li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#slice">slice</a></strong>: if you&rsquo;re implementing <code>__getitem__</code> to make a custom sequence, you may need this (some <a href="https://www.pythonmorsels.com/">Python Morsels</a> exercises require this actually), but unless you make your own custom sequence you&rsquo;ll likely never see <code>slice</code></li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#bytes">bytes</a></strong>, <strong><a href="https://docs.python.org/3/library/functions.html#bytearray">bytearray</a></strong>, and <strong><a href="https://docs.python.org/3/library/functions.html#memoryview">memoryview</a></strong>: if you&rsquo;re working with bytes often, you&rsquo;ll reach for some of these (just ignore them until then)</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#ascii">ascii</a></strong>: like <code>repr</code> but returns an ASCII-only representation of an object; I haven&rsquo;t needed this in my code yet</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#frozenset">frozenset</a></strong>: like <code>set</code>, but it&rsquo;s immutable (and hashable!); very neat but not something I&rsquo;ve needed in my own code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#__import__">__import__</a></strong>: this function isn&rsquo;t really meant to be used by you, use <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module">importlib</a> instead</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#format">format</a></strong>: this calls the <code>__format__</code> method, which is used for string formatting (<a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings">f-strings</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.format">str.format</a>); you usually don&rsquo;t need to call this function directly</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#pow">pow</a></strong>: the exponentiation operator (<code>**</code>) usually supplants this&hellip; unless you&rsquo;re doing modulo-math (maybe you&rsquo;re implementing <a href="http://code.activestate.com/recipes/578838-rsa-a-simple-and-easy-to-read-implementation/">RSA encryption</a> from scratch&hellip;?)</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#complex">complex</a></strong>: if you didn&rsquo;t know that <code>4j+3</code> is valid Python code, you likely don&rsquo;t need the <code>complex</code> function</li>
</ul>


<h2>There&rsquo;s always more to learn</h2>

<p>There are 69 built-in functions in Python (technically <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#The_distinction_between_functions_and_classes_often_doesn%E2%80%99t_matter">only 42 of them are actually functions</a>).</p>

<p>When you&rsquo;re newer in your Python journey, I recommend focusing on only 20 of these built-in functions in your own code (the <a href="#10_Commonly_known_built-in_functions">10 commonly known built-ins</a> and the <a href="#Built-ins_overlooked_by_new_Pythonistas">10 built-ins that are often overlooked</a>), in addition to the <a href="#The_5_debugging_functions">5 debugging functions</a>.</p>

<p>After that there are <a href="#Learn_it_later">14 more built-ins which you&rsquo;ll probably learn later</a> (depending on the style of programming you do).</p>

<p>Then come <a href="#Maybe_learn_it_eventually">the 15 built-ins which you may or may not ever end up needing in your own code</a>.
Some people love these built-ins and some people never use them: as you get more specific in your coding needs, you&rsquo;ll likely find yourself reaching for considerably more niche tools.</p>

<p>After that I mentioned <a href="#You_likely_don%E2%80%99t_need_these">the last 15 built-ins which you&rsquo;ll likely never need</a> (again, very much depending on how you use Python).</p>

<p>You don&rsquo;t need to learn all the Python built-in functions today.
Take it slow: focus on those first 20 important built-ins and then work your way into learning about others if and when you eventually need them.</p>
]]></content>
  </entry>
  
</feed>
