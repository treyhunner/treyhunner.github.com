<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="http://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://treyhunner.com/"/>
  <updated>2019-04-23T15:23:27-07:00</updated>
  <id>http://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Is it a class or a function? It's a callable!]]></title>
    <link href="http://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/"/>
    <updated>2019-04-16T10:20:00-07:00</updated>
    <id>http://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable</id>
    <content type="html"><![CDATA[<p>If you search course curriculum I&rsquo;ve written, you&rsquo;ll often find phrases like &ldquo;<code>zip</code> function&rdquo;, &ldquo;<code>enumerate</code> function&rdquo;, and &ldquo;<code>list</code> function&rdquo;.
Those terms are all technically misnomers.</p>

<p>When I use terms like &ldquo;the <code>bool</code> function&rdquo; and &ldquo;the <code>str</code> function&rdquo; I&rsquo;m incorrectly implying that <code>bool</code> and <code>str</code> are functions.
But these <strong>aren&rsquo;t functions: they&rsquo;re classes</strong>!</p>

<p>I&rsquo;m going to explain why this confusion between classes and functions happens in Python and then explain <strong>why this distinction often doesn&rsquo;t matter</strong>.</p>

<ul data-toc=".entry-content"></ul>


<h2>Class or function?</h2>

<p>When I&rsquo;m training a new group of Python developers, there&rsquo;s group activity we often do: the class or function game.</p>

<p>In <strong>the class or function game</strong>, we take something that we &ldquo;call&rdquo; (using parenthesis: <code>()</code>) and we guess whether it&rsquo;s a class or a function.</p>

<p>For example:</p>

<ul>
<li>We can call <code>zip</code> with a couple iterables and we get another iterable back, so is <code>zip</code> a class or a function?</li>
<li>When we call <code>len</code>, are we calling a class or a function?</li>
<li>What about <code>int</code>: when we write <code>int('4')</code> are we calling a class or a function?</li>
</ul>


<p>Python&rsquo;s <code>zip</code>, <code>len</code>, and <code>int</code> are all often guessed to be functions, but <strong>only one of these is really a function</strong>:</p>

<pre><code class="pycon">&gt;&gt;&gt; zip
&lt;class 'zip'&gt;
&gt;&gt;&gt; len
&lt;built-in function len&gt;
&gt;&gt;&gt; int
&lt;class 'int'&gt;
</code></pre>

<p>While <code>len</code> is a function, <code>zip</code> and <code>int</code> are classes.</p>

<p>The <code>reversed</code>, <code>enumerate</code>, <code>range</code>, and <code>filter</code> &ldquo;functions&rdquo; also aren&rsquo;t really functions:</p>

<pre><code class="pycon">&gt;&gt;&gt; reversed
&lt;class 'reversed'&gt;
&gt;&gt;&gt; enumerate
&lt;class 'enumerate'&gt;
&gt;&gt;&gt; range
&lt;class 'range'&gt;
&gt;&gt;&gt; filter
&lt;class 'filter'&gt;
</code></pre>

<p>After playing the class or function game, we always discuss <strong>callables</strong>, and then we discuss the fact that <strong>we often don&rsquo;t care whether something is a class or a function</strong>.</p>

<h2>What&rsquo;s a callable?</h2>

<p>A <strong>callable</strong> is anything you can <em>call</em>, using parenthesis, and possibly passing arguments.</p>

<p>All three of these lines involve callables:</p>

<pre><code class="pycon">&gt;&gt;&gt; something()
&gt;&gt;&gt; x = AnotherThing()
&gt;&gt;&gt; something_else(4, 8, *x)
</code></pre>

<p>We don&rsquo;t know what <code>something</code>, <code>AnotherThing</code>, and <code>something_else</code> do: but we <em>know</em> they&rsquo;re callables.</p>

<p>We have a number of callables in Python:</p>

<ul>
<li>Functions are callables</li>
<li>Classes are callables</li>
<li>Methods (which are functions that hang off of classes) are callables</li>
<li>Instances of classes can even be turned into callables</li>
</ul>


<p>Callables are a pretty important concept in Python.</p>

<h2>Classes are callables</h2>

<p>Functions are the most obvious callable in Python.
Functions can be &ldquo;called&rdquo; in every programming language.
A <em>class</em> being callable is a bit more unique though.</p>

<p>In JavaScript we can make an &ldquo;instance&rdquo; of the <code>Date</code> class like this:</p>

<pre><code class="javascript">&gt; new Date(2020, 1, 1, 0, 0)
2020-02-01T08:00:00.000Z
</code></pre>

<p>In JavaScript the class instantiation syntax (the way we create an &ldquo;instance&rdquo; of a class) involves the <code>new</code> keyword.
In Python we don&rsquo;t have a <code>new</code> keyword.</p>

<p>In Python we can make an &ldquo;instance&rdquo; of the <code>datetime</code> class (from <code>datetime</code>) like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; datetime(2020, 1, 1, 0, 0)
datetime.datetime(2020, 1, 1, 0, 0)
</code></pre>

<p>In Python, the syntax for <strong>instantiating a new class instance</strong> is the same as the syntax for <strong>calling a function</strong>.
There&rsquo;s no <code>new</code> needed: we just call the class.</p>

<p>When we <strong>call a function</strong>, we get its return value.
When we <strong>call a class</strong>, we get an &ldquo;instance&rdquo; of that class.</p>

<p><strong>We use the same syntax for constructing objects from classes and for calling functions</strong>: this fact is the main reason the word &ldquo;callable&rdquo; is such an important part of our Python vocabulary.</p>

<h2>Disguising classes as functions</h2>

<p>There are many classes-which-look-like-functions among the Python built-ins and in the Python standard library.</p>

<p>I sometimes explain <strong>decorators</strong> (an intermediate-level Python concept) as &ldquo;functions which accept functions and return functions&rdquo;.</p>

<p>But that&rsquo;s not an entirely accurate explanation.
There are also <strong>class decorators</strong>: functions which accept classes and return classes.
And there are also <strong>decorators which are implemented using classes</strong>: classes which accept functions and return objects.</p>

<p>A better explanation of the term decorators might be &ldquo;callables which accept callables and return callables&rdquo; (still not entirely accurate, but good enough for our purposes).</p>

<p>Python&rsquo;s <a href="https://docs.python.org/3/library/functions.html#property">property</a> decorator seems like a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; class Circle:
...     def __init__(self, radius):
...         self.radius = radius
...     @property
...     def diameter(self):
...         return self.radius * 2
...
&gt;&gt;&gt; c = Circle(5)
&gt;&gt;&gt; c.diameter
10
</code></pre>

<p>But it&rsquo;s a class:</p>

<pre><code class="pycon">&gt;&gt;&gt; property
&lt;class 'property'&gt;
</code></pre>

<p>The <code>classmethod</code> and <code>staticmethod</code> decorators are <em>also</em> classes:</p>

<pre><code class="pycon">&gt;&gt;&gt; classmethod
&lt;class 'classmethod'&gt;
&gt;&gt;&gt; staticmethod
&lt;class 'staticmethod'&gt;
</code></pre>

<p>What about context managers, like <a href="https://docs.python.org/3.5/library/contextlib.html#contextlib.suppress">suppress</a> and <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout">redirect_stdout</a> from the <code>contextlib</code> module?
These both use the <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> naming convention, so they seem like functions:</p>

<pre><code class="pycon">&gt;&gt;&gt; from contextlib import suppress
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; with suppress(ValueError):
...     int('hello')
...
&gt;&gt;&gt; with redirect_stdout(StringIO()) as fake_stdout:
...     print('hello!')
...
&gt;&gt;&gt; fake_stdout.getvalue()
'hello!\n'
</code></pre>

<p>But they&rsquo;re actually <strong>implemented using classes</strong>, despite the <code>snake_case</code> naming convention:</p>

<pre><code class="pycon">&gt;&gt;&gt; suppress
&lt;class 'contextlib.suppress'&gt;
&gt;&gt;&gt; redirect_stdout
&lt;class 'contextlib.redirect_stdout'&gt;
</code></pre>

<p>Decorators and context managers are just two places in Python where you&rsquo;ll often see callables which look like functions but aren&rsquo;t.
Whether a <strong>callable</strong> is a class or a function is often <strong>just an implementation detail</strong>.</p>

<p>It&rsquo;s not really a mistake to refer to <code>property</code> or <code>redirect_stdout</code> as functions because <strong>they may as well be functions</strong>.
We can <strong>call</strong> them, and that&rsquo;s what we care about.</p>

<h2>Callable objects</h2>

<p>Python&rsquo;s &ldquo;call&rdquo; syntax, those <code>(...)</code> parenthesis, can <strong>create a class instance</strong> or <strong>call a function</strong>.
But this &ldquo;call&rdquo; syntax can <strong>also be used to call an object</strong>.</p>

<p>Technically, everything in Python &ldquo;is an object&rdquo;:</p>

<pre><code class="pycon">&gt;&gt;&gt; isinstance(len, object)
True
&gt;&gt;&gt; isinstance(range, object)
True
&gt;&gt;&gt; isinstance(range(5), object)
True
</code></pre>

<p>But we often use the term &ldquo;object&rdquo; to imply that we&rsquo;re working with an instance of a class (by <em>instance of a class</em> I mean &ldquo;the thing you get back when you call a class&rdquo;).</p>

<p>There&rsquo;s a <a href="https://docs.python.org/3.5/library/functools.html#functools.partial">partial</a> function which lives in the <code>functools</code> module, which can &ldquo;partially evaluate&rdquo; a function by storing arguments to be used when calling the function later.
This is often used to make Python look a bit more like a functional programming language:</p>

<pre><code class="pycon">&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; just_numbers = partial(filter, str.isdigit)
&gt;&gt;&gt; list(just_numbers(['4', 'hello', '50']))
['4', '50']
</code></pre>

<p>I said above that Python has &ldquo;a <code>partial</code> function&rdquo;, which is both true and false.</p>

<p>While the phrase &ldquo;a <code>partial</code> function&rdquo; makes sense, the <code>partial</code> callable <strong>isn&rsquo;t implemented using a function</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; partial
&lt;class '__main__.partial'&gt;
</code></pre>

<p>The Python core developers <em>could</em> have implemented <code>partial</code> as a function, like this:</p>

<pre><code class="python">def partial(func, *args, **kwargs):
    """Return "partially evaluated" version of given function/arguments."""
    def wrapper(*more_args, **more_kwargs):
        all_kwargs = {**kwargs, **more_kwargs}
        return func(*args, *more_args, **all_kwargs)
    return wrapper
</code></pre>

<p>But instead they chose to use a class, doing something more like this:</p>

<pre><code class="python">class partial:
    """Return "partially evaluated" version of given function/arguments."""
    def __init__(self, func, *args, **kwargs):
        self.func, self.args, self.kwargs = func, args, kwargs
    def __call__(self, *more_args, **more_kwargs):
        all_kwargs = {**self.kwargs, **more_kwargs}
        return self.func(*self.args, *more_args, **all_kwargs)
</code></pre>

<p>That <code>__call__</code> method allows us to <em>call</em> <code>partial</code> objects.
So the <code>partial</code> class makes a <strong>callable object</strong>.</p>

<p>Adding a <code>__call__</code> method to any class will <strong>make instances of that class callable</strong>.
In fact, checking for a <code>__call__</code> method is one way to ask the question &ldquo;is this object callable?&rdquo;</p>

<p>All functions, classes, and callable objects have a <code>__call__</code> method:</p>

<pre><code class="pycon">&gt;&gt;&gt; hasattr(open, '__call__')
True
&gt;&gt;&gt; hasattr(dict, '__call__')
True
&gt;&gt;&gt; hasattr({}, '__call__')
False
</code></pre>

<p>Though a better way to check for callability than looking for a <code>__call__</code> is to use the built-in <code>callable</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; callable(len)
True
&gt;&gt;&gt; callable(list)
True
&gt;&gt;&gt; callable([])
False
</code></pre>

<p>In Python, classes, functions, and instances of classes can all be used as &ldquo;callables&rdquo;.</p>

<h2>The distinction between functions and classes often doesn&rsquo;t matter</h2>

<p>The Python documentation has a page called <a href="https://docs.python.org/3/library/functions.html#built-in-funcs">Built-in Functions</a>.
But this Built-in Functions page <strong>isn&rsquo;t actually for built-in functions</strong>: it&rsquo;s for built-in callables.</p>

<p>Of the 69 &ldquo;built-in functions&rdquo; listed in the Python Built-In Functions page, <strong>only 42 are actually implemented as functions</strong>: 26 are classes and 1 (<code>help</code>) is an instance of a callable class.</p>

<p>Of the 26 classes among those built-in &ldquo;functions&rdquo;, four <em>were</em> actually functions in Python 2 (the now-lazy <code>map</code>, <code>filter</code>, <code>range</code>, and <code>zip</code>) but have since become classes.</p>

<p>The Python built-ins and the standard library are both full of maybe-functions-maybe-classes.</p>

<h3>operator.itemgetter</h3>

<p>The <code>operator</code> module has lots of callables:</p>

<pre><code class="pycon">&gt;&gt;&gt; from operator import getitem, itemgetter
&gt;&gt;&gt; get_a_and_b = itemgetter('a', 'b')
&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; get_a_and_b(d)
(1, 2)
&gt;&gt;&gt; getitem(d, 'a'), getitem(d, 'b')
(1, 2)
</code></pre>

<p>Some of these callables (like <a href="https://docs.python.org/3.5/library/operator.html#operator.itemgetter">itemgetter</a> are <em>callable classes</em>) while others (like <code>getitem</code>) are functions:</p>

<pre><code class="pycon">&gt;&gt;&gt; itemgetter
&lt;class 'operator.itemgetter'&gt;
&gt;&gt;&gt; get_a_and_b
operator.itemgetter('a', 'b')
&gt;&gt;&gt; getitem
&lt;built-in function getitem&gt;
</code></pre>

<p>The <code>itemgetter</code> class <em>could</em> have been implemented as &ldquo;a function that returns a function&rdquo;.
Instead it&rsquo;s a class which implements a <code>__call__</code> method, so its class instances are callable.</p>

<h3>Iterators</h3>

<p>Generator functions are functions which return iterators when called (<a href="https://youtu.be/V2PkkMS2Ack?t=858">generators are iterators</a>):</p>

<pre><code class="python">def count(n=0):
    """Generator that counts upward forever."""
    while True:
        yield n
        n += 1
</code></pre>

<p>And <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">iterator classes</a> are classes which return iterators when called:</p>

<pre><code class="python">class count:
    """Iterator that counts upward forever."""
    def __init__(self, n=0):
        self.n = n
    def __iter__(self):
        return self
    def __next__(self):
        n = self.n
        self.n += 1
        return n
</code></pre>

<p>Iterators can be defined using functions or using classes: whichever you choose is an implementation detail.</p>

<h3>The sorted &ldquo;key function&rdquo;</h3>

<p>The built-in <a href="https://docs.python.org/3.5/library/functions.html#sorted">sorted</a> function has an optional <code>key</code> argument, which is called to get &ldquo;comparison keys&rdquo; for sorting (<code>min</code> and <code>max</code> have a similar <code>key</code> argument).</p>

<p>This <code>key</code> argument can be a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; def digit_count(s): return len(s.replace('_', ''))
...
&gt;&gt;&gt; numbers = ['400', '2_020', '800_000']
&gt;&gt;&gt; sorted(numbers, key=digit_count)
['400', '2_020', '800_000']
</code></pre>

<p>But it can also be a class:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = ['400', '2_020', '800_000']
&gt;&gt;&gt; sorted(numbers, key=int)
['400', '2_020', '800_000']
</code></pre>

<p>The Python documentation says &ldquo;key specifies a function of one argument&hellip;&rdquo;.
That&rsquo;s not <em>technically</em> correct because key can be any callable, not just a function.
But <strong>we often use the words &ldquo;function&rdquo; and &ldquo;callable&rdquo; interchangeably</strong> in Python, and that&rsquo;s okay.</p>

<h3>The defaultdict &ldquo;factory function&rdquo;</h3>

<p>The <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">defaultdict</a> class in the <code>collections</code> module accepts a &ldquo;factory&rdquo; callable, which is used to generate default values for missing dictionary items.</p>

<p>Usually we use a class as a <code>defaultdict</code> factory:</p>

<pre><code class="pycon">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; counts = defaultdict(int)
&gt;&gt;&gt; counts['snakes']
0
&gt;&gt;&gt; things = defaultdict(list)
&gt;&gt;&gt; things['newer'].append('Python 3')
&gt;&gt;&gt; things['newer']
['Python 3']
</code></pre>

<p>But <code>defaultdict</code> can also accept a function (or any other callable):</p>

<pre><code class="pycon">&gt;&gt;&gt; import random
&gt;&gt;&gt; colors = ['blue', 'yellow', 'purple', 'green']
&gt;&gt;&gt; favorite_colors = defaultdict(lambda: random.choice(colors))
&gt;&gt;&gt; favorite_colors['Kevin']
'yellow'
&gt;&gt;&gt; favorite_colors['Stacy']
'green'
&gt;&gt;&gt; probabilities = defaultdict(random.random)
&gt;&gt;&gt; probabilities['having fun']
0.6714530824158086
&gt;&gt;&gt; probabilities['seeing a snake']
0.07703364911089605
</code></pre>

<p>Pretty much anywhere a &ldquo;callable&rdquo; is accepted in Python, a function, a class, or some other callable object will work just fine.</p>

<h2>Think in terms of &ldquo;callables&rdquo; not &ldquo;classes&rdquo; or &ldquo;functions&rdquo;</h2>

<p>In the <a href="https://www.pythonmorsels.com/">Python Morsels</a> exercises I send out every week, I often ask learners to make a &ldquo;callable&rdquo;.
Often I&rsquo;ll say something like &ldquo;this week I&rsquo;d like you to make a callable which returns an iterator&hellip;&rdquo;.</p>

<p>I say &ldquo;callable&rdquo; because I want <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">an iterator</a> back, but I really don&rsquo;t care whether the callable created is a <strong>generator function</strong>, an <strong>iterator class</strong>, or a <strong>function that returns a generator expression</strong>.
All of these things are <em>callables</em> which return the right type that I&rsquo;m testing for (an iterator).
It&rsquo;s up to you, the implementor of this callable, to determine how you&rsquo;d like to define it.</p>

<p>We practice <strong>duck typing</strong> in Python: <strong>if it looks like a duck and quacks like a duck, it&rsquo;s a duck</strong>.
Because of duck typing we tend to use general terms to describe specific things: lists are sequences, iterators are generators, dictionaries are mappings, and functions are callables.</p>

<p>If something looks like a callable and quacks (or rather, calls) like a callable, it&rsquo;s a callable.
Likewise, if something looks like a function and quacks (calls) like a function, we can call it a function&hellip; <strong>even if it&rsquo;s actually implemented using a class or a callable object</strong>!</p>

<p>Callables accept arguments and return something useful to the caller.
When we <em>call</em> classes we get instances of that class back.
When we <em>call</em> functions we get the return value of that function back.
The distinction between a class and a function is <strong>rarely important from the perspective of the caller</strong>.</p>

<p>When talking about passing functions or class objects around, try to think in terms of <em>callables</em>.
<strong>What happens when you call something</strong> is often more important than <strong>what that thing actually is</strong>.</p>

<p>More importantly though, if someone mislabels a function as a class or a class as a function, <strong>don&rsquo;t correct them unless the distinction is actually relevant</strong>.
A function is a callable and a class is a callable: the distinction between these two can often be disregarded.</p>

<h2>Want some practice with callables?</h2>

<p>You don&rsquo;t learn by putting more information into your head.
You learn through recall, that is trying to retrieve information for your head.</p>

<p>If you&rsquo;d like to get some practice with the <code>__call__</code> method, if you&rsquo;d like to make your own iterable/iterator-returning callables, or if you just want to practice working with &ldquo;callables&rdquo;, I have a Python Morsels exercise for you.</p>

<p>Python Morsels is a weekly Python skill-building service.
I send one exercise every week and the first 5 are free.</p>

<p>If you sign up for Python Morsels using the below form, I&rsquo;ll send you one callable-related exercise of your choosing (choose using the selection below).</p>

<h4>Which Python exercise would you like right now?</h4>

<p><form method="post" action="https://www.pythonmorsels.com/signup/">
    <label><input type="radio" name="exercise_track" value="callables1"> Novice exercise with a bonus involving callables</label>
    <br>
    <label><input type="radio" name="exercise_track" value="callables2"> Making a callable which returns an iterable</label>
    <br>
    <label><input type="radio" name="exercise_track" value="callables3"> Making an iterator-returning callable</label>
    <br>
    <label><input type="radio" name="exercise_track" value="callables4">Advanced exercise with bonuses showing the downside of <code>__call__</code></label>
    <br>
    <br>
    <input type="hidden" name="form_id" value="callables">
    <input type="email" name="email" placeholder="Your email address" class="subscribe-email form-big" required>
    <button type="submit" class="subscribe-btn form-big">Get my Python Morsels exercise</button>
    <br>
    <small>
    You can <a href="https://www.pythonmorsels.com/privacy/">find the Privacy Policy for Python Morsels here</a>.
    </small>
</form></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The problem with inheriting from dict and list in Python]]></title>
    <link href="http://treyhunner.com/2019/04/why-you-shouldnt-inherit-from-list-and-dict-in-python/"/>
    <updated>2019-04-09T07:00:00-07:00</updated>
    <id>http://treyhunner.com/2019/04/why-you-shouldnt-inherit-from-list-and-dict-in-python</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve created dozens of [Python Morsels][] since I started it last year.
At this point at least 10 of these exercises involve making a custom collection: often a dict-like, list-like or set-like class.</p>

<p>Since each Python Morsels solutions email involves a walk-through of many ways to solve the same problem, I&rsquo;ve solved each of these in many ways.</p>

<p>I&rsquo;ve solved these:</p>

<ul>
<li>manually with <code>__dunder__</code> methods</li>
<li>with the abstract base classes in [collections.abc][]</li>
<li>with [collections.UserDict][UserDict] and [collections.UserList][UserList]</li>
<li>by inheriting from <code>list</code>, <code>dict</code>, and <code>set</code> directly</li>
</ul>


<p>While creating and solving many exercises involving custom collections, I&rsquo;ve realized that inheriting from <code>list</code>, <code>dict</code>, and <code>set</code> is often subtly painful.
I&rsquo;m writing this article to explain why I often don&rsquo;t recommend inheriting from these built-in classes in Python.</p>

<p>My examples will focus on <code>dict</code> and <code>list</code> since those are likely more commonly sub-classed.</p>

<ul data-toc=".entry-content"></ul>


<h2>Making a custom dictionary</h2>

<p>We&rsquo;d like to make a dictionary that&rsquo;s bi-directional.
When a key-value pair is added, the key maps to the value but the value also maps to the key.</p>

<p>There will always be an even number of elements in this dictionary.
And if <code>d[k] == v</code> is <code>True</code> then <code>d[v] == k</code> will always be <code>True</code> also.</p>

<p>We could try to implement this by customizing deletion and setting of key-value pairs.</p>

<pre><code class="python">class TwoWayDict(dict):
    def __delitem__(self, key):
        value = super().pop(key)
        super().pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        super().__setitem__(key, value)
        super().__setitem__(value, key)
    def __repr__(self):
        return f"{type(self).__name__}({super().__repr__()})"
</code></pre>

<p>Here we&rsquo;re ensuring that:</p>

<ul>
<li>deleting keys will delete their corresponding values as well</li>
<li>whenever we set a new value for <code>k</code>, that any existing value will be removed properly</li>
<li>whenever we set a key-value pair, that the corresponding value-key pair will be set too</li>
</ul>


<p>Setting and deleting items from this bi-directional dictionary seems to work as we&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict()
&gt;&gt;&gt; d[3] = 8
&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 3})
&gt;&gt;&gt; d[7] = 6
&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 3, 7: 6, 6: 7})
</code></pre>

<p>But calling the <code>update</code> method on this dictionary leads to odd behavior:</p>

<pre><code class="python">&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 3, 7: 6, 6: 7})
&gt;&gt;&gt; d.update({9: 7, 8: 2})
&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 2, 7: 6, 6: 7, 9: 7})
</code></pre>

<p>Adding <code>9: 7</code> should have removed <code>7: 6</code> and <code>6: 7</code> and adding <code>8: 2</code> should have removed <code>3: 8</code> and <code>8: 3</code>.</p>

<p>We could fix this with a custom <code>update</code> method:</p>

<pre><code class="python">    def update(self, items):
        if isinstance(items, dict):
            items = items.items()
        for key, value in items:
            self[key] = value
</code></pre>

<p>But calling the initializer doesn&rsquo;t work either:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict({9: 7, 8: 2})
&gt;&gt;&gt; d
TwoWayDict({9: 7, 8: 2})
</code></pre>

<p>So we&rsquo;ll make a custom initializer that calls <code>update</code>:</p>

<pre><code class="python">    def __init__(self, items=()):
        self.update(items)
</code></pre>

<p>But <code>pop</code> doesn&rsquo;t work:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict()
&gt;&gt;&gt; d[9] = 7
&gt;&gt;&gt; d
TwoWayDict({9: 7, 7: 9})
&gt;&gt;&gt; d.pop(9)
7
&gt;&gt;&gt; d
TwoWayDict({7: 9}
</code></pre>

<p>And neither does <code>setdefault</code>:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict()
&gt;&gt;&gt; d.setdefault(4, 2)
2
&gt;&gt;&gt; d
TwoWayDict({4: 2})
</code></pre>

<p>The problem is the <code>pop</code> method doesn&rsquo;t actually call <code>__delitem__</code> and the <code>setdefault</code> method doesn&rsquo;t actually call <code>__setitem__</code>.</p>

<p>If we wanted to fix this problem, we have to completely re-implement <code>pop</code> and <code>setdefault</code>:</p>

<pre><code class="python">DEFAULT = object()

class TwoWayDict(dict):
    # ...
    def pop(self, key, default=DEFAULT):
        if key in self or default is DEFAULT:
            value = self[key]
            del self[key]
            return value
        else:
            return default
    def setdefault(self, key, value):
        if key not in self:
            self[key] = value
</code></pre>

<p>This is all very tedious though.
When inheriting from <code>dict</code> to create a custom dictionary, we&rsquo;d expect <code>update</code> and <code>__init__</code> would call <code>__setitem__</code> and <code>pop</code> and <code>setdefault</code> would call <code>__delitem__</code>.
But they don&rsquo;t!</p>

<p>Likewise, <code>get</code> and <code>pop</code> don&rsquo;t call <code>__getitem__</code>, as you might expect they would.</p>

<h2>Lists and sets have the same problem</h2>

<p>The <code>list</code> and <code>set</code> classes have similar problems to the <code>dict</code> class.
Let&rsquo;s take a look at an example.</p>

<p>We&rsquo;ll make a custom list that inherits from the <code>list</code> constructor and overrides the behavior of <code>__delitem__</code>, <code>__iter__</code>, and <code>__eq__</code>.
This list will customize <code>__delitem__</code> to not actually <em>delete</em> an item but to instead leave a &ldquo;hole&rdquo; where that item used to be.
The <code>__iter__</code> and <code>__eq__</code> methods will skip over this hole when comparing two <code>HoleList</code> classes as &ldquo;equal&rdquo;.</p>

<p>This class is a bit nonsensical (no it&rsquo;s not a Python Morsels exercise fortunately), but we&rsquo;re focused less on the class itself and more on the issue with inheriting from <code>list</code>:</p>

<pre><code class="python">class HoleList(list):

    HOLE = object()

    def __delitem__(self, index):
        self[index] = self.HOLE

    def __iter__(self):
        return (
            item
            for item in super().__iter__()
            if item is not self.HOLE
        )

    def __eq__(self, other):
        if isinstance(other, HoleList):
            return all(
                x == y
                for x, y in zip(self, other)
            )
        return super().__eq__(other)

    def __repr__(self):
        return f"{type(self).__name__}({super().__repr__()})"
</code></pre>

<p>Unrelated Aside: if you&rsquo;re curious about that <code>object()</code> thing, I explain why it&rsquo;s useful in [my article about sentinel values in Python][sentinel values].</p>

<p>If we make two <code>HoleList</code> objects and delete items from them such that they have the same non-hole items:</p>

<pre><code class="python">&gt;&gt;&gt; x = HoleList([2, 1, 3, 4])
&gt;&gt;&gt; y = HoleList([1, 2, 3, 5])
&gt;&gt;&gt; del x[0]
&gt;&gt;&gt; del y[1]
&gt;&gt;&gt; del x[-1]
&gt;&gt;&gt; del y[-1]
</code></pre>

<p>We&rsquo;ll see that they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; list(x), list(y)
([1, 3], [1, 3])
&gt;&gt;&gt; x
HoleList([&lt;object object at 0x7f56bdf38120&gt;, 1, 3, &lt;object object at 0x7f56bdf38120&gt;])
&gt;&gt;&gt; y
HoleList([1, &lt;object object at 0x7f56bdf38120&gt;, 3, &lt;object object at 0x7f56bdf38120&gt;])
</code></pre>

<p>But if we then ask them whether they&rsquo;re <em>not equal</em> we&rsquo;ll see that they&rsquo;re both <em>equal</em> and <em>not equal</em>:</p>

<pre><code class="python">&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x != y
True
&gt;&gt;&gt; list(x), list(y)
([1, 3], [1, 3])
&gt;&gt;&gt; x
HoleList([&lt;object object at 0x7f56bdf38120&gt;, 1, 3, &lt;object object at 0x7f56bdf38120&gt;])
&gt;&gt;&gt; y
HoleList([1, &lt;object object at 0x7f56bdf38120&gt;, 3, &lt;object object at 0x7f56bdf38120&gt;])
</code></pre>

<p>Normally in Python 3, overriding <code>__eq__</code> would customize the behavior of both equality (<code>==</code>) and inequality (<code>!=</code>) checks.
But not for <code>list</code> or <code>dict</code>: they define both <code>__eq__</code> and <code>__ne__</code> methods which means we need to override both.</p>

<pre><code class="python">    def __ne__(self, other):
        return not (self == other)
</code></pre>

<p>Dictionaries suffer from this same problem: <code>__ne__</code> exists which means we need to be careful to override both <code>__eq__</code> and <code>__ne__</code> when inheriting from them.</p>

<p>Also like dictionaries, the <code>remove</code> and <code>pop</code> methods on lists don&rsquo;t call <code>__delitem__</code>:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>y
HoleList([1, <object object at 0x7f56bdf38120>, 3, <object object at 0x7f56bdf38120>])
y.remove(1)
y
HoleList([<object object at 0x7f56bdf38120>, 3, <object object at 0x7f56bdf38120>])
y.pop(0)</p></blockquote></blockquote></blockquote>

<p><object object at 0x7f56bdf38120></p>

<blockquote><blockquote><blockquote><p>y
HoleList([3, <object object at 0x7f56bdf38120>])
```</p></blockquote></blockquote></blockquote>

<p>We could again fix these issues by re-implementing the <code>remove</code> and <code>pop</code> methods:</p>

<pre><code class="python">    def remove(self, value):
        index = self.index(value)
        del self[index]
    def pop(self, index=-1):
        value = self[index]
        del self[index]
        return value
</code></pre>

<p>But this is a pain.
And who knows whether we&rsquo;re done?</p>

<p>Every time we customize a bit of core functionality on a <code>list</code> or <code>dict</code> subclass, we&rsquo;ll need to make sure we customize other methods that also include exactly the same functionality (but which don&rsquo;t delegate to the method we overrode).</p>

<h2>Why did the Python developers do this?</h2>

<p>From my understanding, the built-in <code>list</code>, <code>dict</code>, and <code>set</code> types have in-lined a lot of code for performance.
Essentially, they&rsquo;ve copy-pasted the same code between many different functions to avoid extra function calls and make things a tiny bit faster.</p>

<p>I haven&rsquo;t found a reference online that explains why this decision was made and what the consequences of the alternatives to this choice were.
But I mostly trust that this was done for my benefit as a Python developer.
If <code>dict</code> and <code>list</code> weren&rsquo;t faster this way, why would the core developers have chosen this odd implementation?</p>

<h2>What&rsquo;s the alternative to inheriting from list and dict?</h2>

<p>So inheriting from <code>list</code> to make a custom list was painful and inheriting from <code>dict</code> to create a custom dictionary was painful.
What&rsquo;s the alternative?</p>

<p>How can we create a custom dictionary-like object that <em>doesn&rsquo;t</em> inherit from the built-in <code>dict</code>?</p>

<p>There are a few ways to create custom dictionaries:</p>

<ol>
<li>Fully embrace duck typing: figure out everything you need for your data structure to be <code>dict</code>-like and create a completely custom class (that walks and quacks like a <code>dict</code>)</li>
<li>Inherit from a helper class that&rsquo;ll point us in the right direction and tell us which methods our object needs to be <code>dict</code>-like</li>
<li>Find a more extensible re-implementation of <code>dict</code> and inherit from it instead</li>
</ol>


<p>We&rsquo;re going to skip over the first approach: reimplementing everything from scratch will take a while and Python has some helpers that&rsquo;ll make things easier.
We&rsquo;re going to take a look at those helpers, first the ones that point us in the right direction (2 above) and then the ones that act as full <code>dict</code>-replacements (3 above).</p>

<h3>Abstract base classes: they&rsquo;ll help you quack like a duck</h3>

<p>Python&rsquo;s [collections.abc][] module includes <strong>abstract base classes</strong> that can help us implement some of the common protocols (<em>interfaces</em> as Java calls them) seen in Python.</p>

<p>We&rsquo;re trying to make a dictionary-like object.
Dictionaries are <strong>mutable mappings</strong>.
A dictionary-like object is a mapping.
That word &ldquo;mapping&rdquo; comes from &ldquo;hash map&rdquo;, which is what many other programming languages call this kind of data structure.</p>

<p>So we want to make a mutable mapping.
The <code>collections.abc</code> module provides an abstract base class for that: <code>MutableMapping</code>!</p>

<p>If we inherit from this abstract base class, we&rsquo;ll see that we&rsquo;re required to implement certain methods for it to work:</p>

<pre><code class="python">&gt;&gt;&gt; from collections.abc import MutableMapping
&gt;&gt;&gt; class TwoWayDict(MutableMapping):
...     pass
...
&gt;&gt;&gt; d = TwoWayDict()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class TwoWayDict with abstract methods __delitem__, __getitem__, __iter__, __len__, __setitem__
</code></pre>

<p>The <code>MutableMapping</code> class requires us to say how getting, deleting, and setting items works, how iterating works, and how we get the length of our dictionary.
But once we do that, we&rsquo;ll get the <code>pop</code>, <code>clear</code>, <code>update</code>, and <code>setdefault</code> methods for free!</p>

<p>Here&rsquo;s a re-implementation of <code>TwoWayDict</code> using the <code>MutableMapping</code> abstract base class:</p>

<pre><code class="python">from collections.abc import MutableMapping


class TwoWayDict(MutableMapping):
    def __init__(self, data=()):
        self.mapping = {}
        self.update(data)
    def __getitem__(self, key):
        return self.mapping[key]
    def __delitem__(self, key):
        value = self[key]
        del self.mapping[key]
        self.pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        self.mapping[key] = value
        self.mapping[value] = key
    def __iter__(self):
        return iter(self.mapping)
    def __len__(self):
        return len(self.mapping)
    def __repr__(self):
        return f"{type(self).__name__}({self.mapping})"
</code></pre>

<p>Unlike <code>dict</code>, these <code>update</code> and <code>setdefault</code> methods will call our <code>__setitem__</code> method and the <code>pop</code> and <code>clear</code> methods will call our <code>__delitem__</code> method.</p>

<p>Abstract base classes might make you think we&rsquo;re leaving the wonderful land of Python duck typing behind for some sort of strongly-typed [OOP][] land.
But abstract base classes actually enhance duck typing.
<strong>Inheriting from abstract base classes helps us be better ducks</strong>.
We don&rsquo;t have to worry about whether we&rsquo;ve implemented all the behaviors that make a mutable mapping because the abstract base class will yell at us if we forgot to specify some essential behavior.</p>

<p>The <code>HoleList</code> class we made before would need to inherit from the <code>MutableSequence</code> abstract base class.
A custom set-like class would probably inherit from the <code>MutableSet</code> abstract base class.</p>

<h3>UserList/UserDict: lists and dictionaries that are actually extensible</h3>

<p>When using the collection ABCs, <code>Mapping</code>, <code>Sequence</code>, <code>Set</code> (and their mutable children) you&rsquo;ll often find yourself creating a wrapper around an existing data structure.
If you&rsquo;re implementing a dictionary-like object, using a dictionary under the hood makes things easier: the same applies for lists and sets.</p>

<p>Python actually includes two even higher level helpers for creating list-like and dictionary-like classes which <strong>wrap around <code>list</code> and <code>dict</code> objects</strong>.
These two classes live in the [collections][] module as [UserList][] and [UserDict][].</p>

<p>Here&rsquo;s a re-implementation of <code>TwoWayDict</code> that inherits from <code>UserDict</code>:</p>

<pre><code class="python">from collections import UserDict


class TwoWayDict(UserDict):
    def __delitem__(self, key):
        value = self[key]
        super().__delitem__(key)
        self.pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        super().__setitem__(key, value)
        super().__setitem__(value, key)
    def __repr__(self):
        return f"{type(self).__name__}({self.data})"
</code></pre>

<p>You may notice something interesting about the above code.</p>

<p>That code looks extremely similar to the code we originally wrote (the first version that had lots of bugs) when attempting to inherit from <code>dict</code>:</p>

<pre><code class="python">class TwoWayDict(dict):
    def __delitem__(self, key):
        value = super().pop(key)
        super().pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        super().__setitem__(key, value)
        super().__setitem__(value, key)
    def __repr__(self):
        return f"{type(self).__name__}({super().__repr__()})"
</code></pre>

<p>The <code>__setitem__</code> method is identical, but the <code>__delitem__</code> method has some small differences.</p>

<p>It might seem from these two code blocks that <code>UserDict</code> just a better <code>dict</code>.
That&rsquo;s not quite right though: <code>UserDict</code> isn&rsquo;t a <code>dict</code> replacement so much as a <code>dict</code> wrapper.</p>

<p>The <code>UserDict</code> class implements the <em>interface</em> that dictionaries are supposed to have, but it wraps around an actual <code>dict</code> object under-the-hood.</p>

<p>Here&rsquo;s another way we could have written the above <code>UserDict</code> code, without any <code>super</code> calls:</p>

<pre><code class="python">from collections import UserDict


class TwoWayDict(UserDict):
    def __delitem__(self, key):
        value = self.data.pop(key)
        self.data.pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        self.data[key] = value
        self.data[value] = key
</code></pre>

<p>Both of these methods reference <code>self.data</code>, which we didn&rsquo;t define.</p>

<p>The <code>UserDict</code> class initializer makes a dictionary which it stores in <code>self.data</code>.
All of the methods on this dictionary-like <code>UserDict</code> class wrap around this <code>self.data</code> dictionary.
<code>UserList</code> works the same way, except its <code>data</code> attribute wraps around a <code>list</code> object.
If we want to customize one of the <code>dict</code> or <code>list</code> methods of these classes, we can just override it and change what it does.</p>

<p>You can think of <code>UserDict</code> and <code>UserList</code> as <strong>wrapper classes</strong>.
When we inherit from these classes, we&rsquo;re wrapping around a <code>data</code> attribute which we proxy all our method lookups to.</p>

<p>In fancy OOP speak, we might consider <code>UserDict</code> and <code>UserList</code> to be [adapter classes][].</p>

<h3>So should I use abstract base classes or UserDict and UserList?</h3>

<p>The <code>UserList</code> and <code>UserDict</code> classes were originally created long before the abstract base classes in <code>collections.abc</code>.
<code>UserList</code> and <code>UserDict</code> have been around (in some form at least) since before Python 2.0 was even released, but the <code>collections.abc</code> abstract base classes have only been around since Python 2.6.</p>

<p>The <code>UserList</code> and <code>UserDict</code> classes are for when you want something that acts almost identically to a list or a dictionary but you want to customize just a little bit of functionality.</p>

<p>The abstract base classes in <code>collections.abc</code> are useful when you want something that&rsquo;s a <em>sequence</em> or a <em>mapping</em> but is different enough from a list or a dictionary that you really should be making your own custom class.</p>

<h2>Does inheriting from list and dict ever make sense?</h2>

<p>Inheriting from <code>list</code> and <code>dict</code> isn&rsquo;t always bad.</p>

<p>For example, here&rsquo;s a perfectly functional version of a <code>DefaultDict</code> (which acts a little differently from <code>collections.defaultdict</code>):</p>

<pre><code class="python">class DefaultDict(dict):
    def __init__(self, *args, default=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default = default
    def __missing__(self, key):
        return self.default
</code></pre>

<p>This <code>DefaultDict</code> uses the <code>__missing__</code> method to act as you&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; d = DefaultDict({'a': 8})
&gt;&gt;&gt; d['a']
8
&gt;&gt;&gt; d['b']
&gt;&gt;&gt; d
{'a': 8}
&gt;&gt;&gt; e = DefaultDict({'a': 8}, default=4)
&gt;&gt;&gt; e['a']
8
&gt;&gt;&gt; e['b']
4
&gt;&gt;&gt; e
{'a': 8}
</code></pre>

<p>There&rsquo;s no problem with inheriting from <code>dict</code> here because we&rsquo;re not overriding functionality that lives in many different places.</p>

<p>If you&rsquo;re changing functionality that&rsquo;s limited to a single method or adding your own custom method, it&rsquo;s probably worth inheriting from <code>list</code> or <code>dict</code> directly.
But if your change will require duplicating the same functionality in multiple places (as is often the case), consider reaching for one of the alternatives.</p>

<h2>When making a custom list or dictionary, remember you have options</h2>

<p>When creating your own set-like, list-like, or dictionary-like object, think carefully about how you need your object to work.</p>

<p>If you need to change some core functionality, inheriting from <code>list</code>, <code>dict</code>, or <code>set</code> will be painful and I&rsquo;d recommend against it.</p>

<p>If you&rsquo;re making a variation of <code>list</code> or <code>dict</code> and need to customize just a little bit of core functionality, consider inheriting from <code>collections.UserList</code> or <code>collections.UserDict</code>.</p>

<p>In general, if you&rsquo;re making something custom, you&rsquo;ll often want to reach for the abstract base classes in <code>collections.abc</code>.
For example if you&rsquo;re making a slightly more custom sequence or mapping (think <code>collections.deque</code>, <code>range</code>, and maybe <code>collections.Counter</code>) you&rsquo;ll want <code>MutableSequence</code> or <code>MutableMapping</code>.
And if you&rsquo;re making a custom set-like object, your only options are <code>collections.abc.Set</code> or <code>collections.abc.MutableSet</code> (there is no <code>UserSet</code>).</p>

<p>We don&rsquo;t need to create our own data structures very often in Python.
When you do need to create your own custom collections, wrapping around a data structure is a great idea.
Remember the <code>collections</code> and <code>collections.abc</code> modules when you need them!</p>

<h2>You don&rsquo;t learn by putting information into your head</h2>

<p>You don&rsquo;t learn by putting information into your head, you learn by trying to retrieve information <em>from</em> your head.
This knowledge about inheriting from <code>list</code> and <code>dict</code> and the <code>collections.abc</code> classes and <code>collections.UserList</code> and <code>collections.UserDict</code> isn&rsquo;t going to stick unless you try to apply it!</p>

<p>If you use the below form to sign up for Python Morsels, the first exercise you see when you sign up will involve creating your own custom mapping or sequence (it&rsquo;ll be a surprise which one).
After that first exercise, I&rsquo;ll send you one exercise every week for the next month.
By default they&rsquo;ll be <strong>intermediate-level</strong> exercises, though you can change your skill level after you sign up.</p>

<p><form method="post" action="https://www.pythonmorsels.com/signup/">
    <input type="email" name="email" placeholder="Your email" class="subscribe-email form-big" required>
    <input type="hidden" name="exercise_track" value="custom collection">
    <input type="hidden" name="form_id" value="inheriting from builtins">
    <button type="submit" class="subscribe-btn form-big">Get my Python Morsels exercise</button>
    <br>
    <small>
    You can <a href="https://www.pythonmorsels.com/privacy/">find the Privacy Policy for Python Morsels here</a>.
    </small>
</form></p>

<p>If you&rsquo;d rather get more beginner-friendly exercises, use the Python Morsels sign up form on the right side of this page instead.</p>

<p>[python morsels]: <a href="https://www.pythonmorsels.com/">https://www.pythonmorsels.com/</a>
[collections.abc]: <a href="https://docs.python.org/3/library/collections.abc.html">https://docs.python.org/3/library/collections.abc.html</a>
[UserDict]: <a href="https://docs.python.org/3/library/collections.html#collections.UserDict">https://docs.python.org/3/library/collections.html#collections.UserDict</a>
[UserList]: <a href="https://docs.python.org/3/library/collections.html#collections.UserList">https://docs.python.org/3/library/collections.html#collections.UserList</a>
[solid]: <a href="https://en.wikipedia.org/wiki/SOLID_">https://en.wikipedia.org/wiki/SOLID_</a>(object-oriented_design)
[oop]: <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">https://en.wikipedia.org/wiki/Object-oriented_programming</a>
[collections]: <a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>
[sentinel values]: <a href="https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/">https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/</a>
[adapter classes]: <a href="https://en.wikipedia.org/wiki/Adapter_pattern">https://en.wikipedia.org/wiki/Adapter_pattern</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making the most of the PyCon sprints]]></title>
    <link href="http://treyhunner.com/2019/04/making-the-most-of-the-pycon-sprints/"/>
    <updated>2019-04-02T09:45:00-07:00</updated>
    <id>http://treyhunner.com/2019/04/making-the-most-of-the-pycon-sprints</id>
    <content type="html"><![CDATA[<p>I wrote a blog post last year, <a href="https://treyhunner.com/2018/04/how-to-make-the-most-of-your-first-pycon/">How to have a great first PyCon</a>, in which I gave quite a few tips for <strong>making the most of your time at PyCon</strong> (if you&rsquo;re a first time PyCon attendee, <a href="https://treyhunner.com/2018/04/how-to-make-the-most-of-your-first-pycon/">go read it</a>).
One thing I didn&rsquo;t mention <em>at all</em> in that article on PyCon was <a href="https://us.pycon.org/2019/community/sprints/">the sprints</a>.</p>

<p>I didn&rsquo;t mention the sprints not because I don&rsquo;t like them (I actually love the sprints and I usually attend at least the first two days of sprints every year), but because <strong>first-time PyCon attendees often don&rsquo;t stay for the sprints</strong>.
This is partly because the sprints can be very intimidating for first-time PyCon attendees.
The fear that <strong>the sprints aren&rsquo;t for me</strong> is a very real one.</p>

<p>This year PyCon has multiple options to help you have a successful sprint, including their annual &ldquo;Introduction to Sprinting Workshop&rdquo; on Sunday and, brand-new this year, the <a href="https://us.pycon.org/2019/hatchery/mentoredsprints/">mentored sprints</a> a hatchery track for underrepresented beginners.
The applications for the mentored sprints have closed for PyCon 2019, but that&rsquo;s something to keep an eye on for future PyCons.</p>

<p>In this post I&rsquo;m going to share some advice for <strong>how to get the most out of the PyCon sprints</strong> and I hope to <strong>address the fears that folks often feel</strong>. I&rsquo;m hoping this post might encourage you to add an extra day or two to your PyCon trip and give the sprints a try.</p>

<p>The sprints are a very different experience from the talk days at PyCon and <strong>they&rsquo;re hard to compare to the rest of PyCon</strong>.
Some people like the talks better, but I&rsquo;ve also talked to first time sprinters who said <strong>the sprints were their favorite part of the conference</strong>.</p>

<p>In this post I&rsquo;m going to share some advice for <strong>how to get the most out of the PyCon sprints</strong>.
I&rsquo;m hoping this post might encourage you to add an extra day or two to your PyCon trip and give the sprints a try.</p>

<ol data-toc=".entry-content"></ol>


<h2>Your fears going into the sprints</h2>

<p>We&rsquo;re going to start by addressing some common concerns.
I&rsquo;ve heard these concerns from folks I&rsquo;ve encouraged to stay for the sprints and from folks I&rsquo;ve interviewed about their advice for first-time sprinters.</p>

<h3>I&rsquo;m not experienced enough</h3>

<p>I&rsquo;ve <strong>never contributed to an open source project before</strong> and I don&rsquo;t really know what to do.
I&rsquo;m a <strong>junior programmer</strong> and I&rsquo;m afraid I&rsquo;m not experienced enough.
I <strong>don&rsquo;t write code for a living</strong> and I&rsquo;m afraid I won&rsquo;t be able to get anything done because I don&rsquo;t know how to <em>do</em> much yet.</p>

<p>The sprints are a great place for a first-time open source contributor.
Making a contribution to an open source project <strong>while sitting next to the maintainer</strong> is a unique experience.
If you contribute to open source at home or at work, you&rsquo;re unlikely to have a project maintainer nearby.</p>

<p>If you&rsquo;re a junior programmer or you don&rsquo;t code for a living <strong>you might be afraid of your inexperience</strong>: maybe you&rsquo;re pretty new to coding in general and you don&rsquo;t understand git, testing, version control, and GitHub.
But there&rsquo;s very likely a project for <em>you</em> to contribute to.
The sprints include sprint coordinators who can help <strong>point you to projects they&rsquo;ve heard are particularly beginner-friendly</strong> or who have quite a bit of <strong>low-hanging fruit in their issue tracker for newcomers to dig into</strong> (something as simple as updating the on-boarding documentation can be a great benefit to maintainers).</p>

<h3>It&rsquo;ll be too fast-paced for me</h3>

<p>You might think the sprints involve smart people coding for many hours on end, racing against the clock.
This is false.
From my experience, sprints usually aren&rsquo;t like that at all.</p>

<p>There are some very smart people at the sprints, but there are a lot of newcomers too.
Everyone at the sprints is new to <em>something</em> and most of us are <a href="https://youtu.be/hIJdFxYlEKE?t=333">mediocre programmers</a> (who are more skilled in some areas and less skilled in others).</p>

<p>The &ldquo;pace&rdquo; of the sprints is really up to you.
The name &ldquo;sprints&rdquo; is kind of a misnomer: <strong>I never find myself <em>sprinting</em> while at the sprints</strong>.</p>

<p>I&rsquo;ve attended at least one day of sprints at PyCon US for each of the last 5 years and my sprint experience has almost always consisted of:</p>

<ul>
<li>Some <strong>high level conversation</strong> about an intriguing feature, topic, or idea</li>
<li>Some <strong>low level conversation</strong> about how pieces of a project work (conversations about the inner-workings of a project are so much easier to have in-person)</li>
<li>Some <strong>writing time</strong>.  Sometimes this is writing code.  Sometimes this is writing text copy for documentation or marketing material.  Sometimes it&rsquo;s my own writing time for a talk or article I&rsquo;m working on.</li>
<li>Some <strong>rubber duck time</strong>.  I often wander around asking people what they&rsquo;re working on and sometimes act as their <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber duck</a>.  I also often wander around seeking my own rubber duck if I get stuck on a particular topic or idea (whether on my own personal project or an open source project I&rsquo;m contributing to).</li>
<li>Plenty of <strong>personal break time</strong>.  I very often take mental breaks during the sprints to wander the halls, often aimlessly.  Breaks feel great, but they also often help my subconscious work on a task for a bit while my conscious mind rests.</li>
</ul>


<p>Sprints are what you make them: some people prefer many hours of furious coding with their earbuds in most of the day but many people prefer something that looks a bit more like <strong>coworking with new friends in a coffee shop</strong>. Sprints are an intense experience for some people, but they don&rsquo;t have to be intense for you.</p>

<p>My sprints are often more relaxed than the conference and many of the best conversations I have during PyCon come out of the sprints.</p>

<h3>I won&rsquo;t be able to get enough done while I&rsquo;m there</h3>

<p>If you&rsquo;re only planning to be at the sprints for one day, <strong>can you really expect to get up to speed quickly enough to accomplish something meaningful</strong>?</p>

<p>This fear is very real for all sprint attendees.</p>

<p>If you&rsquo;re just getting started on contributing to a new (to you) code base, <strong>you may not be able to submit a viable change (often in the form of a pull request) by the end of the day</strong>.</p>

<p>This fear is about framing: <strong>what is your goal at the sprints</strong>?</p>

<p>If your goal is to get a pull request merged into an open source project by the end of the day, try to find something minor that needs fixing in the documentation, website styling, or something else that the project maintainer agrees needs fixing.
It&rsquo;s much easier to <strong>get a minor change merged</strong> if you get an early start and pick a small issue.</p>

<p>But if your goal is to make a more substantial improvement to a project, then you probably won&rsquo;t get much code merged (if any) by the end of the day.
For bigger changes, you&rsquo;ll likely <strong>start your work at the sprints and continue it at home</strong>, often with help from the project maintainers (via comments on pull request and/or emails).</p>

<h2>What to expect from the sprints</h2>

<p>What can you really expect while attending the sprints?
What is sprinting really like?</p>

<h3>Some projects are easier to sprint on than others</h3>

<p>Different projects sprint in different ways.
Many projects <strong>go out of their way to welcome contributions from newcomers</strong>, some projects may struggle a little in welcoming newcomers, and a few projects might hold a sprint that&rsquo;s focused entirely on engaging existing contributors since they might not meet to work in-person often (but you&rsquo;re unlikely to stumble upon those).</p>

<p>If you&rsquo;re not sure what project you&rsquo;d like to sprint on during first day at the sprints, <strong>I recommend picking a project to sprint on that seems particularly newcomer friendly</strong>.
The <a href="https://us.pycon.org/2019/community/sprints/">Pycon Sprints page</a> has several projects that will be sprinting and after the conference ends on Sunday evening you&rsquo;ll get a chance to hear many of the sprinting projects come on stage and tell you who they are and how you can help.
Alternatively (or additionally), if you&rsquo;ve identified a project that particularly suits your interests, <strong>talk to the maintainers</strong> and see if they think (and you think) their project would be a good fit for you.</p>

<p>Keep in mind that <strong>newer projects and smaller projects often have more to be done</strong>.
It can be quite challenging to find issues that need fixing in big and stable projects like CPython and Django, but newer or smaller projects often need more help.</p>

<p>It&rsquo;s also usually more fun to be <strong>a big fish in a small pond</strong> rather than a small fish in a big pond.
It might take you the same amount of effort to make a small improvement to a big project as it takes to make a big change to a small project.</p>

<h3>The maintainers are there to help you</h3>

<p>During the sprints, project maintainers are there to help you.
Project maintainers can quietly write code at home, but it&rsquo;s hard for them to encourage <em>you</em> to quietly write code at home.
So <strong>many project maintainers consider it their primary responsibility to help you contribute to their project during the sprints</strong>.</p>

<p>The maintainers of projects are usually focused on <strong>enabling your contributions during the sprints</strong> because they want your help.
If you contribute to a project during the sprints, it&rsquo;s more likely you&rsquo;ll decide to contribute to the project again <em>after</em> the sprints.
That would be great for the maintainers (they&rsquo;re getting your help) and might be quite fun for you too.</p>

<p>You might be thinking &ldquo;surely, the maintainers can&rsquo;t be there entirely to help me&rdquo;.
And you&rsquo;re right: a number of maintainers do contribute code to their own projects during the sprints.
Generally the amount of code maintainers commit to their projects increases as the sprints stretch on.
There are far fewer people on the third and fourth days of sprints than on the first and second days.
If a maintainer stays for all four days of the sprints, they&rsquo;re much more likely to commit code to their own project as the number of sprinters working on their project dwindles and as those still working start to need a bit less help than they did on the first day.
<strong>During the first couple days of the sprints, most maintainers are there primarily to help you</strong>.</p>

<h3>The sprints can be more relaxing than the talks</h3>

<p>The talk days of PyCon can be pretty overwhelming.
<strong>The sprints are a bit more structured</strong> (in a sort of odd semi-structured way) because everyone at the sprints is working on something together (or at least they&rsquo;re working on something <em>and</em> they&rsquo;re together).</p>

<p>The sprints are <strong>sort of like an introvert party</strong>: everyone is sitting at tables next to each other, sometimes talking and sometimes working quietly, but always sitting next to other humans without the need to constantly talk and interact.
And even if you&rsquo;re <em>not</em> working on the same thing as someone else, <strong>you&rsquo;re still a PyCon person in a room with other PyCon people, doing whatever it is you&rsquo;re all doing</strong>.</p>

<p>For some people the sprints really are a sprint, but for most of us <strong>the sprints are more like an endurance run</strong>, one with <em>plenty</em> of breaks.</p>

<h3>Contributing at the sprints is often easier than online</h3>

<p><strong>Contributing to open source projects at the sprints is usually easier than contributing online</strong>.
The ease of in-person communication often makes the experience less intimidating.</p>

<p>It&rsquo;s easier to express oneself and empathize during face-to-face communication than over text-based communication.
Emoji are great, but they&rsquo;re not a substitute for body language and tone of voice.</p>

<p>It feels less awkward to chat with a project maintainer about your goals and your skill level in-person than via a GitHub pull request.</p>

<p>Little bits of seemingly meaningless conversation happen while folks sit next to each other for hours: conversation about weather, hobbies, what we thought of our lunch, pop culture, and whatever else comes up.
That kind of natural conversation brings people closer together and makes us feel more comfortable communicating later, whether in-person or online.</p>

<p>Continued communication online is also often easier <em>after</em> face-to-face communication.
After you&rsquo;ve met a project maintainer in-person, you&rsquo;ll likely find communicating online via their issue tracker less intimidating because <strong>you and the maintainer already know each other</strong>.</p>

<p>The in-person nature of the sprints makes them a uniquely favorable place for your first open source contribution.</p>

<h2>How to get the most out of the sprints</h2>

<p>The sprints are a unique experience that <em>might</em> give you a greater sense of community, purpose, and belonging than the (often not quite as communal) talk days of the conference.</p>

<p>What steps can you take to increase the likelihood that you&rsquo;ll have a wonderful time at the PyCon sprints?</p>

<h3>Don&rsquo;t underestimate your skills</h3>

<p>If you&rsquo;re trying to get a feel for what project might be a good fit for you, let the maintainers know what skills you do and don&rsquo;t have and <strong>see if you get a good vibe</strong> from both the maintainers and the project.
If you do, run with it!</p>

<p>If you&rsquo;re afraid you won&rsquo;t have something to contribute, remember that, like businesses, <strong>open source projects have a wide variety of needs</strong>.</p>

<p>If you know something about marketing, you can offer to sit with project maintainers and <strong>help them improve their marketing materials</strong>.
At PyCon 2016 I interviewed some project maintainers and then crafted slogans and wrote marketing copy that explained what problem their project solved and who needed it.
I feel those were some of the most valuable contributions I made in a pretty short amount of time.</p>

<p>If you&rsquo;re pretty good at design, you could offer to <strong>create visuals for projects</strong> (maybe logos, diagrams, or other visualizations).</p>

<p>If you know CSS or JavaScript, you could find <strong>a web-based project that needs help with their front-end</strong>.
Being the &ldquo;front-end dev among Pythonistas&rdquo; or the &ldquo;UX person among developers&rdquo; can really help you make uniquely helpful contributions to projects.</p>

<p>Also keep in mind that there are often small projects that you can make big contributions to at the sprints simply because they&rsquo;re in great need.
Sometimes people even start a project <em>at the sprints</em> because it&rsquo;s easier to get help from others when <strong>you&rsquo;re in a room full of folks who might know a few things about the technology you&rsquo;re using</strong>.
If you join a newer or smaller project at the sprints (or start your own), you&rsquo;ll often be able to find a whole bunch of low-hanging fruit that hasn&rsquo;t been taken care of only because no one has had the time to work on it yet.</p>

<h3>Attend the intro to the sprints the night before</h3>

<p>Some maintainers list their projects on the <a href="https://us.pycon.org/2019/community/sprints/">PyCon sprints page</a> to note that they&rsquo;ll be attending the sprints.
Some maintainers simply announce their project during <strong>the sprint pitches after</strong> the main conference closing, on the last day of talks (Sunday).
If you are looking for a project, stick around after the last talk of the day and dozens of maintainers will walk up on the big stage to give an elevator pitch for the project they&rsquo;re sprinting on, with each pitch taking about a minute.</p>

<p>During the sprint pitches, each maintainer will talk about what their project is, what kind of help they&rsquo;re most in need of (fitting as much as they can in the very few seconds they have) and generally close with some commentary on whether their project is a good fit for newcomers.
You don&rsquo;t have to attend the sprint pitches, but doing so will increase your chances of hearing about <strong>a project that you&rsquo;d actually really like to work on</strong>.</p>

<p>Another thing to pay attention to on the last day of talks is the hands-on <strong>Introduction to Sprinting tutorial</strong> on Sunday evening.
The Intro to Sprinting tutorial is open to walk-ins (first-come, first-served) and is purposely held after the main conference closing so you won&rsquo;t need to miss any talks.</p>

<p>Last year the Intro to Sprinting tutorial room filled up pretty quickly, so rest assured you won&rsquo;t be alone.
Definitely try to get the Intro to Sprinting workshop on your calendar (once the room and time are announced) and show up on-time if you can.</p>

<h3>Try to prepare yourself for the setup time</h3>

<p>Getting started on a new project can take a lot of time, so try to prepare yourself and your development environment as much as you can early on.</p>

<p>Make sure you have git, GitHub, a code editor, and a modern version (maybe multiple versions) of Python installed on your machine.</p>

<p><strong>Get an early start if possible</strong>.
The setup process can take a long time for some projects. Many projects will have a documentation page set up with instructions on what to install and how to install it. But be aware&hellip; sometimes the setup process is a little buggy and <strong>the first pull request you make to a project may be related to improving the setup instructions</strong>.</p>

<p>If you show up to sprints early, you might be able to pick a project and get that project setup on your machine before break time.
If you&rsquo;re feeling extra ambitious, <strong>you could even get a head start and prepare your machine the night before the sprints</strong>.
I&rsquo;ve never done this because I&rsquo;m rarely feeling ambitious, but I know some folks do this to make sure they can get in a little more quality sprinting time on the first day.</p>

<p>Another way to prepare yourself for setup time is to stay longer.
If you&rsquo;re staying for 2 or 3 days of sprints, you can take it easy and spend more time on setup and getting your footing during the first day.
That way you&rsquo;ll feel <strong>more confident and more independent on the second day</strong>.
If you stay more than one day, you might also get the opportunity to <strong>sprint on two different projects</strong> if you decide you&rsquo;d like to switch projects on day 2 (or even mid-day if you&rsquo;d like).</p>

<p>Oh and another way to prepare yourself: remember your laptop and your laptop charger (and if you&rsquo;re from outside the US, a power adapter if needed).</p>

<h3>Ask for help</h3>

<p>If the maintainer of the project your sprinting on is in the room they&rsquo;re likely there because <strong>they want to help you contribute to their project</strong>.
On day 1 of sprints, project maintainers tend to prioritize helping you, over writing their own code.
<strong>Please don&rsquo;t forget to ask for help when you need it</strong>.</p>

<p>Also if you&rsquo;re stuck on laptop setup issues, the PyCon sprint coordinators will be hosting <strong>a help desk during the first day of sprints</strong> (on Monday).
The help desk is a great place to get yourself unstuck when you have a general issue that could use another set of eyes.</p>

<p>If you&rsquo;re at the sprints to learn, you do want to struggle <em>some</em>.
Struggling is a great way to learn, but don&rsquo;t let yourself flounder for too long on issues that aren&rsquo;t your area of expertise.
If you get stuck, attempt to fix your problem by trial-and-error and Googling, talk to your neighbor or your <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber duck</a> and <strong>after you&rsquo;ve given yourself some time to troubleshoot, ask for help</strong>!</p>

<h3>Plan to follow-through when home (if you&rsquo;d like)</h3>

<p>Keep in mind that you may not complete your work at the sprints.
You&rsquo;re likely to find yourself <strong>still in the middle of a pull request back-and-forth at the end of your sprints</strong>.
Pull requests often require more work before merging.
Expect to get started at the sprints, but not necessarily to finish while you&rsquo;re there.</p>

<p>If you plan to complete your pull request at home, <strong>ask the project maintainer what form of remote communication would be best for questions you have regarding contributions</strong>.</p>

<h3>Empathize with others</h3>

<p>Your project maintainer may not show up early on day 1 and they might even leave early, depending on what their plans and schedule look like.
If they&rsquo;re at the Sunday night pitches or if you interact with them during PyCon, you might consider asking them when they plan to be present and how they plan to operate (will they be writing code or helping others write code or both).</p>

<p>When sprinting, try to empathize with your project maintainer.
Empathy is challenging during remote open source contributions, but it can be a struggle even for in-person contributions.</p>

<p>Consider what your project maintainer&rsquo;s motivations likely are and remember that they&rsquo;re often trying to balance <strong>getting many new contributors to their project</strong>, <strong>getting bugs fixed</strong>, and <strong>maintaining the quality and consistency of their code base</strong>.
Balancing multiple goals which sometimes compete with each other can be a challenge.</p>

<p>Text-based communication is hard, so <strong>seize your face-to-face communication while you&rsquo;re at the sprints</strong> and try to get a sense for how your project maintainer thinks.
If you do decide to contribute more after the sprints are over, <strong>that in-person empathy can help you continue to empathize remotely as well</strong>.</p>

<p>Some other places you may want to use empathy: empathizing with users of your code/documentation/design (someone is going to use your work) and the other sprinters in the room with you.
It&rsquo;s nice to congratulate your fellow sprinters when they get their code working or if they get a pull request accepted.</p>

<p>If you bring snacks, candy, donuts, or a small power strip to expand one power strip port into multiple, <strong>your kindness might give you happy neighbors at the sprints</strong>.</p>

<h3>Be kind to yourself</h3>

<p>Don&rsquo;t go into the sprints with a very specific thing that you absolutely must do: have a goal but <strong>allow yourself to change your goal</strong> as you learn new information about your environment.
<strong>Be flexible and be forgiving with yourself</strong>.</p>

<p>You&rsquo;re allowed to <strong>switch projects</strong> at any time, as often as you like, and for any reason you like (i.e. the project isn&rsquo;t as interesting as you hoped, the onboarding process isn&rsquo;t as smooth as you expected, or the project isn&rsquo;t a good fit for you).
If you need to switch projects, don&rsquo;t feel you need to offer elaborate explanations.</p>

<p>You&rsquo;re allowed to <strong>stop sprinting</strong> at any time and <strong>take a break</strong>.
You aren&rsquo;t obligated to follow through on a pull request you opened (it&rsquo;d be lovely if you did, but you don&rsquo;t <em>have</em> to).</p>

<p>Time-wise, there&rsquo;s lots of flexibility at the sprints.
The maintainer of the project you&rsquo;re sprinting on might get an early start or they might not show up until later on the first day of sprints.
You need to give yourself flexibility as well.</p>

<p>Don&rsquo;t feel obligated at the sprints: you don&rsquo;t have to make a code change, <strong>you don&rsquo;t have to be productive</strong>, you don&rsquo;t have to show up at a certain time or stay for a certain amount of time, and <strong>you don&rsquo;t even have to sprint on an open source project</strong> (I frequently don&rsquo;t).</p>

<p>If you&rsquo;d like to take half of a sprint day to explore the city you&rsquo;re in with a new friend (or on your own because you need personal time), go for it!</p>

<p>Embrace self-care at the sprints, whatever that means for you.</p>

<h3>Remember that sprints are lots of things to lots of people</h3>

<p>During my first PyCon sprint in 2014, I helped a project figure out how to migrate from Python 2 to Python 3.
The project maintainer wasn&rsquo;t looking forward to that migration so they were grateful to have another brain troubleshooting with them.</p>

<p>But during that sprint I also got an idea for a contribution to another project (Django), was encouraged to pursue the idea, and <a href="https://github.com/django/deps/pull/4">a few weeks after the sprints</a> I proposed the idea publicly.
After my suggestion sat without feedback, I sort of abandoned it.</p>

<p>But at the PyCon 2015 sprints the next year, I brought up my abandoned idea to a Django core developer and they offered to shepherd my change through, so I <a href="https://github.com/django/deps/pull/13">continued my efforts</a> during the sprints.
A couple weeks after the sprints ended I <a href="https://github.com/django/deps/pull/14">finished up the idea at home</a> and finally <a href="https://github.com/django/django/pull/4573">implemented the changes</a>, which were eventually merged (after <a href="https://github.com/django/deps/pull/15/files">some scope tweaks</a>).</p>

<p>My first two years of PyCon sprints involved some substantial code contributions that I hadn&rsquo;t expected to make.
Most of the changes I made were <strong>started at the sprints but finished at home</strong>.</p>

<p>The sprints were a source of idea generation and inspiration, not a place to get lots of work done.
Since 2015 I&rsquo;ve started sprinting on <em>ideas</em> more than code.</p>

<p>During my PyCon 2016 sprints I helped a few open source projects improve their marketing copy (so someone hitting their website would better understand what their project did and who it was for).
My pull requests during these sprints were text-based changes, not code changes.</p>

<p>My PyCon 2017 sprints involved a lot of community work: discussions with folks about the PSF and the new Code of Conduct working group.
I spent much more time in Google Docs tweaking documents than I did using git.</p>

<p>My sprints at PyCon 2018 involved writing talk proposals, meeting with new friends, and chatting with core developers about the soon-to-be-written <a href="https://www.python.org/dev/peps/pep-0582/">PEP 582</a>.
I don&rsquo;t think I made any contributions to open source projects (outside of possibly inspiring a bullet point or two in that PEP).
But I had a great time and sitting quietly in the sprint rooms helped me get a lot of work done on my talk proposals.</p>

<p><strong>The sprints aren&rsquo;t one thing</strong>.
If you&rsquo;re not feeling like a code contribution is the thing you&rsquo;d like to do during the sprints, get creative!
<strong>Your time at the sprints can be spent however you&rsquo;d like it to be</strong>.</p>

<h2>Running your own sprint</h2>

<p>This could be a whole article on its own, but I want to give a few quick tips for folks who might be attempting to run a sprint for their own project.</p>

<p>While I&rsquo;ve maintained open source projects remotely, I haven&rsquo;t run an in-person sprint on my own projects.
So my tips on running a sprint on your own project come from the perspective of a contributor and a floating helper for maintainers who needed an extra hand.</p>

<p>As a project maintainer on day 1 of sprints, <strong>I&rsquo;d consider your primary responsibility to be one of helping encourage other contributors</strong>.
You want to help folks get their environment setup, help folks identify good issues to work on, help folks with their code contributions, and even help other contributors as they help out their neighbors.</p>

<p><strong>Your job often isn&rsquo;t to write code</strong>, it&rsquo;s to be <em>interrupted</em> by people who are trying to make contributions but need your help.</p>

<p>For the in-person, in-the-moment part of running a sprint I have <a href="http://trey.io/pycascades2019">a whole talk and a bunch of related resources</a> for folks who are coaching others in-person.
But your job doesn&rsquo;t start <em>at the sprints</em>.
Ideally, you&rsquo;ll want to <strong>prepare your project for the sprints</strong> a while before the sprints even start.</p>

<p>Many projects use issue labels to indicate <strong>issues which are specifically good for first-time contributors</strong> (something like &ldquo;newcomer&rdquo;, &ldquo;good first issue&rdquo;, &ldquo;first-timers only&rdquo;, etc.).
I&rsquo;d recommend looking at <a href="https://github.com/MunGell/awesome-for-beginners#python">the many other contributor-friendly projects</a>, studying what they do, and figuring out <strong>how you can make your project more friendly to new sprinters</strong>.</p>

<p>The PyCon sprints page also recommends this <a href="https://opensourceevents.github.io/">in-person events handbook</a> made by the OpenHatch folks.
Take a look at it!
And if you can, <strong>ask questions of other project maintainers you admire who will also be sprinting</strong>: how do they ensure newcomers feel appreciated, how do they help folks feel accomplished, what do they do to get their project and their minds ready?</p>

<h2>Take note of the key events</h2>

<p>Put the events you&rsquo;ll be attending for the PyCon 2019 sprints in your calendar!</p>

<p>The sprint pitches are on the last talk day at PyCon, just after the closing of the main conference.
The Intro to Sprints tutorial usually starts just after that.
And during the first day of sprints the next day, the sprint help desk will be available to help you get some extra help on day 1.</p>

<p>Also remember the mentored sprints (if you&rsquo;ve gone through the application process already) which are designed for underrepresented groups and are on Saturday during the talks.</p>

<h2>Ask others what they think of the sprints</h2>

<p>Much of the above advice was borrowed or enhanced by wisdom from others.
I&rsquo;ve held interviews with folks during the last few PyCon sprints, I&rsquo;ve asked folks online what they think of the sprints, and I&rsquo;ve chatted with first-time sprinters about what their concerns were going into the sprints.
If you shared your sprint experiences with me in the past, thank you.</p>

<p>If you&rsquo;re still uncertain about whether you should attend a sprint, please talk to others about what they think of the PyCon sprints.
I&rsquo;ve found that most PyCon attendees are more than happy to talk about their perspective on the various parts of the conference they&rsquo;ve partaken in.</p>

<p>If you can&rsquo;t afford to stay for the sprints, I completely understand.
Most PyCon attendees will not be staying for the sprints.
But if you&rsquo;re lucky enough to have the time and resources to stay, I&rsquo;d suggest giving it a try.</p>

<p>If you can afford to schedule some extra time to attend a day or two of sprints and then decide that the sprints aren&rsquo;t for you, that time could always be spent exploring the city you&rsquo;re in, working, or doing something else that makes you feel whole.</p>

<p>And if you&rsquo;re from an underrepresented or marginalized group in tech and you&rsquo;re new to sprinting, consider applying for the <a href="https://us.pycon.org/2019/hatchery/mentoredsprints/">mentored sprints</a> for PyCon 2020.</p>

<p>Whatever you decide, have a lovely PyCon! </p>

<p>Thanks to Asheesh Laroia for encouraging this post and Chalmer Lowe for quite a bit of helpful feedback while I was writing it.
Thanks also to the many folks who sent me ideas and shared their perspective and advice about the sprints.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Overusing list comprehensions and generator expressions in Python]]></title>
    <link href="http://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python/"/>
    <updated>2019-03-26T13:30:00-07:00</updated>
    <id>http://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python</id>
    <content type="html"><![CDATA[<p>List comprehensions are one of my favorite features in Python.
I love list comprehensions so much that I&rsquo;ve written an <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">article</a> about them, done <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">a talk</a> about them, and held a <a href="https://youtu.be/_6U1XoxyyBY" title="Using List Comprehensions and Generator Expressions For Data Processing">3 hour comprehensions tutorial</a> at PyCon 2018.</p>

<p>While I love list comprehensions, I&rsquo;ve found that once new Pythonistas start to really appreciate comprehensions they tend to use them everywhere.
<strong>Comprehensions are lovely, but they can easily be overused</strong>!</p>

<p>This article is all about cases when comprehensions aren&rsquo;t the best tool for the job, at least in terms of readability.
We&rsquo;re going to walk through a number of cases where there&rsquo;s a more readable alternative to comprehensions and we&rsquo;ll also see some not-so-obvious cases where comprehensions aren&rsquo;t needed at all.</p>

<p>This article isn&rsquo;t meant to scare you off from comprehensions if you&rsquo;re not already a fan; it&rsquo;s meant to encourage moderation for those of us (myself included) who need it.</p>

<p><strong>Note</strong>: In this article, I&rsquo;ll be using the term &ldquo;comprehension&rdquo; to refer to all forms of comprehensions (list, set, dict) as well as generator expressions.
If you&rsquo;re unfamiliar with comprehensions, I recommend reading <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">this article</a> or watching <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">this talk</a> (the talk dives into generator expressions a bit more deeply).</p>

<ul data-toc=".entry-content"></ul>


<h2>Writing comprehensions with poor spacing</h2>

<p>Critics of list comprehensions often say they&rsquo;re hard to read.
And they&rsquo;re right, many comprehensions <em>are</em> hard to read.
<strong>Sometimes all a comprehension needs to be more readable is better spacing</strong>.</p>

<p>Take the comprehension in this function:</p>

<pre><code class="python">def get_factors(dividend):
    """Return a list of all factors of the given number."""
    return [n for n in range(1, dividend+1) if dividend % n == 0]
</code></pre>

<p>We could make that comprehension more readable by adding some well-placed line breaks:</p>

<pre><code class="python">def get_factors(dividend):
    """Return a list of all factors of the given number."""
    return [
        n
        for n in range(1, dividend+1)
        if dividend % n == 0
    ]
</code></pre>

<p>Less code can mean more readable code, but not always.
<strong>Whitespace is your friend, especially when you&rsquo;re writing comprehensions</strong>.</p>

<p>In general, I prefer to write most of my comprehensions <strong>spaced out over multiple lines of code</strong> using the indentation style above.
I do write one-line comprehensions sometimes, but I don&rsquo;t default to them.</p>

<h2>Writing ugly comprehensions</h2>

<p>Some loops technically <em>can</em> be written as comprehensions but they have so much logic in them they probably <em>shouldn&rsquo;t</em> be.</p>

<p>Take this comprehension:</p>

<pre><code class="python">fizzbuzz = [
    f'fizzbuzz {n}' if n % 3 == 0 and n % 5 == 0
    else f'fizz {n}' if n % 3 == 0
    else f'buzz {n}' if n % 5 == 0
    else n
    for n in range(100)
]
</code></pre>

<p>This comprehension is equivalent to this <code>for</code> loop:</p>

<pre><code class="python">fizzbuzz = []
for n in range(100):
    fizzbuzz.append(
        f'fizzbuzz {n}' if n % 3 == 0 and n % 5 == 0
        else f'fizz {n}' if n % 3 == 0
        else f'buzz {n}' if n % 5 == 0
        else n
    )
</code></pre>

<p>Both the comprehension and the <code>for</code> loop use three nested <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator">inline if statements</a> (Python&rsquo;s <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a>).</p>

<p>Here&rsquo;s a more readable way to write this code, using an <code>if-elif-else</code> construct:</p>

<pre><code class="python">fizzbuzz = []
for n in range(100):
    if n % 3 == 0 and n % 5 == 0:
        fizzbuzz.append(f'fizzbuzz {n}')
    elif n % 3 == 0:
        fizzbuzz.append(f'fizz {n}')
    elif n % 5 == 0:
        fizzbuzz.append(f'buzz {n}')
    else:
        fizzbuzz.append(n)
</code></pre>

<p>Just because there <em>is</em> a way to write your code as a comprehension, <strong>that doesn&rsquo;t mean that you <em>should</em> write your code as a comprehension</strong>.</p>

<p>Be careful using any amount of complex logic in comprehensions, even a single <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator">inline if</a>:</p>

<pre><code class="python">number_things = [
    n // 2 if n % 2 == 0 else n * 3
    for n in numbers
]
</code></pre>

<p>If you really prefer to use a comprehension in cases like this, at least give some thought to <strong>whether whitespace or parenthesis could make things more readable</strong>:</p>

<pre><code class="python">number_things = [
    (n // 2 if n % 2 == 0 else n * 3)
    for n in numbers
]
</code></pre>

<p>And consider whether breaking some of your logic out into a separate function might improve readability as well (it may not in this somewhat silly example).</p>

<pre><code class="python">number_things = [
    even_odd_number_switch(n)
    for n in numbers
]
</code></pre>

<p>Whether a separate function makes things more readable will depend on how important that operation is, how large it is, and how well the function name conveys the operation.</p>

<h2>Loops disguised as comprehensions</h2>

<p>Sometimes you&rsquo;ll encounter code that uses a comprehension syntax but breaks the spirit of what comprehensions are used for.</p>

<p>For example, this code looks like a comprehension:</p>

<pre><code class="python">[print(n) for n in range(1, 11)]
</code></pre>

<p>But it doesn&rsquo;t <em>act</em> like a comprehension.
We&rsquo;re using a comprehension for a purpose it wasn&rsquo;t intended for.</p>

<p>If we execute this comprehension in the Python shell you&rsquo;ll see what I mean:</p>

<pre><code class="python">&gt;&gt;&gt; [print(n) for n in range(1, 11)]
1
2
3
4
5
6
7
8
9
10
[None, None, None, None, None, None, None, None, None, None]
</code></pre>

<p>We wanted to print out all the numbers from 1 to 10 and that&rsquo;s what we did.
But this comprehension statement also returned a list of <code>None</code> values to us, which we promptly discarded.</p>

<p><strong>Comprehensions build up lists: that&rsquo;s what they&rsquo;re for</strong>.
We built up a list of the return values from the <code>print</code> function and the <code>print</code> function returns <code>None</code>.</p>

<p>But we didn&rsquo;t care about the list our comprehension built up: we only cared about its side effect.</p>

<p>We could have instead written that code like this:</p>

<pre><code class="python">for n in range(1, 11):
    print(n)
</code></pre>

<p>List comprehensions are for <strong>looping over an iterable and building up new lists</strong>, while <code>for</code> loops are for <strong>looping over an iterable to do pretty much any operation you&rsquo;d like</strong>.</p>

<p>When I see a list comprehension in code <strong>I immediately assume that we&rsquo;re building up a new list</strong> (because that&rsquo;s what they&rsquo;re for).
If you use a comprehension for <strong>a purpose outside of building up a new list</strong>, it&rsquo;ll confuse others who read your code.</p>

<p>If you don&rsquo;t care about building up a new list, don&rsquo;t use a comprehension.</p>

<h2>Using comprehensions when a more specific tool exists</h2>

<p>For many problems, a more specific tool makes more sense than a general purpose <code>for</code> loop.
<strong>But comprehensions aren&rsquo;t always the best special-purpose tool for the job at hand.</strong></p>

<p>I have both seen and written quite a bit of code that looks like this:</p>

<pre><code class="python">import csv

with open('populations.csv') as csv_file:
    lines = [
        row
        for row in csv.reader(csv_file)
    ]
</code></pre>

<p>That comprehension is sort of an <em>identity</em> comprehension.
Its only purpose is to loop over the given iterable (<code>csv.reader(csv_file)</code>) and create a list out of it.</p>

<p>But in Python, we have a more specialized tool for this task: the <code>list</code> constructor.
Python&rsquo;s <code>list</code> constructor can do all the looping and list creation work for us:</p>

<pre><code class="python">import csv

with open('populations.csv') as csv_file:
    lines = list(csv.reader(csv_file))
</code></pre>

<p>Comprehensions are a special-purpose tool for looping over an iterable to build up a new list while modifying each element along the way and/or filtering elements down.
The <code>list</code> constructor is a special-purpose tool for looping over an iterable to build up a new list, without changing anything at all.</p>

<p>If you don&rsquo;t need to filter your elements down or map them into new elements while building up your new list, <strong>you don&rsquo;t need a comprehension: you need the <code>list</code> constructor</strong>.</p>

<p>This comprehension converts each of the <code>row</code> tuples we get from looping over <code>zip</code> into lists:</p>

<pre><code class="python">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        [n for n in row]
        for row in zip(*matrix)
    ]
</code></pre>

<p>We could use the <code>list</code> constructor for that too:</p>

<pre><code class="python">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        list(row)
        for row in zip(*matrix)
    ]
</code></pre>

<p>Whenever you see a comprehension like this:</p>

<pre><code class="python">my_list = [x for x in some_iterable]
</code></pre>

<p>You could write this instead:</p>

<pre><code class="python">my_list = list(some_iterable)
</code></pre>

<p>The same applies for <code>dict</code> and <code>set</code> comprehensions.</p>

<p>This is also something I&rsquo;ve written quite a bit in the past:</p>

<pre><code class="python">states = [
    ('AL', 'Alabama'),
    ('AK', 'Alaska'),
    ('AZ', 'Arizona'),
    ('AR', 'Arkansas'),
    ('CA', 'California'),
    # ...
]

abbreviations_to_names = {
    abbreviation: name
    for abbreviation, name in states
}
</code></pre>

<p>Here we&rsquo;re looping over a list of two-item tuples and making a dictionary out of them.</p>

<p>This task is exactly what the <code>dict</code> constructor was made for:</p>

<pre><code class="python">abbreviations_to_names = dict(states)
</code></pre>

<p>The built-in <code>list</code> and <code>dict</code> constructors aren&rsquo;t the only comprehension-replacing tools.
The standard library and third-party libraries also include tools that are sometimes better suited for your looping needs than a comprehension.</p>

<p>Here&rsquo;s a generator expression that sums up an iterable-of-iterables-of-numbers:</p>

<pre><code class="python">def sum_all(number_lists):
    """Return the sum of all numbers in the given list-of-lists."""
    return sum(
        n
        for numbers in number_lists
        for n in numbers
    )
</code></pre>

<p>And here&rsquo;s the same thing using <code>itertools.chain</code>:</p>

<pre><code class="python">from itertools import chain

def sum_all(number_lists):
    """Return the sum of all numbers in the given list-of-lists."""
    return sum(chain.from_iterable(number_lists))
</code></pre>

<p>When you should use a comprehension and when you should use the alternative isn&rsquo;t always straightforward.</p>

<p>I&rsquo;m often torn on whether to use <code>itertools.chain</code> or a comprehension.
I usually write my code both ways and then go with the one that seems clearer.</p>

<p>Readability is fairly problem-specific with many programming constructs, comprehensions included.</p>

<h2>Needless work</h2>

<p>Sometimes you&rsquo;ll see comprehensions that shouldn&rsquo;t be replaced by another construct but should instead be <strong>removed entirely</strong>, leaving only the iterable they loop over.</p>

<p>Here we&rsquo;re opening up a file of words (with one word per line), storing file in memory, and counting the number of times each occurs:</p>

<pre><code class="python">from collections import Counter

word_counts = Counter(
    word
    for word in open('word_list.txt').read().splitlines()
)
</code></pre>

<p>We&rsquo;re using a generator expression here, but we don&rsquo;t need to be.
This works just as well:</p>

<pre><code class="python">from collections import Counter

word_counts = Counter(open('word_list.txt').read().splitlines())
</code></pre>

<p>We were looping over a list to convert it to a generator before passing it to the <code>Counter</code> class.
That was needless work!
The <code>Counter</code> class accepts <strong>any iterable: it doesn&rsquo;t care whether they&rsquo;re lists, generators, tuples, or something else</strong>.</p>

<p>Here&rsquo;s another needless comprehension:</p>

<pre><code class="python">with open('word_list.txt') as words_file:
    lines = [line for line in words_file]
    for line in lines:
        if 'z' in line:
            print('z word', line, end='')
</code></pre>

<p>We&rsquo;re looping over <code>words_file</code>, converting it to a list of <code>lines</code>, and then looping over <code>lines</code> just once.
That conversion to a list was unnecessary.</p>

<p>We could just loop over <code>words_file</code> directly instead:</p>

<pre><code class="python">with open('word_list.txt') as words_file:
    for line in words_file:
        if 'z' in line:
            print('z word', line, end='')
</code></pre>

<p>There&rsquo;s no reason to convert an iterable to a list if all we&rsquo;re going to do is loop over it once.</p>

<p>In Python, we often care less about <strong>whether something is a list</strong> and more about <strong>whether it&rsquo;s an iterable</strong>.</p>

<p>Be careful not to create new iterables when you don&rsquo;t need to: <strong>if you&rsquo;re only going to loop over an iterable once, just use the iterable you already have</strong>.</p>

<h2>When would I use a comprehension?</h2>

<p>So when would you actually use a comprehension?</p>

<p>The simple but imprecise answer is whenever you can write your code in the below <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">comprehension copy-pasteable format</a> and there isn&rsquo;t another tool you&rsquo;d rather use for shortening your code, you should consider using a list comprehension.</p>

<pre><code class="python">new_things = []
for ITEM in old_things:
    if condition_based_on(ITEM):
        new_things.append(some_operation_on(ITEM))
</code></pre>

<p>That loop can be rewritten as this comprehension:</p>

<pre><code class="python">new_things = [
    some_operation_on(ITEM)
    for ITEM in old_things
    if condition_based_on(ITEM)
]
</code></pre>

<p>The complex answer is whenever comprehensions make sense, you should consider them.
That&rsquo;s not really an answer, but there is no one answer to the question &ldquo;when should I use a comprehension&rdquo;?</p>

<p>For example here&rsquo;s a <code>for</code> loop which doesn&rsquo;t really look like it could be rewritten using a comprehension:</p>

<pre><code class="python">def is_prime(candidate):
    for n in range(2, candidate):
        if candidate % n == 0:
            return False
    return True
</code></pre>

<p>But there is in fact another way to write this loop using a generator expression, if we know how to use the built-in <code>all</code> function:</p>

<pre><code class="python">def is_prime(candidate):
    return all(
        candidate % n != 0
        for n in range(2, candidate)
    )
</code></pre>

<p>I wrote <a href="https://treyhunner.com/2016/11/check-whether-all-items-match-a-condition-in-python/">a whole article on the <code>any</code> and <code>all</code> functions</a> and how they pair so nicely with generator expressions.
But <code>any</code> and <code>all</code> aren&rsquo;t alone in their affinity for generator expressions.</p>

<p>We have a similar situation with this code:</p>

<pre><code class="python">def sum_of_squares(numbers):
    total = 0
    for n in numbers:
        total += n**2
    return total
</code></pre>

<p>There&rsquo;s no <code>append</code> there and no new iterable being built up.
But if we create a generator of squares, we could pass them to the built-in <code>sum</code> function to get the same result:</p>

<pre><code class="python">def sum_of_squares(numbers):
    return sum(n**2 for n in numbers)
</code></pre>

<p>So in addition to the &ldquo;can I copy-paste my way from a loop to a comprehension&rdquo; check, there&rsquo;s another, fuzzier, check to consider: could your code be enhanced by a generator expression combined with an iterable-accepting function or class?</p>

<p>Any function or class that <strong>accepts an iterable as an argument</strong> <em>might</em> be a good candidate for <strong>combining with a generator expression</strong>.</p>

<h2>Use list comprehensions thoughtfully</h2>

<p>List comprehensions can make your code more readable (if you don&rsquo;t believe me, see the examples in my <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">Comprehensible Comprehensions</a> talk), but they can definitely be abused.</p>

<p>List comprehensions are a special-purpose tool for solving a specific problem.
The <code>list</code> and <code>dict</code> constructors are <strong>even more special-purpose tools</strong> for solving even more specific problems.</p>

<p>Loops are <strong>a more general purpose tool</strong> for times when you have a problem that doesn&rsquo;t fit within the realm of comprehensions or another special-purpose looping tool.</p>

<p>Functions like <code>any</code>, <code>all</code>, and <code>sum</code>, and classes like <code>Counter</code> and <code>chain</code> are iterable-accepting tools that <strong>pair very nicely with comprehensions</strong> and sometimes <strong>replace the need for comprehensions entirely</strong>.</p>

<p>Remember that comprehensions are for a single purpose: <strong>creating a new iterable from an old iterable</strong>, while tweaking values slightly along the way and/or for filtering out values that don&rsquo;t match a certain condition.
Comprehensions are a lovely tool, but <strong>they&rsquo;re not your only tool</strong>.
Don&rsquo;t forget the <code>list</code> and <code>dict</code> constructors and always consider <code>for</code> loops when your comprehensions get out of hand.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique sentinel values, identity checks, and when to use object() instead of None]]></title>
    <link href="http://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/"/>
    <updated>2019-03-20T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2019/03/unique-and-sentinel-values-in-python</id>
    <content type="html"><![CDATA[<p>Occasionally in Python (and in programming in general), you&rsquo;ll need an object which can be uniquely identified.
Sometimes this unique object represents a <strong>stop value</strong> or a <strong>skip value</strong> and sometimes it&rsquo;s an <strong>initial value</strong>.
But in each of these cases you want your object to stand out from the other objects you&rsquo;re working with.</p>

<p>When you need a unique value (a <strong>sentinel value</strong> maybe) <code>None</code> is often the value to reach for.
But sometimes <code>None</code> isn&rsquo;t enough: sometimes <code>None</code> is ambiguous.</p>

<p>In this article we&rsquo;ll talk about when <code>None</code> isn&rsquo;t enough, I&rsquo;ll show you how I create unique values when <code>None</code> doesn&rsquo;t cut it, and we&rsquo;ll see a few different uses for this technique.</p>

<ul data-toc=".entry-content"></ul>


<h2>Initial values and default values</h2>

<p>Let&rsquo;s re-implement a version of Python&rsquo;s built-in <code>min</code> function.</p>

<pre><code class="python">def min(iterable, default=None):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = None
    for item in iterable:
        if minimum is None or item &lt; minimum:
            minimum = item
    if minimum is not None:
        return minimum
    elif default is not None:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>This <code>min</code> function, like the built-in one, returns the minimum value in the given iterable or raises an exception when an empty iterable is given unless a default value is specified (in which case the default is returned).</p>

<pre><code class="python">&gt;&gt;&gt; min([4, 3, 8, 7])
3
&gt;&gt;&gt; min([9])
9
&gt;&gt;&gt; min([])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in min
ValueError: Empty iterable
&gt;&gt;&gt; min([], default=9)
9
&gt;&gt;&gt; min([4, 3, 8, 7], default=9)
3
</code></pre>

<p>This behavior is somewhat similar to the built-in <code>min</code> function, except <strong>our code is buggy</strong>!</p>

<p>There are two bugs here.</p>

<p>First, an iterable containing a single <code>None</code> value will be treated as if it was an empty iterable:</p>

<pre><code class="python">&gt;&gt;&gt; min([None], default=0)
0
&gt;&gt;&gt; min([None])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 8, in min
ValueError: Empty iterable
</code></pre>

<p>Second, if we specify our <code>default</code> value as <code>None</code> this <code>min</code> function won&rsquo;t accept it:</p>

<pre><code class="python">&gt;&gt;&gt; min([], default='')
''
&gt;&gt;&gt; min([], default=None)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in min
ValueError: Empty iterable
</code></pre>

<p>Why is this happening?</p>

<p>It&rsquo;s all about <code>None</code>.</p>

<h2>Why is <code>None</code> a problem?</h2>

<p>The first bug in our code is related to the initial value for <code>minimum</code> and the second is related to the default value for our <code>default</code> argument.
In both cases, <strong>we&rsquo;re using <code>None</code> to represent an <em>unspecified</em> or <em>un-initialized</em> value</strong>.</p>

<pre><code class="python">def min(iterable, default=None):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = None
    for item in iterable:
        if minimum is None or item &lt; minimum:
            minimum = item
    if minimum is not None:
        return minimum
    elif default is not None:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>Using <code>None</code> is a problem in both cases because <code>None</code> is both a valid value for <code>default</code> and a valid value in our iterable.</p>

<p>Python&rsquo;s <code>None</code> value is useful for representing emptiness, but it isn&rsquo;t magical, at least not any more magical than any other valid value.</p>

<p>If we need a truly unique value for our default state, we need to invent our own.</p>

<p>When <code>None</code> isn&rsquo;t a valid input for your function, it&rsquo;s perfectly fine to use it to represent a unique default or initial state.
But <code>None</code> is often valid data, which means <strong><code>None</code> is sometimes a poor choice for a unique initial state</strong>.</p>

<p>We&rsquo;ll fix both of our bugs by using <code>object()</code>: a somewhat common convention for creating a truly unique value in Python.</p>

<p>First we&rsquo;ll set <code>minimum</code> to a unique object:</p>

<pre><code class="python">def min(iterable, default=None):
    """Imperfect re-implementation of Python's built-in min function."""
    initial = object()
    minimum = initial
    for item in iterable:
        if minimum is initial or item &lt; minimum:
            minimum = item
    if minimum is not initial:
        return minimum
    elif default is not None:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>That <code>initial</code> variable holds our unique value so we can check for its presence later.</p>

<p>This fixes the first bug:</p>

<pre><code class="python">&gt;&gt;&gt; min([None], default=0)
&gt;&gt;&gt; min([None])
&gt;&gt;&gt; min([])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 13, in min
ValueError: Empty iterable
</code></pre>

<p>But not the second.</p>

<p>To fix the second bug we need to use a different default value for our <code>default</code> argument (other than <code>None</code>).</p>

<p>To do this, we&rsquo;ll make a global &ldquo;constant&rdquo; (by convention) variable, <code>INITIAL</code>, outside our function:</p>

<pre><code class="python">INITIAL = object()


def min(iterable, default=INITIAL):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = INITIAL
    for item in iterable:
        if minimum is INITIAL or item &lt; minimum:
            minimum = item
    if minimum is not INITIAL:
        return minimum
    elif default is not INITIAL:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>Now our code works exactly how we&rsquo;d hope it would:</p>

<pre><code class="python">&gt;&gt;&gt; min([None], default=0)
&gt;&gt;&gt; min([None])
&gt;&gt;&gt; min([], default=None)
&gt;&gt;&gt; min([], default='')
''
&gt;&gt;&gt; min([4, 3, 7, 8])
3
&gt;&gt;&gt; min([4, 3, 7, 8], default=0)
3
&gt;&gt;&gt; min([])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in min
ValueError: Empty iterable
</code></pre>

<p>That&rsquo;s lovely&hellip; but what is this magical <code>object()</code> thing?
Why does it work, how does it work, and when should we use it?</p>

<h2>What is <code>object()</code>?</h2>

<p>Every class in Python has a base class of <code>object</code> (in Python 3 that is&hellip; things were a bit weirder in Python 2).</p>

<p>So <code>object</code> is a class:</p>

<pre><code class="python">&gt;&gt;&gt; object
&lt;class 'object'&gt;
&gt;&gt;&gt; type(object)
&lt;class 'type'&gt;
</code></pre>

<p>When we call <code>object</code> we&rsquo;re creating an &ldquo;instance&rdquo; of the object class, just as calling any other class (when given the correct arguments) will create instances of them:</p>

<pre><code class="python">&gt;&gt;&gt; set()
set()
&gt;&gt;&gt; bytearray()
bytearray(b'')
&gt;&gt;&gt; frozenset()
frozenset()
</code></pre>

<p>So we&rsquo;re creating an instance of <code>object</code>.
But&hellip; why?</p>

<p>Well, an instance of <code>object</code> shouldn&rsquo;t be seen as equal to any other object:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; x == y
False
&gt;&gt;&gt; x == 4
False
&gt;&gt;&gt; x == None
False
&gt;&gt;&gt; x == []
False
</code></pre>

<p>Except itself:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; z = x
&gt;&gt;&gt; x == z
True
</code></pre>

<p>Python&rsquo;s <code>None</code> is similar, except that <em>anyone</em> can get access to this unique <code>None</code> object anywhere in their code by just typing <code>None</code>.</p>

<pre><code class="python">&gt;&gt;&gt; x = None
&gt;&gt;&gt; y = None
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; x == y
False
</code></pre>

<p>We needed a placeholder value in our code.
<code>None</code> is a lovely placeholder as long as <strong>we don&rsquo;t need to worry about distinguishing between <em>our</em> <code>None</code> and <em>their</em> <code>None</code></strong>.</p>

<p>If <code>None</code> is valid <em>data</em>, it&rsquo;s no longer just a placeholder.
At that point, we need to start reaching for <code>object()</code> instead.</p>

<h2>Equality vs identity</h2>

<p>I noted that <code>object()</code> isn&rsquo;t <em>equal</em> to anything else.
But we weren&rsquo;t actually checking for equality (using <code>==</code> or <code>!=</code>) in our function:</p>

<p>Instead of <code>==</code> and <code>!=</code>, we used <code>is</code> and <code>is not</code>.</p>

<pre><code class="python">INITIAL = object()


def min(iterable, default=INITIAL):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = INITIAL
    for item in iterable:
        if minimum is INITIAL or item &lt; minimum:
            minimum = item
    if minimum is not INITIAL:
        return minimum
    elif default is not INITIAL:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>While <code>==</code> and <code>!=</code> are equality operators, <code>is</code> and <code>is not</code> are <strong>identity operators</strong>.</p>

<p>Python&rsquo;s <code>is</code> operator asks about the <strong>identity</strong> of an object: are the two objects on either side of the <code>is</code> operator actually the same exact object.</p>

<p>We&rsquo;re not just asking <em>are they equal</em>, but are they stored in <em>the same place in memory</em> and in fact refer to the same exact object.</p>

<p>Two of the variables below (<code>x</code> and <code>z</code>) point to the same object:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; z = x
</code></pre>

<p>So while <code>y</code> has a unique ID in memory, <code>x</code> and <code>z</code> do not:</p>

<pre><code class="python">&gt;&gt;&gt; id(x)
140079600030400
&gt;&gt;&gt; id(y)
140079561403808
&gt;&gt;&gt; id(z)
140079600030400
</code></pre>

<p>Which means <code>x</code> is <em>identical</em> to <code>z</code>:</p>

<pre><code class="python">&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; x is z
True
</code></pre>

<p>By default, Python&rsquo;s <code>==</code> operator delegates to <code>is</code>.
Meaning unless two variables point to the exact some object in memory, <code>==</code> will return <code>False</code>:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; z = x
&gt;&gt;&gt; x == x
True
&gt;&gt;&gt; x == y
False
&gt;&gt;&gt; x == z
True
</code></pre>

<p>This is true <em>by default</em>&hellip; but many objects in Python overload the <code>==</code> operator to do much more useful things when we ask about equality.</p>

<pre><code class="python">&gt;&gt;&gt; 0 == 0.0
True
&gt;&gt;&gt; [1, 2, 3] == [1, 2, 3]
True
&gt;&gt;&gt; (1, 2) == (1, 3)
False
&gt;&gt;&gt; {} == {}
True
</code></pre>

<p>Each object can <strong>customize the behavior of <code>==</code></strong> to answer whatever question they&rsquo;d like.</p>

<p>Which means someone could make a class like this:</p>

<pre><code class="python">&gt;&gt;&gt; class AlwaysEqual:
...     def __eq__(self, other):
...         return True
...
</code></pre>

<p>And suddenly our assumption about <code>==</code> with <code>object()</code> (or any other value) will fail us:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = AlwaysEqual()
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; x == y
True
</code></pre>

<h2>Use identity to compare unique objects</h2>

<p>The <code>is</code> operator, unlike <code>==</code>, is not overloadable.
<strong>Unlike with <code>==</code>, there&rsquo;s no way to control or change what happens when you say <code>x is y</code>.</strong></p>

<p>There&rsquo;s a <code>__eq__</code> method, but there&rsquo;s no such thing as a <code>__is__</code> method.
Which means the <code>is</code> operator will never lie to you: it will always tell you whether two objects are one in the same.</p>

<p>If we use <code>is</code> instead of <code>==</code>, we could actually use any unique object to represent our unique <code>INITIAL</code> value.</p>

<p>Even an empty list:</p>

<pre><code class="python">INITIAL = []


def min(iterable, default=INITIAL):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = INITIAL
    for item in iterable:
        if minimum is INITIAL or item &lt; minimum:
            minimum = item
    if minimum is not INITIAL:
        return minimum
    elif default is not INITIAL:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>An empty list might seem problematic in the same way as <code>None</code> was: but they&rsquo;re actually quite different.</p>

<p>We don&rsquo;t have any of the same issues as we did with <code>None</code> before:</p>

<pre><code class="python">&gt;&gt;&gt; min([[]], default=0)
[]
&gt;&gt;&gt; min([[]])
[]
&gt;&gt;&gt; min([], default=[])
[]
</code></pre>

<p>The reason is that <code>None</code> is a <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singleton value</a>.
That means that whenever you say <code>None</code> in your Python code, you&rsquo;re referencing the exact same <code>None</code> object every time.</p>

<pre><code class="python">&gt;&gt;&gt; x = None
&gt;&gt;&gt; y = None
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; id(x), id(y)
(94548887510464, 94548887510464)
</code></pre>

<p>Whereas every empty list we make creates a brand new list object:</p>

<pre><code class="python">&gt;&gt;&gt; x = []
&gt;&gt;&gt; y = []
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; id(x), id(y)
(140079561624776, 140079598927432)
</code></pre>

<p>So while two independent empty lists may be <em>equal</em>, they aren&rsquo;t the same object:</p>

<pre><code class="python">&gt;&gt;&gt; x = []
&gt;&gt;&gt; y = []
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x is y
False
</code></pre>

<p>The objects that those <code>x</code> and <code>y</code> variables point to have <strong>the same value</strong> but are <strong>not actually the same object</strong>.</p>

<h2>None is a placeholder value</h2>

<p>Python&rsquo;s <code>None</code> is lovely.
<code>None</code> is a universal placeholder value.
Need a placeholder?
Great!
Python has a great placeholder value and it&rsquo;s called <code>None</code>!</p>

<p>There are lots of places where Python itself actually uses <code>None</code> as a placeholder value also.</p>

<p>If you pass no arguments to the string <code>split</code> method, that&rsquo;s the same as passing a separator value of <code>None</code>:</p>

<pre><code class="python">&gt;&gt;&gt; s = "hello world"
&gt;&gt;&gt; s.split()
['hello', 'world']
&gt;&gt;&gt; s.split(None)
['hello', 'world']
</code></pre>

<p>If you pass in a <code>key</code> function of <code>None</code> to the <code>sorted</code> builtin, that&rsquo;s the same as passing in no <code>key</code> function at all:</p>

<pre><code class="python">&gt;&gt;&gt; sorted(s, key=None)
[' ', 'd', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
&gt;&gt;&gt; sorted(s)
[' ', 'd', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
</code></pre>

<p>Python loves using <code>None</code> as a placeholder because it&rsquo;s often a pretty great placeholder value.</p>

<p>The issue with <code>None</code> only appears <strong>if someone else could reasonably be using <code>None</code> as a non-placeholder input to our function</strong>.
This is often the case when the caller of a function has a placeholder values (often <code>None</code>) in their inputs and the author of that function (that&rsquo;s us) needs a separate unique placeholder.</p>

<p>Using <code>None</code> to represent two different things at once is like having two identical-looking bookmarks in the same book: it&rsquo;s confusing!</p>

<h2>Creating unique non-None placeholders: why <code>object()</code>?</h2>

<p>When we made that <code>INITIAL</code> value before, we were sort of inventing our own <code>None</code>-like object: an object that we could uniquely reference by using the <code>is</code> operator.</p>

<p>That <code>INITIAL</code> object we made should be completely unique: it shouldn&rsquo;t ever be seen in any arbitrary input that may be given to our function (unless someone made the strange decision to import <code>INITIAL</code> and reference it specifically).</p>

<p>Why <code>object()</code> though?
After all we could have used any unique object by creating an instance of pretty much any class:</p>

<pre><code class="python">&gt;&gt;&gt; INITIAL = []
&gt;&gt;&gt; INITIAL == []
True
&gt;&gt;&gt; INITIAL is []
False
</code></pre>

<p>Though it might have been even more clear to create our own class just for this purpose:</p>

<pre><code class="python">class DummyClass:
    """Class that just creates unique objects."""

INITIAL = DummyClass()
</code></pre>

<p>But I&rsquo;d argue that <code>object()</code> is the &ldquo;right&rdquo; thing to use here.</p>

<p>Everyone knows what <code>[]</code> means, but <code>object()</code> is mysterious, which is actually the reason I think it&rsquo;s a good choice in this case.</p>

<p>When we see an empty list we expect that list to be used <em>as a list</em> and when we see a class instance, we expect that class to <em>do something</em>.
But we don&rsquo;t actually want this object to <em>do</em> anything: <strong>we only care about the uniqueness of this new object</strong>.</p>

<p>We could have done this:</p>

<pre><code class="python">&gt;&gt;&gt; INITIAL = ['completely unique value']
</code></pre>

<p>But I find using <code>object()</code> less confusing than this because it&rsquo;s clear: readers won&rsquo;t have a chance to be confused by the listy-ness of a list.</p>

<pre><code class="python">&gt;&gt;&gt; INITIAL = object()  # completely unique value
</code></pre>

<p>Also if a confused developer Googles &ldquo;what is <code>object()</code> in Python?&rdquo; they might end up with <a href="https://stackoverflow.com/questions/28306371/what-is-object-good-for">some sort of explanation</a>.</p>

<h2>Other cases for non-None placeholders</h2>

<p>There&rsquo;s a word I&rsquo;ve been avoiding using up to this point.
I&rsquo;ve only been avoiding it because I think I typically misuse it (or rather overuse it).
The word is <a href="https://en.wikipedia.org/wiki/Sentinel_value">sentinel value</a>.</p>

<p>I suspect I overuse this word because I use it to mean any unique placeholder value, such as the <code>INITIAL</code> object we made before.
But most definitions I&rsquo;ve seen use &ldquo;sentinel value&rdquo; to specifically mean a value which indicates the end of a list, a loop, or an algorithm.</p>

<p>Sentinel values are a thing that, when seen, indicate that something has finished.
I think of this as a <strong>stop value</strong>: when you see a sentinel value it&rsquo;s a signal that the loop or algorithm that you&rsquo;re in should terminate.</p>

<p>Before we weren&rsquo;t using a stop value so much as an <strong>initial value</strong>.</p>

<p>Here&rsquo;s an example of a stop value; a true sentinel value:</p>

<pre><code class="python">from itertools import zip_longest

SENTINEL = object()

def strict_zip(*iterables):
    """Variation of ``zip`` which requires equal-length iterables."""
    for values in zip_longest(*iterables, fillvalue=SENTINEL):
        if SENTINEL in values:
            raise ValueError("Given iterables must have the same length.")
        yield values
</code></pre>

<p>We&rsquo;re using the unique <code>SENTINEL</code> value above to signal that we need to stop looping and raise an exception.
The presence of this value indicates that one of our iterables was a different length than the others and we need to handle this error case.</p>

<h2>Rely on identity checks for unique values</h2>

<p>Note that we&rsquo;re implicitly relying on <code>==</code> above because we&rsquo;re saying <code>if SENTINEL in values</code> which actually loops over <code>values</code> looking for a value that is equal to <code>SENTINEL</code>.</p>

<p>If we wanted to be more strict (and possibly more efficient) we could rely on <code>is</code>, but we&rsquo;d need to do some looping ourselves.
Fortunately Python&rsquo;s <code>any</code> function and a generator expression would make that a bit easier:</p>

<pre><code class="python">from itertools import zip_longest

SENTINEL = object()

def strict_zip(*iterables):
    """Variation of ``zip`` which requires equal-length iterables."""
    for values in zip_longest(*iterables, fillvalue=SENTINEL):
        if any(v is SENTINEL for v in values):
            raise ValueError("Given iterables must have the same length.")
        yield values
</code></pre>

<p>I&rsquo;m fine with either of these functions.  The first is a bit more readable even though this one is arguably a bit more correct.</p>

<p>Identity checks are often faster than equality checks (<code>==</code> has to call the <code>__eq__</code> method, but <code>is</code> does a straight memory ID check).
But identity checks are also a bit more <em>correct</em>: if it&rsquo;s uniqueness we care about, <strong>a unique memory location is the ultimate uniqueness check</strong>.</p>

<p>When writing code that uses <strong>a unique object</strong>, it&rsquo;s wise to <strong>rely on identity rather than equality</strong> if you can.</p>

<h2>This is what <code>is</code> was made for</h2>

<p>If we care about <em>equality</em> (the value of an object) we use <code>==</code>, if we care about <em>identity</em> (the memory location) we use <code>is</code>.</p>

<p>If you search my Python code for <code>is</code> you&rsquo;ll pretty much only find the following things:</p>

<ol>
<li><code>x is None</code> (this is the most common thing you&rsquo;ll see)</li>
<li><code>x is True</code> or <code>x is False</code> (sometimes my tests get picky about <code>True</code> vs truthiness)</li>
<li><code>iter(x) is x</code> (<a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">iterators</a> are a different Python rabbit hole)</li>
<li><code>x is some_unique_object</code></li>
</ol>


<p>Those first two are checking for a <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singleton</a> value (as <a href="https://pep8.org/#programming-recommendations">recommended by PEP 8</a>).
The third one is checking if we&rsquo;ve seen <strong>the same object twice</strong> (an iterator in this case).
And the fourth one is checking for the presence of these unique values we&rsquo;ve been discussing.</p>

<p>The <code>is</code> operator checks whether two objects are exactly the same object in memory.
<strong>You never want to use the <code>is</code> operator <em>except</em> for true identity checks</strong>: <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singletons</a> (like <code>None</code>, <code>True</code>, and <code>False</code>), checking for the same object again, and checking for our own unique values (sentinels, as I usually call them).</p>

<h2>So when would we use <code>object()</code>?</h2>

<p>Oftentimes <code>None</code> is both the easy answer and the right answer for a unique placeholder value in Python, but sometimes you just need to invent your own unique placeholder value.
In those cases <code>object()</code> is a great tool to have in your Python toolbox.</p>

<p>When would we actually use <code>object()</code> for a uniqueness check in our own code?</p>

<p>I can think of a few cases:</p>

<ol>
<li><strong>Unique initial values</strong>: a starting value that should be distinguished from values seen later (<code>default</code> and <code>initial</code> in our <code>min</code> function)</li>
<li><strong>Unique stop values</strong>: a value whose presence tells us to stop looping/processing (a true sentinel value, as in <code>strict_zip</code>)</li>
<li><strong>Unique skip values</strong>: a value whose presence should be treated as an empty value to be skipped over (we didn&rsquo;t see this, but it comes up with utilities like <code>itertools.zip_longest</code> sometimes)</li>
</ol>


<p>I hope this meandering through unique values has given you something (some non-<code>None</code> things) to think about.</p>

<p>May your <code>None</code> values be unambiguous and your identity checks be truly unique.</p>
]]></content>
  </entry>
  
</feed>
