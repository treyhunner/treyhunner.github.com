<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="http://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://treyhunner.com/"/>
  <updated>2018-12-20T09:54:43-08:00</updated>
  <id>http://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Cyber Monday Sales]]></title>
    <link href="http://treyhunner.com/2018/11/python-cyber-monday-sales/"/>
    <updated>2018-11-26T07:45:00-08:00</updated>
    <id>http://treyhunner.com/2018/11/python-cyber-monday-sales</id>
    <content type="html"><![CDATA[<p>I&rsquo;m running <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">a sale</a> that ends in 24 hours, but I&rsquo;m not the only one.
This post is a compilation of the different Cyber Monday deals I&rsquo;ve found related to Python and Python learning.</p>

<h3>Python Morsels weekly skill-building</h3>

<p>This is my weekly Python skill-building service.</p>

<p>I&rsquo;m offering 52 weeks of <a href="https://www.pythonmorsels.com/">Python Morsels</a> for 50% off.</p>

<p>You can find <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">more details on this sale here</a>.</p>

<h3>Talk Python Course Bundle</h3>

<p>Michael Kennedy of <a href="https://training.talkpython.fm/courses/bundle/black-friday-2018">Talk Python</a> is offering a 4 course bundle for a number of Python courses.</p>

<h3>Reuven Lerner&rsquo;s Python courses</h3>

<p>Reuven Lerner is also offering a <a href="http://blog.lerner.co.il/last-chance-to-save-40-on-python-and-git-courses/">40% off sale on his courses</a>.
Reuven has courses on Python, Git, and regular expressions.</p>

<h3>PyBites Code Challenges</h3>

<p>Bob and Julian of PyBites are offering a 50% off sale on their <a href="https://gumroad.com/l/ZFrD/black-friday">Code Challenges</a>.
These are a different variety of code challenges than Python Morsels.
You could sign up for both and <a href="https://www.pythonmorsels.com/">Python Morsels</a> if you wanted extra learning every week.</p>

<h3>Hello Web Books</h3>

<p>Tracy Osborn is running a 50% off sale on her <a href="https://hellowebbooks.com/order/">Hello Web Books</a>, which include books on Python and Django for beginners to web programming and books on design for beginners to web design.
You&rsquo;ll need to enter coupon code BLACKFRIDAY2018 to get these deals.</p>

<h3>The pytest book</h3>

<p>Brian Okken&rsquo;s <a href="https://pragprog.com/book/bopytest/python-testing-with-pytest">Python Testing with pytest</a> is on sale today (along with other Pragmatic Bookshelf books) for 40% off with coupon code turkeysale2018.</p>

<h3>More Python Books</h3>

<p>A number of Python book publishers, such as <a href="https://nostarch.com/catalog/python">No Starch</a>, are running big sales on their books.
I took a look at their sale, but haven&rsquo;t gone searching for more of them.</p>

<h3>Other Cyber Monday deals?</h3>

<p>If you have questions about the <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">Python Morsels sale</a>, <a href="mailto:tr%65y%40&amp;#116;%72%75&amp;#116;%68%66u&amp;#108;&amp;#46;&amp;#116;&amp;#101;c%68&amp;#110;%6flo%67%79">email me</a>.</p>

<p>The Python Morsels sale and likely all the other sales above will end in the next 24 hours, probably sooner depending on when you&rsquo;re reading this.</p>

<p>So go check them out!</p>

<p>Did I miss a deal that you know about?
Link to it in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Black Friday Sale: 50% Off 52 weeks of Python Morsels]]></title>
    <link href="http://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/"/>
    <updated>2018-11-21T11:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python</id>
    <content type="html"><![CDATA[<p>I launched a weekly Python skill-building service earlier this year called <a href="https://www.pythonmorsels.com/">Python Morsels</a>.
This week I&rsquo;m running my first sale, which will also likely be the biggest sale that I run on Python Morsels for the foreseeable future (I don&rsquo;t want to say forever, but probably forever).</p>

<p>If you&rsquo;re an experienced programmer and you feel like your Python code could be <em>more Pythonic</em>, <a href="https://www.pythonmorsels.com/">Python Morsels</a> is for you.</p>

<p>Before I jump into details, let me explain what Python Morsels is.</p>

<h2>The inspiration</h2>

<p>I do on-site Python training for teams, which means I work with a lot of developers at a lot of companies.
One question I hear all the time is &ldquo;how can I make my code more Pythonic&rdquo;?</p>

<p>Most of the folks I teach are not new to programming and they&rsquo;re usually not new to Python either, but they also aren&rsquo;t experienced at leveraging the features and idioms that make Python unique.
Being a skilled programmer isn&rsquo;t the same as being a skilled <em>Python</em> programmer</p>

<p>Late last year this conundrum inspired me to create <a href="https://www.pythonmorsels.com/">Python Morsels</a>.</p>

<h2>Learning by doing</h2>

<p>My training courses and workshops are exercise-driven and I find an exercise-heavy style of teaching very effective.</p>

<p>You don&rsquo;t learn by putting information into your head, <strong>you learn by trying to retrieve information from your head</strong>.
You can watch talks and read books and read code, but you&rsquo;ll absorb very little unless you <em>apply</em> what you&rsquo;ve learned.
You learn by doing, which means writing Python code.</p>

<p>That&rsquo;s why Python Morsels is entirely about writing code and reflecting on the code you&rsquo;ve written.</p>

<h2>Python Morsels: exercise-driven learning</h2>

<p>After you sign up for Python Morsels I&rsquo;ll send you <strong>one exercise every week</strong>.
Not an interview questions: a realistic Python exercise inspired by the interesting problems I&rsquo;ve had to solve in the past. The purpose of these exercises is to <strong>inspire you to learn something new about Python each week</strong>.</p>

<p>Each exercise includes a number of bonuses so you can <strong>choose your own difficulty level</strong>.
All exercises also include automated tests so you can test your code quickly.
After you&rsquo;ve solved the exercise I&rsquo;ll send you a number of different solutions to the problem with a discussion about why we might choose one solution over another.
These solutions are meant to help you <strong>reconsider the way you write your code</strong>.</p>

<p>While solving the bonuses is important, the more important thing is that you <strong>get into the habit of time-boxed weekly learning</strong>. You want to spend your time effectively and the best way to do that is to <strong>form a learning habit</strong> and time box that habit.
I suggest that you dedicate 30 minutes every week to solving the exercise, regardless of the difficulty level you choose, as well as 30 minutes to reflecting on the solutions email I send you.</p>

<h2>So how much is this sale for?</h2>

<p>Python Morsels normally costs $16/month (or $160/year on the annual plan).</p>

<p>From now until Monday I&rsquo;m offering a 40% discount off the annual plan, which means you&rsquo;ll get <strong>52 weeks of Python skill-building for $96</strong>.
That&rsquo;s effectively $8/month or <strong>a 50% discount</strong> when compared to the monthly subscription.</p>

<p>I say &ldquo;52 weeks&rdquo; instead of 1 year because Python Morsels subscriptions can be &ldquo;paused&rdquo; at any time, which allows for breaks during vacations and busy periods and ensures you&rsquo;ll get all of the 52 weeks you signed up for.</p>

<p>To take advantage of this discount you&rsquo;ll need to sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a>, verify your email address, go to the Account page, and click the Subscribe button for the <strong>52 Week Plan</strong>.
The BLACKFRIDAY discount code should be automatically applied from now until the end of the sale on Monday.</p>

<h2>Money back guarantee</h2>

<p>This is the first sale I&rsquo;ve ever held so I&rsquo;m not sure whether it&rsquo;s common to offer a guarantee on sales, but I&rsquo;m going to do it for this one because I&rsquo;m pretty confident in what I&rsquo;m offering.</p>

<p>If you contact me with concerns but I can&rsquo;t find something that works for your needs, I&rsquo;ll send you a full refund.
I want you to improve your Python skills, but I don&rsquo;t want you signing up for something that isn&rsquo;t for you.
If you end up signing up for Python Morsels and you don&rsquo;t improve your Python skills because of it, <strong>you deserve a refund because I&rsquo;ve wasted your time</strong>.</p>

<h2>What do the first 52 weeks of Python Morsels exercises cover?</h2>

<p>Python Morsels starts small, but the exercises increase in difficulty over time.
The first 52 weeks of Python exercises will wander into <strong>a lot of interesting topics</strong>.</p>

<p>Within one year we&rsquo;ll:</p>

<ul>
<li>work with and create our own iterators (both generators and iterator classes)</li>
<li>make text-parsing programs and command-line programs</li>
<li>talk a lot about readability and code style</li>
<li>dive into a number of the built-ins and standard library modules</li>
<li>use operator overloading to make classes that support arithmetic</li>
<li>create our context managers</li>
<li>create our own decorators</li>
<li>use properties and descriptors and even <strong>make our own descriptor</strong></li>
<li>create custom collections (mappings, sequences, strings, sets, etc.)</li>
</ul>


<p>Haven&rsquo;t made a descriptor before?
By this time next year you will have!</p>

<h2>The sale ends on Monday</h2>

<p>This sale will ends on <strong>Monday November 26</strong>, end of day.</p>

<p>To get an effective 50% discount on Python Morsels over the next 52 weeks, <a href="https://www.pythonmorsels.com/signup/">sign up to Python Morsels</a>, verify your email, go to the Account page, and subscribe to the <strong>52 Week Plan</strong>.</p>

<h2>Share this sale with friends and family</h2>

<p>If you have a friend or colleague who might benefit from weekly Python practice, let them know about this sale!
The BLACKFRIDAY coupon expires on Monday, but there&rsquo;s no limit on the number of signups, so there&rsquo;s no reason to keep this sale a secret.</p>

<p>So please share this email or the discount code with anyone you know who might find value in 52 weeks of Python skill-building.</p>

<h2>Frequently Asked Questions</h2>

<p>These are questions that I&rsquo;ve been asked at least once (that&rsquo;s apparently what &ldquo;frequently&rdquo; means now).</p>

<h4>Is this for someone who is brand new to programming?</h4>

<p>No, it isn&rsquo;t.
Python Morsels is for someone who has been using Python for a while and wants to improve their Python coding practices.
Many of the folks currently signed up write primarily Python code, but have a background in at least one other programming language.
However, there are a handful of folks who are signed up who would call Python their first and only programming language and I do try to accommodate folks in that camp as much as I can.</p>

<p>In general, I recommend Python Morsels for <strong>folks who are currently writing Python code regularly</strong>.</p>

<h4>How is Python Morsels different from a Python course?</h4>

<p>During my on-site trainings I&rsquo;m present as a live instructor and coach.
That&rsquo;s something you won&rsquo;t get from Python Morsels.
During online courses there are videos explaining each topic before it&rsquo;s practiced.
Python Morsels also doesn&rsquo;t have that.</p>

<p>The focus of Python Morsels is a bit different than a course or a training.
If you think of Python course as like taking a tennis class, Python Morsels is more like <strong>weekly tennis practice</strong>.
A Python Morsels subscriber described it to me as <strong>like Hannon&rsquo;s finger exercises for piano or Kreutzer&rsquo;s Ã©tudes for violin</strong>.
Python Morsels is guided <strong>deliberate practice</strong> in the domain of writing readable and maintainable Python code.</p>

<h4>How much time does this require each week?</h4>

<p>I expect that you&rsquo;ll spend <strong>about an hour each week on Python Morsels in total</strong>.</p>

<p>You&rsquo;re a busy person who has production code to write and I don&rsquo;t want to waste your time.
The exercise includes bonuses, but I don&rsquo;t expect you to solve them all each week: instead I want you to time box yourself.
I recommend that you set aside 30 minutes to solve the problem each week, including running the tests and solving as many bonuses as you can.
I&rsquo;d also like you to set aside 30 minutes to reflect on your code while reading the solution email I send each week.
I often link to related resources to read/watch, but I&rsquo;d like you to bookmark those for later.</p>

<p>If you have more than one hour to devote each week, you could sit on the solutions for a couple days and then resolve the exercise without looking at the solutions email.
I don&rsquo;t expect this though.</p>

<h4>What if the exercises are too easy for me and I don&rsquo;t learn anything new?</h4>

<p>If you find the exercises are too easy, email me and I&rsquo;ll see what I can do.
I&rsquo;ve developed quite a few exercises over the last year and I may be able to work with you to ensure the exercises you get are a good fit for your experience level.
If it turns out that Python Morsels simply isn&rsquo;t for you, I&rsquo;ll refund you.</p>

<h4>What if the exercises suddenly get too hard for me?</h4>

<p>If the exercises turn out to be too challenging for you, either immediately or eventually, email me.
I plan to create some easier tracks for Python Morsels eventually (there&rsquo;s certainly demand for this) and I may have some suitable exercises to send to you.
If Python Morsels doesn&rsquo;t suit your needs and I can&rsquo;t easily fix the problem, I&rsquo;ll send you a refund.</p>

<h2>Ready to start a weekly skill-building habit?</h2>

<p>Are you ready to start 52 weeks of Python skill-building for $96 (normally $192)?
That&rsquo;s less than $2/week and about one hour of your time each week (which really is the bigger cost here).</p>

<p>If you have questions that I didn&rsquo;t address above, please <a href="mailto:tr%65y%40&amp;#116;%72%75&amp;#116;%68%66u&amp;#108;&amp;#46;&amp;#116;&amp;#101;c%68&amp;#110;%6flo%67%79">email me</a> and say what you&rsquo;re thinking/feeling.</p>

<p>If you&rsquo;re interested in seeing the opinion of someone who has worked through Python Morsels exercises, see the testimonials <a href="https://www.pythonmorsels.com/">on the homepage</a> or take a look at what some of my Python Morsels friends have said about it on Twitter (<a href="https://twitter.com/AndrewsForge/status/1018597131496710144">Andrew Pinkham</a>, <a href="https://twitter.com/PavelAnni/status/963778202605932544">Pavel Anni</a>, <a href="https://twitter.com/jmwatt3/status/1035314897280794629">Jason Wattier</a>, <a href="https://twitter.com/abqpythonista/status/976202006405595136">Ben Jones</a>).</p>

<p>Ready to sign up?
<a href="https://www.pythonmorsels.com/signup/">Click here to get 52 weeks of Python Morsels at 50% off</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Asterisks in Python: what they are and how to use them]]></title>
    <link href="http://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/"/>
    <updated>2018-10-11T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them</id>
    <content type="html"><![CDATA[<p>There are a lot of places you&rsquo;ll see <code>*</code> and <code>**</code> used in Python.
These two operators can be a bit mysterious at times, both for brand new programmers and for folks moving from many other programming languages which may not have completely equivalent operators.
I&rsquo;d like to discuss what those operators are and the many ways they&rsquo;re used.</p>

<p>The <code>*</code> and <code>**</code> operators have grown in ability over the years and I&rsquo;ll be discussing all the ways that you can currently use these operators and noting which uses only work in modern versions of Python.
So if you learned <code>*</code> and <code>**</code> back in the days of Python 2, I&rsquo;d recommend at least skimming this article because Python 3 has added a lot of new uses for these operators.</p>

<p>If you&rsquo;re newer to Python and you&rsquo;re not yet familiar with keyword arguments (a.k.a. named arguments), I&rsquo;d recommend reading my article on <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">keyword arguments in Python</a> first.</p>

<h2>What we&rsquo;re not talking about</h2>

<p>When I discuss <code>*</code> and <code>**</code> in this article, I&rsquo;m talking about the <code>*</code> and <code>**</code> <em>prefix</em> operators, not the <em>infix</em> operators.</p>

<p>So I&rsquo;m not talking about multiplication and exponentiation:</p>

<pre><code class="pycon">&gt;&gt;&gt; 2 * 5
10
&gt;&gt;&gt; 2 ** 5
32
</code></pre>

<h2>So what are we talking about?</h2>

<p>We&rsquo;re talking about the <code>*</code> and <code>**</code> prefix operators, that is the <code>*</code> and <code>**</code> operators that are used before a variable.  For example:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; more_numbers = [*numbers, 11, 18]
&gt;&gt;&gt; print(*more_numbers, sep=', ')
2, 1, 3, 4, 7, 11, 18
</code></pre>

<p>Two of the uses of <code>*</code> are shown in that code and no uses of <code>**</code> are shown.</p>

<p>This includes:</p>

<ol>
<li>Using <code>*</code> and <code>**</code> to pass arguments to a function</li>
<li>Using <code>*</code> and <code>**</code> to capture arguments passed into a function</li>
<li>Using <code>*</code> to accept keyword-only arguments</li>
<li>Using <code>*</code> to capture items during tuple unpacking</li>
<li>Using <code>*</code> to unpack iterables into a list/tuple</li>
<li>Using <code>**</code> to unpack dictionaries into other dictionaries</li>
</ol>


<p>Even if you think you&rsquo;re familiar with all of these ways of using <code>*</code> and <code>**</code>, I recommend looking at each of the code blocks below to make sure they&rsquo;re all things you&rsquo;re familiar with.
The Python core developers have continued to add new abilities to these operators over the last few years and it&rsquo;s easy to overlook some of the newer uses of <code>*</code> and <code>**</code>.</p>

<h2>Asterisks for unpacking into function call</h2>

<p>When calling a function, the <code>*</code> operator can be used to unpack an iterable into the arguments in the function call:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; print(fruits[0], fruits[1], fruits[2], fruits[3])
lemon pear watermelon tomato
&gt;&gt;&gt; print(*fruits)
lemon pear watermelon tomato
</code></pre>

<p>That <code>print(*fruits)</code> line is passing all of the items in the <code>fruits</code> list into the <code>print</code> function call as separate arguments, without us even needing to know how many arguments are in the list.</p>

<p>The <code>*</code> operator isn&rsquo;t just syntactic sugar here.
This ability of sending in all items in a particular iterable as separate arguments wouldn&rsquo;t be possible without <code>*</code>, unless the list was a fixed length.</p>

<p>Here&rsquo;s another example:</p>

<pre><code class="python">def transpose_list(list_of_lists):
    return [
        list(row)
        for row in zip(*list_of_lists)
    ]
</code></pre>

<p>Here we&rsquo;re accepting a list of lists and returning a &ldquo;transposed&rdquo; list of lists.</p>

<pre><code class="pycon">&gt;&gt;&gt; transpose_list([[1, 4, 7], [2, 5, 8], [3, 6, 9]])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>

<p>The <code>**</code> operator does something similar, but with keyword arguments.
The <code>**</code> operator allows us to take a dictionary of key-value pairs and unpack it into keyword arguments in a function call.</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': "2020", 'month': "01", 'day': "01"}
&gt;&gt;&gt; filename = "{year}-{month}-{day}.txt".format(**date_info)
&gt;&gt;&gt; filename
'2020-01-01.txt'
</code></pre>

<p>From my experience, using <code>**</code> to unpack keyword arguments into a function call isn&rsquo;t particularly common.
The place I see this most is when practicing inheritance: calls to <code>super()</code> often include both <code>*</code> and <code>**</code>.</p>

<p>Both <code>*</code> and <code>**</code> can be used multiple times in function calls, as of Python 3.5.</p>

<p>Using <code>*</code> multiple times can sometimes be handy:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; print(*numbers, *fruits)
2 1 3 4 7 lemon pear watermelon tomato
</code></pre>

<p>Using <code>**</code> multiple times looks similar:</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': "2020", 'month': "01", 'day': "01"}
&gt;&gt;&gt; track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'}
&gt;&gt;&gt; filename = "{year}-{month}-{day}-{artist}-{title}.txt".format(
...     **date_info,
...     **track_info,
... )
&gt;&gt;&gt; filename
'2020-01-01-Beethoven-Symphony No 5.txt'
</code></pre>

<p>You need to be careful when using <code>**</code> multiple times though.
Functions in Python can&rsquo;t have the same keyword argument specified multiple times, so the keys in each dictionary used with <code>**</code> must be distinct or an exception will be raised.</p>

<h2>Asterisks for packing arguments given to function</h2>

<p>When defining a function, the <code>*</code> operator can be used to capture an unlimited number of positional arguments given to the function.
These arguments are captured into a tuple.</p>

<pre><code class="python">from random import randint

def roll(*dice):
    return sum(randint(1, die) for die in dice)
</code></pre>

<p>This function accepts any number of arguments:</p>

<pre><code class="pycon">&gt;&gt;&gt; roll(20)
18
&gt;&gt;&gt; roll(6, 6)
9
&gt;&gt;&gt; roll(6, 6, 6)
8
</code></pre>

<p>Python&rsquo;s <code>print</code> and <code>zip</code> functions accept any number of positional arguments.
This argument-packing use of <code>*</code> allows us to make our own function which, like <code>print</code> and <code>zip</code>, accept any number of arguments.</p>

<p>The <code>**</code> operator also has another side to it: we can use <code>**</code> when defining a function to capture any keyword arguments given to the function into a dictionary:</p>

<pre><code class="python">def tag(tag_name, **attributes):
    attribute_list = [
        f'{name}="{value}"'
        for name, value in attributes.items()
    ]
    return f"&lt;{tag_name} {' '.join(attribute_list)}&gt;"
</code></pre>

<p>That <code>**</code> will capture any keyword arguments we give to this function into a dictionary which will that <code>attributes</code> arguments will reference.</p>

<pre><code class="pycon">&gt;&gt;&gt; tag('a', href="http://treyhunner.com")
'&lt;a href="http://treyhunner.com"&gt;'
&gt;&gt;&gt; tag('img', height=20, width=40, src="face.jpg")
'&lt;img height="20" width="40" src="face.jpg"&gt;'
</code></pre>

<h2>Positional arguments with keyword-only arguments</h2>

<p>As of Python 3, we now have a special syntax for accepting keyword-only arguments to functions.
Keyword-only arguments are function arguments which can <em>only</em> be specified using the keyword syntax, meaning they cannot be specified positionally.</p>

<p>To accept keyword-only arguments, we can put named arguments after a <code>*</code> usage when defining our function:</p>

<pre><code class="python">def get_multiple(*keys, dictionary, default=None):
    return [
        dictionary.get(key, default)
        for key in keys
    ]
</code></pre>

<p>The above function can be used like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon': 'yellow', 'orange': 'orange', 'tomato': 'red'}
&gt;&gt;&gt; get_multiple('lemon', 'tomato', 'squash', dictionary=fruits, default='unknown')
['yellow', 'red', 'unknown']
</code></pre>

<p>The arguments <code>dictionary</code> and <code>default</code> come after <code>*keys</code>, which means they can <em>only</em> be specified as <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">keyword arguments</a>.
If we try to specify them positionally we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon': 'yellow', 'orange': 'orange', 'tomato': 'red'}
&gt;&gt;&gt; get_multiple('lemon', 'tomato', 'squash', fruits, 'unknown')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: get_multiple() missing 1 required keyword-only argument: 'dictionary'
</code></pre>

<p>This behavior was introduced to Python through <a href="https://www.python.org/dev/peps/pep-3102/">PEP 3102</a>.</p>

<h2>Keyword-only arguments without positional arguments</h2>

<p>That keyword-only argument feature is cool, but what if you want to require keyword-only arguments without capturing unlimited positional arguments?</p>

<p>Python allows this with a somewhat strange <code>*</code>-on-its-own syntax:</p>

<pre><code class="python">def with_previous(iterable, *, fillvalue=None):
    """Yield each iterable item along with the item before it."""
    previous = fillvalue
    for item in iterable:
        yield previous, item
        previous = item
</code></pre>

<p>This function accepts an <code>iterable</code> argument, which can be specified positionally (as the first argument) or by its name and a <code>fillvalue</code> argument which is a keyword-only argument.  This means we can call <code>with_previous</code> like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(with_previous([2, 1, 3], fillvalue=0))
[(0, 2), (2, 1), (1, 3)]
</code></pre>

<p>But not like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(with_previous([2, 1, 3], 0))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: with_previous() takes 1 positional argument but 2 were given
</code></pre>

<p>This function accepts two arguments and one of them, <code>fillvalue</code> <em>must be specified as a keyword argument</em>.</p>

<p>I usually use keyword-only arguments used while capturing any number of positional arguments, but I do sometimes use this <code>*</code> to enforce an argument to only be specified positionally.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function actually uses this approach.  If you look at the help information on <code>sorted</code> you&rsquo;ll see the following:</p>

<pre><code>&gt;&gt;&gt; help(sorted)
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.

    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.
</code></pre>

<p>There&rsquo;s an <code>*</code>-on-its-own, right in the documented arguments for <code>sorted</code>.</p>

<h2>Asterisks in tuple unpacking</h2>

<p>Python 3 also added a new way of using the <code>*</code> operator that is only somewhat related to the <code>*</code>-when-defining-a-function and <code>*</code>-when-calling-a-function features above.</p>

<p>The <code>*</code> operator can also be used in tuple unpacking now:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; first, second, *remaining = fruits
&gt;&gt;&gt; remaining
['watermelon', 'tomato']
&gt;&gt;&gt; first, *remaining = fruits
&gt;&gt;&gt; remaining
['pear', 'watermelon', 'tomato']
&gt;&gt;&gt; first, *middle, last = fruits
&gt;&gt;&gt; middle
['pear', 'watermelon']
</code></pre>

<p>If you&rsquo;re wondering &ldquo;where could I use this in my own code&rdquo;, take a look at the examples in my article on <a href="https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">tuple unpacking in Python</a>.
In that article I show how this use of the <code>*</code> operator can sometimes be used as an alternative to sequence slicing.</p>

<p>Usually when I teach <code>*</code> I note that you can only use one <code>*</code> expression in a single multiple assignment call.
That&rsquo;s technically incorrect because it&rsquo;s possible to use two in a nested unpacking (I talk about nested unpacking in my tuple unpacking article):</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; ((first_letter, *remaining), *other_fruits) = fruits
&gt;&gt;&gt; remaining
['e', 'm', 'o', 'n']
&gt;&gt;&gt; other_fruits
['pear', 'watermelon', 'tomato']
</code></pre>

<p>I&rsquo;ve never seen a good use for this though and I don&rsquo;t think I&rsquo;d recommend using it even if you found one because it seems a bit cryptic.</p>

<p>The PEP that added this to Python 3.0 is <a href="https://www.python.org/dev/peps/pep-3132/">PEP 3132</a> and it&rsquo;s not a very long one.</p>

<h2>Asterisks in list literals</h2>

<p>Python 3.5 introduced a ton of new <code>*</code>-related features through <a href="https://www.python.org/dev/peps/pep-0448/">PEP 448</a>.
One of the biggest new features is the ability to use <code>*</code> to dump an iterable into a new list.</p>

<p>Say you have a function that takes any sequence and returns a list with the sequence and the reverse of that sequence concatenated together:</p>

<pre><code class="python">def palindromify(sequence):
    return list(sequence) + list(reversed(sequence))
</code></pre>

<p>This function needs to convert things to lists a couple times in order to concatenate the lists and return the result.
In Python 3.5, we can type this instead:</p>

<pre><code class="python">def palindromify(sequence):
    return [*sequence, *reversed(sequence)]
</code></pre>

<p>This code removes some needless list calls so our code is both more efficient and more readable.</p>

<p>Here&rsquo;s another example:</p>

<pre><code class="python">def rotate_first_item(sequence):
    return [*sequence[1:], sequence[0]]
</code></pre>

<p>That function returns a new list where the first item in the given list (or other sequence) is moved to the end of the new list.</p>

<p>This use of the <code>*</code> operator is a great way to concatenate iterables of different types together.
The <code>*</code> operator works for any iterable, whereas using the <code>+</code> operator only works on particular sequences which have to all be the same type.</p>

<p>This isn&rsquo;t just limited to creating lists either.
We can also dump iterables into new tuples or sets:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['lemon', 'pear', 'watermelon', 'tomato']
&gt;&gt;&gt; (*fruits[1:], fruits[0])
('pear', 'watermelon', 'tomato', 'lemon')
&gt;&gt;&gt; uppercase_fruits = (f.upper() for f in fruits)
&gt;&gt;&gt; {*fruits, *uppercase_fruits}
{'lemon', 'watermelon', 'TOMATO', 'LEMON', 'PEAR', 'WATERMELON', 'tomato', 'pear'}
</code></pre>

<p>Notice that the last line above takes a list and a generator and dumps them into a new set.
Before this use of <code>*</code>, there wasn&rsquo;t previously an easy way to do this in one line of code.
There was a way to do this before, but it wasn&rsquo;t easy to remember or discover:</p>

<pre><code class="pycon">&gt;&gt;&gt; set().union(fruits, uppercase_fruits)
{'lemon', 'watermelon', 'TOMATO', 'LEMON', 'PEAR', 'WATERMELON', 'tomato', 'pear'}
</code></pre>

<h2>Double asterisks in dictionary literals</h2>

<p>PEP 448 also expanded the abilities of <code>**</code> by allowing this operator to be used for dumping key/value pairs from one dictionary into a new dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': "2020", 'month': "01", 'day': "01"}
&gt;&gt;&gt; track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'}
&gt;&gt;&gt; all_info = {**date_info, **track_info}
&gt;&gt;&gt; all_info
{'year': '2020', 'month': '01', 'day': '01', 'artist': 'Beethoven', 'title': 'Symphony No 5'}
</code></pre>

<p>I wrote another article on how this is now the <a href="https://treyhunner.com/2016/02/how-to-merge-dictionaries-in-python/">idiomatic way to merge dictionaries in Python</a>.</p>

<p>This can be used for more than just merging two dictionaries together though.</p>

<p>For example we can copy a dictionary while adding a new value to it:</p>

<pre><code class="pycon">&gt;&gt;&gt; date_info = {'year': '2020', 'month': '01', 'day': '7'}
&gt;&gt;&gt; event_info = {**date_info, 'group': "Python Meetup"}
&gt;&gt;&gt; event_info
{'year': '2020', 'month': '01', 'day': '7', 'group': 'Python Meetup'}
</code></pre>

<p>Or copy/merge dictionaries while overriding particular values:</p>

<pre><code class="pycon">&gt;&gt;&gt; event_info = {'year': '2020', 'month': '01', 'day': '7', 'group': 'Python Meetup'}
&gt;&gt;&gt; new_info = {**event_info, 'day': "14"}
&gt;&gt;&gt; new_info
{'year': '2020', 'month': '01', 'day': '14', 'group': 'Python Meetup'}
</code></pre>

<h2>Python&rsquo;s asterisks are powerful</h2>

<p>Python&rsquo;s <code>*</code> and <code>**</code> operators aren&rsquo;t just syntactic sugar.
Some of the things they allow you to do could be achieved through other means, but the alternatives to <code>*</code> and <code>**</code> tend to be more cumbersome and more resource intensive.
And some of the features they provide are simply impossible to achieve without them: for example there&rsquo;s no way to accept any number of positional arguments to a function without <code>*</code>.</p>

<p>After reading about all the features of <code>*</code> and <code>**</code>, you might be wondering what the names for these odd operators are.
Unfortunately, they don&rsquo;t really have succinct names.
I&rsquo;ve heard <code>*</code> called the &ldquo;packing&rdquo; and &ldquo;unpacking&rdquo; operator.
I&rsquo;ve also heard it called &ldquo;splat&rdquo; (from the Ruby world) and I&rsquo;ve heard it called simply &ldquo;star&rdquo;.</p>

<p>I tend to call these operators &ldquo;star&rdquo; and &ldquo;double star&rdquo; or &ldquo;star star&rdquo;.
That doesn&rsquo;t distinguish them from their infix relatives (multiplication and exponentiation), but context usually makes it obvious whether we&rsquo;re talking about prefix or infix operators.</p>

<p>If you don&rsquo;t understand <code>*</code> and <code>**</code> or you&rsquo;re concerned about memorizing all of their uses, don&rsquo;t be!
These operators have many uses and memorizing the specific use of each one isn&rsquo;t as important as getting a feel for when you might be able to reach for these operators.
I suggest using this article as <strong>a cheat sheet</strong> or to making your own cheat sheet to help you use <code>*</code> and <code>**</code> in Python.</p>

<h2>Practice makes perfect</h2>

<p>You don&rsquo;t learn by putting information in your head, you learn by attempting to retrieve information from your head.
So you&rsquo;ve just read an article on something new, but <strong>you haven&rsquo;t learned yet</strong>.</p>

<p>Write some code that uses <code>*</code> and <code>**</code> in a number of different ways today.
Then quiz yourself on the many different ways to use <code>*</code> and <code>**</code> tomorrow!</p>

<p>If you&rsquo;d like to get practice with <code>*</code> and <code>**</code>, <strong><a href="https://www.pythonmorsels.com/">sign up for Python Morsels</a></strong>.
The first few problems use <code>*</code> in a couple different ways.
If you sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a> I&rsquo;ll help you <strong>level up your Python skills every week</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Overusing lambda expressions in Python]]></title>
    <link href="http://treyhunner.com/2018/09/stop-writing-lambda-expressions/"/>
    <updated>2018-09-27T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2018/09/stop-writing-lambda-expressions</id>
    <content type="html"><![CDATA[<p><strong>Note</strong>: This post was originally titled &ldquo;Stop writing lambda expressions in Python&rdquo; but I&rsquo;ve changed the title after deciding that it was a little too extreme.</p>

<p>It&rsquo;s hard for me to teach an in-depth Python class without discussing lambda expressions.
I almost always get questions about them.
My students tend to see them in code on StackOverflow or they see them in a coworker&rsquo;s code (which, realistically, may have also come from StackOverflow).</p>

<p>I get a lot of questions about lambda, I&rsquo;m hesitant to recommend my students embrace Python&rsquo;s lambda expressions.
I have had an aversion to lambda expressions for many years, and since I started teaching Python more regularly a few years ago, my aversion to lambda expressions has only grown stronger.</p>

<p>I&rsquo;m going to explain how I see lambda expressions and why I tend to recommend my students avoid using them.</p>

<h2>Lambda expressions in Python: what are they?</h2>

<p>Lambda expressions a special syntax in Python for creating <a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous functions</a>.
I&rsquo;ll call the <code>lambda</code> syntax itself a <strong>lambda expression</strong> and the function you get back from this I&rsquo;ll call a <strong>lambda function</strong>.</p>

<p>Python&rsquo;s lambda expressions allow a function to be created and passed around (often into another function) all in one line of code.</p>

<p>Lambda expressions allow us to take this code:</p>

<pre><code class="python">colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])

def normalize_case(string):
    return string.casefold()

normalized_colors = map(normalize_case, colors)
</code></pre>

<p>And turn it into this code:</p>

<pre><code class="python">colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])

normalized_colors = map(lambda s: s.casefold(), colors)
</code></pre>

<p>Lambda expressions are just a special syntax for making functions.
They can only have one statement in them and they return the result of that statement automatically.</p>

<p>The inherent limitations of lambda expressions are actually part of their appeal.
When an experienced Python programmer sees a lambda expression they know that they&rsquo;re working with a function that is <strong>only used in one place</strong> and does <strong>just one thing</strong>.</p>

<p>If you&rsquo;ve ever used anonymous functions in JavaScript before, you can think of Python&rsquo;s lambda expressions as the same, except they have more restrictions and use a very different syntax than the traditional function syntax.</p>

<h2>Where they&rsquo;re usually used</h2>

<p>You&rsquo;ll typically see <code>lambda</code> expressions used when calling functions (or classes) that accept a function as an argument.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function accepts a function as its <code>key</code> argument.  This <em>key function</em> is used to compute a comparison key when determining the sorting order of items.</p>

<p>So <code>sorted</code> is a great example of a place that lambda expressions are often used:</p>

<pre><code class="python">&gt;&gt;&gt; colors = ["Goldenrod", "purple", "Salmon", "turquoise", "cyan"]
&gt;&gt;&gt; sorted(colors, key=lambda s: s.casefold())
['cyan', 'Goldenrod', 'purple', 'Salmon', 'turquoise']
</code></pre>

<p>The above code returns the given colors sorted in a case-insensitive way.</p>

<p>The <code>sorted</code> function isn&rsquo;t the only use of lambda expressions, but it&rsquo;s a common one.</p>

<h2>The pros and cons of lambda</h2>

<p>I frame my thinking around lambda expressions as a constant comparison to using <code>def</code> to define functions.
Both of these tools give us functions, but they each have different limitations and use a different syntax.</p>

<p>The main ways lambda expressions are different from <code>def</code>:</p>

<ol>
<li>They can be immediately passed around (no variable needed)</li>
<li>They can only have a single line of code within them</li>
<li>They return automatically</li>
<li>They can&rsquo;t have a docstring and they don&rsquo;t have a name</li>
<li>They use a different and unfamiliar syntax</li>
</ol>


<p>The fact that lambda expressions can be passed around is their biggest benefit.  Returning automatically is neat but not a big benefit in my mind.  I find the &ldquo;single line of code&rdquo; limitation is neither good nor bad overall.  The fact that lambda functions can&rsquo;t have docstrings and don&rsquo;t have a name is unfortunate and their unfamiliar syntax can be troublesome for newer Pythonistas.</p>

<p>Overall I feel the cons slightly outweigh the pros of lambda expressions, but my biggest complaint about them is that I find that they tend to be both misused and overused.</p>

<h2>Lambda is both misused and overused</h2>

<p>When I see a lambda expression in unfamiliar code I immediately become skeptical.
When I encounter a lambda expression in the wild, I often find that removing it improves code readability.</p>

<p>Sometimes the issue is that lambda expressions are being misused, meaning they&rsquo;re <strong>used in a way that is nearly always unideal</strong>.
Other times lambda expressions are simply being overused, meaning they&rsquo;re acceptable but I&rsquo;d personally <strong>prefer to see the code written a different way</strong>.</p>

<p>Let&rsquo;s take a look at the various ways lambda expressions are misused and overused.</p>

<h2>Misuse: naming lambda expressions</h2>

<p>PEP8, the official Python style guide, advises never to write code like this:</p>

<pre><code class="python">normalize_case = lambda s: s.casefold()
</code></pre>

<p>The above statement makes an anonymous function and then assigns it to a variable.
The above code ignores the reason lambda functions are useful: <strong>lambda functions can be passed around without needing to be assigned to a variable first</strong>.</p>

<p>If you want to create a one-liner function and store it in a variable, you should use <code>def</code> instead:</p>

<pre><code class="python">def normalize_case(s): return s.casefold()
</code></pre>

<p>PEP8 recommends this because named functions are a common and easily understood thing.
This also has the benefit of giving our function a proper name, which could make debugging easier.
Unlike functions defined with <code>def</code>, lambda functions never have a name (it&rsquo;s always <code>&lt;lambda&gt;</code>):</p>

<pre><code class="python">&gt;&gt;&gt; normalize_case = lambda s: s.casefold()
&gt;&gt;&gt; normalize_case
&lt;function &lt;lambda&gt; at 0x7f264d5b91e0&gt;
&gt;&gt;&gt; def normalize_case(s): return s.casefold()
...
&gt;&gt;&gt; normalize_case
&lt;function normalize_case at 0x7f247f68fea0&gt;
</code></pre>

<p><strong>If you want to create a function and store it in a variable, define your function using <code>def</code></strong>.
That&rsquo;s exactly what it&rsquo;s for.
It doesn&rsquo;t matter if your function is a single line of code or if you&rsquo;re defining a function inside of another function, <code>def</code> works just fine for those use cases.</p>

<h2>Misuse: needless function calls</h2>

<p>I frequently see lambda expressions used to wrap around a function that was already appropriate for the problem at hand.</p>

<p>For example take this code:</p>

<pre><code class="python">sorted_numbers = sorted(numbers, key=lambda n: abs(n))
</code></pre>

<p>The person who wrote this code likely learned that lambda expressions are used for making a function that can be passed around.
But they missed out on a slightly bigger picture idea: <strong>all functions in Python (not just lambda functions) can be passed around</strong>.</p>

<p>Since <code>abs</code> (which returns the absolute value of a number) is a function and all functions can be passed around, we could actually have written the above code like this:</p>

<pre><code class="python">sorted_numbers = sorted(numbers, key=abs)
</code></pre>

<p>Now this example might feel contrived, but it&rsquo;s not terribly uncommon to overuse lambda expressions in this way.  Here&rsquo;s another example I&rsquo;ve seen:</p>

<pre><code class="python">pairs = [(4, 11), (8, 8), (5, 7), (11, 3)]
sorted_by_smallest = sorted(pairs, key=lambda items: min(items))
</code></pre>

<p>Because we&rsquo;re accepting exactly the same arguments as we&rsquo;re passing into <code>min</code>, we don&rsquo;t need that extra function call.  We can just pass the <code>min</code> function to <code>key</code> instead:</p>

<pre><code class="python">pairs = [(4, 11), (8, 8), (5, 7), (11, 3)]
sorted_by_smallest = sorted(pairs, key=min)
</code></pre>

<p>You don&rsquo;t need a lambda function if you already have another function that does what you want.</p>

<h2>Overuse: simple, but non-trivial functions</h2>

<p>It&rsquo;s common to see lambda expressions used to make a function that returns a couple of values in a tuple:</p>

<pre><code class="python">colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])
colors_by_length = sorted(colors, key=lambda c: (len(c), c.casefold()))
</code></pre>

<p>That <code>key</code> function here is helping us sort these colors by their length followed by their case-normalized name.</p>

<p>This code is the same as the above code, but I find it more readable:</p>

<pre><code class="python">def length_and_alphabetical(string):
    """Return sort key: length first, then case-normalized string."""
    return (len(string), string.casefold())

colors = ["Goldenrod", "Purple", "Salmon", "Turquoise", "Cyan"])
colors_by_length = sorted(colors, key=length_and_alphabetical)
</code></pre>

<p>This code is quite a bit more verbose, but I find the name of that key function makes it clearer what we&rsquo;re sorting by.
We&rsquo;re not just sorting by the length and we&rsquo;re not just sorting by the color: we&rsquo;re sorting by both.</p>

<p><strong>If a function is important, it deserves a name</strong>.
You could argue that most functions that are used in a lambda expression are so trivial that they don&rsquo;t deserve a name, but there&rsquo;s often little downside to naming functions and I find it usually makes my code more readable overall.</p>

<p>Naming functions often makes code more readable, the same way <a href="http://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">using tuple unpacking to name variables</a> instead of using arbitrary index-lookups often makes code more readable.</p>

<h2>Overuse: when multiple lines would help</h2>

<p>Sometimes the &ldquo;just one line&rdquo; aspect of lambda expressions cause us to write code in convoluted ways.  For example take this code:</p>

<pre><code class="python">points = [((1, 2), 'red'), ((3, 4), 'green')]
points_by_color = sorted(points, key=lambda p: p[1])
</code></pre>

<p>We&rsquo;re hard-coding an index lookup here to sort points by their color.
If we used a named function we could have used <a href="http://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">tuple unpacking</a> to make this code more readable:</p>

<pre><code class="python">def color_of_point(point):
    """Return the color of the given point."""
    (x, y), color = point
    return color

points = [((1, 2), 'red'), ((3, 4), 'green')]
points_by_color = sorted(points, key=color_of_point)
</code></pre>

<p>Tuple unpacking can improve readability over using hard-coded index lookups.
<strong>Using lambda expressions often means sacrificing some Python language features</strong>, specifically those that require multiple lines of code (like an extra assignment statement).</p>

<h2>Overuse: lambda with map and filter</h2>

<p>Python&rsquo;s map and filter functions are almost always paired with lambda expressions.  It&rsquo;s common to see StackOverflow questions asking &ldquo;what is lambda&rdquo; answered with code examples like this:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; squared_numbers = map(lambda n: n**2, numbers)
&gt;&gt;&gt; odd_numbers = filter(lambda n: n % 2 == 1, numbers)
</code></pre>

<p>I find these examples a bit confusing because <strong>I almost never use map and filter in my code</strong>.</p>

<p>Python&rsquo;s <code>map</code> and <code>filter</code> functions are used for looping over an iterable and making a new iterable that either slightly changes each element or filters the iterable down to only elements that match a certain condition.
We can accomplish both of those tasks just as well with list comprehensions or generator expressions:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; squared_numbers = (n**2 for n in numbers)
&gt;&gt;&gt; odd_numbers = (n for n in numbers if n % 2 == 1)
</code></pre>

<p>Personally, I&rsquo;d prefer to see the above generator expressions written over multiple lines of code (<a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">see my article on comprehensions</a>) but I find even these one-line generator expressions more readable than those <code>map</code> and <code>filter</code> calls.</p>

<p>The general operations of mapping and filtering are useful, but we really don&rsquo;t need the <code>map</code> and <code>filter</code> functions themselves.
Generator expressions are a special syntax that exists just for the tasks of mapping and filtering.
So my advice is to <strong>use generator expressions instead of the <code>map</code> and <code>filter</code> functions</strong>.</p>

<h2>Misuse: sometimes you don&rsquo;t even need to pass a function</h2>

<p>What about cases where you need to pass around a function that performs a single operation?</p>

<p>Newer Pythonistas who are keen on functional programming sometimes write code like this:</p>

<pre><code class="python">from functools import reduce

numbers = [2, 1, 3, 4, 7, 11, 18]
total = reduce(lambda x, y: x + y, numbers)
</code></pre>

<p>This code adds all the numbers in the <code>numbers</code> list.
There&rsquo;s an even better way to do this:</p>

<pre><code class="python">numbers = [2, 1, 3, 4, 7, 11, 18]
total = sum(numbers)
</code></pre>

<p>Python&rsquo;s built-in <code>sum</code> function was made just for this task.</p>

<p>The <code>sum</code> function, along with a number of other specialized Python tools, are easy to overlook.
But I&rsquo;d encourage you to seek out the more specialized tools when you need them because they often make for more readable code.</p>

<p>Instead of passing functions into other functions, <strong>look into whether there is a more specialized way to solve your problem instead</strong>.</p>

<h2>Overuse: using lambda for very simple operations</h2>

<p>Let&rsquo;s say instead of adding numbers up, we&rsquo;re multiply numbers together:</p>

<pre><code class="python">from functools import reduce

numbers = [2, 1, 3, 4, 7, 11, 18]
product = reduce(lambda x, y: x * y, numbers, 1)
</code></pre>

<p>The above lambda expression is necessary because we&rsquo;re not allowed to pass the <code>*</code> operator around as if it were a function.
If there was a function that was equivalent to <code>*</code>, we could pass it into the <code>reduce</code> function instead.</p>

<p>Python&rsquo;s standard library actually has a whole module meant to address this problem:</p>

<pre><code class="python">from functools import reduce
from operator import mul

numbers = [2, 1, 3, 4, 7, 11, 18]
product = reduce(mul, numbers, 1)
</code></pre>

<p>Python&rsquo;s <a href="https://docs.python.org/3/library/operator.html">operator module</a> exists to make various Python operators easy to use as functions.
If you&rsquo;re practicing functional(ish) programming, <strong>Python&rsquo;s <code>operator</code> module is your friend</strong>.</p>

<p>In addition to providing functions corresponding to Python&rsquo;s many operators, the <code>operator</code> module provides a couple common higher level functions for accessing items and attributes and calling methods.</p>

<p>There&rsquo;s <code>itemgetter</code> for accessing indexes of a list/sequence or keys of a dictionary/mapping:</p>

<pre><code class="python"># Without operator: accessing a key/index
rows_sorted_by_city = sorted(rows, key=lambda row: row['city'])

# With operator: accessing a key/index
from operator import itemgetter
rows_sorted_by_city = sorted(rows, key=itemgetter('city'))
</code></pre>

<p>There&rsquo;s also <code>attrgetter</code> for accessing attributes on an object:</p>

<pre><code class="python"># Without operator: accessing an attribute
products_by_quantity = sorted(products, key=lambda p: p.quantity)

# With operator: accessing an attribute
from operator import attrgetter
products_by_quantity = sorted(products, key=attrgetter('quantity'))
</code></pre>

<p>And <code>methodcaller</code> for calling methods on an object:</p>

<pre><code class="python"># Without operator: calling a method
sorted_colors = sorted(colors, key=lambda s: s.casefold())

# With operator: calling a method
from operator import methodcaller
sorted_colors = sorted(colors, key=methodcaller('casefold'))
</code></pre>

<p>I <em>usually</em> find that <strong>using the functions in the <code>operator</code> module makes my code clearer</strong> than if I&rsquo;d used an equivalent lambda expression.</p>

<h2>Overuse: when higher order functions add confusion</h2>

<p>A function that accepts a function as an argument is called a <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher order function</a>.  Higher order functions are the kinds of functions that we tend to pass lambda functions to.</p>

<p>The use of higher order functions is common when practicing functional programming.  Functional programming isn&rsquo;t the only way to use Python though: Python is a multi-paradigm language so we can mix and match coding disciplines to make our code more readable.</p>

<p>Compare this:</p>

<pre><code class="python">from functools import reduce

numbers = [2, 1, 3, 4, 7, 11, 18]
product = reduce(lambda x, y: x * y, numbers, 1)
</code></pre>

<p>To this:</p>

<pre><code class="python">def multiply_all(numbers):
    """Return the product of the given numbers."""
    product = 1
    for n in numbers:
        product *= n
    return product

numbers = [2, 1, 3, 4, 7, 11, 18]
product = multiply_all(numbers)
</code></pre>

<p>The second code is longer, but folks without a functional programming background will often find it easier to understand.</p>

<p>Anyone who has gone through one of my Python training courses can probably understand what that <code>multiply_all</code> function does, whereas that <code>reduce</code>/<code>lambda</code> combination is likely a bit more cryptic for many Python programmers.</p>

<p>In general, <strong>passing one function into another function, tends to make code more complex, which can hurt readability</strong>.</p>

<h2>Should you ever use lambda expressions?</h2>

<p>So I find the use of lambda expressions problematic because:</p>

<ul>
<li>lambda expressions are an odd and unfamiliar syntax to many Python programmers</li>
<li>lambda functions inherently lack a name or documentation, meaning reading their code is the only way to figure out what they do</li>
<li>lambda expressions can have only one statement in them so certain language features that improve readability, like tuple unpacking, can&rsquo;t be used with them</li>
<li>lambda functions can often be replaced with already existing functions in the standard libray or built-in to Python</li>
</ul>


<p>Lambda expressions are rarely more immediately readable than a well-named function.
While a <code>def</code> statement is often more understandable, <strong>Python also has a number of features that can be used to replace lambda expressions</strong>, including special syntaxes (comprehensions), built-in functions (sum), and standard library functions (in the <code>operators</code> module).</p>

<p>I&rsquo;d say that using lambda expressions is acceptable only if your situation meets all four of these criteria:</p>

<ol>
<li>The operation you&rsquo;re doing is trivial: the function doesn&rsquo;t deserve a name</li>
<li>Having a lambda expression makes your code more understandable than the function names you can think of</li>
<li>You&rsquo;re pretty sure there&rsquo;s not already a function that does what you&rsquo;re looking for</li>
<li>Everyone on your team understands lambda expressions and you&rsquo;ve all agreed to use them</li>
</ol>


<p>If any of those four statements don&rsquo;t fit your situation, I&rsquo;d recommend <strong>writing a new function using <code>def</code></strong> and (whenever possible) <strong>embracing a function that already exists within Python</strong> that already does what you&rsquo;re looking for.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to make an iterator in Python]]></title>
    <link href="http://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/"/>
    <updated>2018-06-21T16:00:00-07:00</updated>
    <id>http://treyhunner.com/2018/06/how-to-make-an-iterator-in-python</id>
    <content type="html"><![CDATA[<p>I wrote an article sometime ago on <a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">the iterator protocol that powers Python&rsquo;s <code>for</code> loops</a>.
One thing I left out of that article was <strong>how to make your own iterators</strong>.</p>

<p>In this article I&rsquo;m going to discuss why you&rsquo;d want to make your own iterators and then show you how to do so.</p>

<h2>What is an iterator?</h2>

<p>First let&rsquo;s quickly address what an iterator is.
For a much more detailed explanation, consider watching my <a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">Loop Better talk</a> or reading <a href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python">the article based on the talk</a>.</p>

<p>An <strong>iter<em>able</em></strong> is anything you&rsquo;re able to loop over.</p>

<p>An <strong>iter<em>ator</em></strong> is the object that does the actual iterating.</p>

<p>You can get an iterator from any iterable by calling the built-in <code>iter</code> function on the iterable.</p>

<pre><code class="python">&gt;&gt;&gt; favorite_numbers = [6, 57, 4, 7, 68, 95]
&gt;&gt;&gt; iter(favorite_numbers)
&lt;list_iterator object at 0x7fe8e5623160&gt;
</code></pre>

<p>You can use the built-in <code>next</code> function on an iterator to get the next item from it (you&rsquo;ll get a <code>StopIteration</code> exception if there are no more items).</p>

<pre><code class="python">&gt;&gt;&gt; favorite_numbers = [6, 57, 4, 7, 68, 95]
&gt;&gt;&gt; my_iterator = iter(favorite_numbers)
&gt;&gt;&gt; next(my_iterator)
6
&gt;&gt;&gt; next(my_iterator)
57
</code></pre>

<p>There&rsquo;s one more rule about iterators that makes everything interesting: <strong>iterators are also iterables</strong> and their iterator is themselves.
I explain the consequences of that more fully in that <a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">Loop Better talk</a> I mentioned above.</p>

<h2>Why make an iterator?</h2>

<p>Iterators allow you to make an iterable that computes its items as it goes.
Which means that you can make iterables that are <strong>lazy</strong>, in that they don&rsquo;t determine what their next item is until you ask them for it.</p>

<p>Using an iterator instead of a list, set, or another iterable data structure can sometimes allow us to save memory.
For example, we can use <code>itertools.repeat</code> to create an iterable that provides 100 million <code>4</code>&rsquo;s to us:</p>

<pre><code class="python">&gt;&gt;&gt; from itertools import repeat
&gt;&gt;&gt; lots_of_fours = repeat(4, times=100_000_000)
</code></pre>

<p>This iterator takes up 56 bytes of memory on my machine:</p>

<pre><code class="python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof(lots_of_fours)
56
</code></pre>

<p>An equivalent list of 100 million <code>4</code>&rsquo;s takes up many megabytes of memory:</p>

<pre><code class="python">&gt;&gt;&gt; lots_of_fours = [4] * 100_000_000
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.getsizeof(lots_of_fours)
800000064
</code></pre>

<p>While iterators can save memory, they can also save time.
For example if you wanted to print out just the first line of a 10 gigabyte log file, you could do this:</p>

<pre><code class="python">&gt;&gt;&gt; print(next(open('giant_log_file.txt')))
This is the first line in a giant file
</code></pre>

<p>File objects in Python are implemented as iterators.
As you loop over a file, data is read into memory one line at a time.
If we instead used the <code>readlines</code> method to store all lines in memory, we might run out of system memory.</p>

<p>So <strong>iterators can save us memory</strong>, but <strong>iterators can sometimes save us time</strong> also.</p>

<p>Additionally, <strong>iterators have abilities that other iterables don&rsquo;t</strong>.
For example, the laziness of iterables can be used to make iterables that have an unknown length.
In fact, you can even make infinitely long iterators.</p>

<p>For example, the <code>itertools.count</code> utility will give us an iterator that will provide every number from <code>0</code> upward as we loop over it:</p>

<pre><code class="python">&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; for n in count():
...     print(n)
...
0
1
2
(this goes on forever)
</code></pre>

<p>That <code>itertools.count</code> object is essentially an infinitely long iterable.
And it&rsquo;s implemented as an iterator.</p>

<h2>Making an iterator: the object-oriented way</h2>

<p>So we&rsquo;ve seen that iterators can save us memory, save us CPU time, and unlock new abilities to us.</p>

<p>Let&rsquo;s make our own iterators.
We&rsquo;ll start be re-inventing the <code>itertools.count</code> iterator object.</p>

<p>Here&rsquo;s an iterator implemented using a class:</p>

<pre><code class="python">class Count:

    """Iterator that counts upward forever."""

    def __init__(self, start=0):
        self.num = start

    def __iter__(self):
        return self

    def __next__(self):
        num = self.num
        self.num += 1
        return num
</code></pre>

<p>This class has an initializer that initializes our current number to <code>0</code> (or whatever is passed in as the <code>start</code>).
The things that make this class usable as an iterator are the <code>__iter__</code> and <code>__next__</code> methods.</p>

<p>When an object is passed to the <code>str</code> built-in function, its <code>__str__</code> method is called.
When an object is passed to the <code>len</code> built-in function, its <code>__len__</code> method is called.</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; str(numbers), numbers.__str__()
('[1, 2, 3]', '[1, 2, 3]')
&gt;&gt;&gt; len(numbers), numbers.__len__()
(3, 3)
</code></pre>

<p>Calling the built-in <code>iter</code> function on an object will attempt to call its <code>__iter__</code> method.
Calling the built-in <code>next</code> function on an object will attempt to call its <code>__next__</code> method.</p>

<p>The <code>iter</code> function is supposed to return an iterator.
So our <code>__iter__</code> function must return an iterator.
But <strong>our object is an iterator</strong>, so should return ourself.
Therefore our <code>Count</code> object returns <code>self</code> from its <code>__iter__</code> method because it is <em>its own iterator</em>.</p>

<p>The <code>next</code> function is supposed to return the next item in our iterator or raise a <code>StopIteration</code> exception when there are no more items.
We&rsquo;re returning the current number and incrementing the number so it&rsquo;ll be larger during the next <code>__next__</code> call.</p>

<p>We can manually loop over our <code>Count</code> iterator class like this:</p>

<pre><code class="python">&gt;&gt;&gt; c = Count()
&gt;&gt;&gt; next(c)
0
&gt;&gt;&gt; next(c)
1
</code></pre>

<p>We could also loop over our <code>Count</code> object like using a <code>for</code> loop, as with any other iterable:</p>

<pre><code class="python">&gt;&gt;&gt; for n in Count():
...     print(n)
...
0
1
2
(this goes on forever)
</code></pre>

<p>This object-oriented approach to making an iterator is cool, but it&rsquo;s not the usual way that Python programmers make iterators.
Usually when we want an iterator, we make a generator.</p>

<h2>Generators: the easy way to make an iterator</h2>

<p>The easiest ways to make our own iterators in Python is to create a generator.</p>

<p>There are two ways to make generators in Python.</p>

<p>Given this list of numbers:</p>

<pre><code class="python">&gt;&gt;&gt; favorite_numbers = [6, 57, 4, 7, 68, 95]
</code></pre>

<p>We can make a generator that will lazily provide us with all the squares of these numbers like this:</p>

<pre><code class="python">&gt;&gt;&gt; def square_all(numbers):
...     for n in numbers:
...         yield n**2
...
&gt;&gt;&gt; squares = square_all(favorite_numbers)
</code></pre>

<p>Or we can make the same generator like this:</p>

<pre><code class="python">&gt;&gt;&gt; squares = (n**2 for n in favorite_numbers)
</code></pre>

<p>The first one is called a <strong>generator function</strong> and the second one is called a <strong>generator expression</strong>.</p>

<p>Both of these generator objects work the same way.
They both have a type of <code>generator</code> and they&rsquo;re both iterators that provide squares of the numbers in our numbers list.</p>

<pre><code class="python">&gt;&gt;&gt; type(squares)
&lt;class 'generator'&gt;
&gt;&gt;&gt; next(squares)
36
&gt;&gt;&gt; next(squares)
3249
</code></pre>

<p>We&rsquo;re going to talk about both of these approaches to making a generator, but first let&rsquo;s talk about terminology.</p>

<p>The word &ldquo;generator&rdquo; is used in quite a few ways in Python:</p>

<ul>
<li>A <strong>generator</strong>, also called a <strong>generator object</strong>, is an iterator whose type is <code>generator</code></li>
<li>A <strong>generator function</strong> is a special syntax that allows us to make a function which returns a <strong>generator object</strong> when we call it</li>
<li>A <strong>generator expression</strong> is a comprehension-like syntax that allows you to create a <strong>generator object</strong> inline</li>
</ul>


<p>With that terminology out of the way, let&rsquo;s take a look at each one of these things individually.
We&rsquo;ll look at generator functions first.</p>

<h2>Generator functions</h2>

<p>Generator functions are distinguished from plain old functions by the fact that they have one or more <code>yield</code> statements.</p>

<p>Normally when you call a function, its code is executed:</p>

<pre><code class="python">&gt;&gt;&gt; def gimme4_please():
...     print("Let me go get that number for you.")
...     return 4
...
&gt;&gt;&gt; num = gimme4_please()
Let me go get that number for you.
&gt;&gt;&gt; num
4
</code></pre>

<p>But if the function has a <code>yield</code> statement in it, it isn&rsquo;t a typical function anymore.
It&rsquo;s now a <strong>generator function</strong>, meaning it will return a <strong>generator object</strong> when called.
That generator object can be looped over to execute it until a <code>yield</code> statement is hit:</p>

<pre><code class="python">&gt;&gt;&gt; def gimme4_later_please():
...     print("Let me go get that number for you.")
...     yield 4
...
&gt;&gt;&gt; get4 = gimme4_later_please()
&gt;&gt;&gt; get4
&lt;generator object gimme4_later_please at 0x7f78b2e7e2b0&gt;
&gt;&gt;&gt; num = next(get4)
Let me go get that number for you.
&gt;&gt;&gt; num
4
</code></pre>

<p>The mere presence of a <code>yield</code> statement turns a function into a generator function.
If you see a function and there&rsquo;s a <code>yield</code>, you&rsquo;re working with a different animal.
It&rsquo;s a bit odd, but that&rsquo;s the way generator functions work.</p>

<p>Okay let&rsquo;s look at a real example of a generator function.
We&rsquo;ll make a generator function that does the same thing as our <code>Count</code> iterator class we made earlier.</p>

<pre><code class="python">def count(start=0):
    num = start
    while True:
        yield num
        num += 1
</code></pre>

<p>Just like our <code>Count</code> iterator class, we can manually loop over the generator we get back from calling <code>count</code>:</p>

<pre><code class="python">&gt;&gt;&gt; c = count()
&gt;&gt;&gt; next(c)
0
&gt;&gt;&gt; next(c)
1
</code></pre>

<p>And we can loop over this generator object using a <code>for</code> loop, just like before:</p>

<pre><code class="python">&gt;&gt;&gt; for n in count():
...     print(n)
...
0
1
2
(this goes on forever)
</code></pre>

<p>But this function is considerably shorter than our <code>Count</code> class we created before.</p>

<h2>Generator expressions</h2>

<p>Generator expressions are a list comprehension-like syntax that allow us to make a generator object.</p>

<p>Let&rsquo;s say we have a list comprehension that filters empty lines from a file and strips newlines from the end:</p>

<pre><code class="python">lines = [
    line.rstrip('\n')
    for line in poem_file
    if line != '\n'
]
</code></pre>

<p>We could create a generator instead of a list, by turning the square brackets of that comprehension into parenthesis:</p>

<pre><code class="python">lines = (
    line.rstrip('\n')
    for line in poem_file
    if line != '\n'
)
</code></pre>

<p>Just as our list comprehension gave us a list back, our <strong>generator expression</strong> gives us a <strong>generator object</strong> back:</p>

<pre><code class="python">&gt;&gt;&gt; type(lines)
&lt;class 'generator'&gt;
&gt;&gt;&gt; next(lines)
' This little bag I hope will prove'
&gt;&gt;&gt; next(lines)
'To be not vainly made--'
</code></pre>

<p>Generator expressions use a shorter inline syntax compared to generator functions.
They&rsquo;re not as powerful though.</p>

<p>If you can write your generator function in this form:</p>

<pre><code class="python">def get_a_generator(some_iterable):
    for item in some_iterable:
        if some_condition(item):
            yield item
</code></pre>

<p>Then you can replace it with a generator expression:</p>

<pre><code class="python">def get_a_generator(some_iterable):
    return (
        item
        for item in some_iterable
        if some_condition(item)
    )
</code></pre>

<p>If you can&rsquo;t write your generator function in that form, then you can&rsquo;t create a generator expression to replace it.</p>

<h2>Generator expressions vs generator functions</h2>

<p>You can think of generator expressions as the list comprehensions of the generator world.</p>

<p>If you&rsquo;re not familiar with list comprehensions, I recommend reading my article on <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">list comprehensions in Python</a>.
I note in that article that you can copy-paste your way from a <code>for</code> loop to a list comprehension.</p>

<p>You can also copy-paste your way from a generator function to a function that returns a generator expression:</p>

<p><img src="/images/generator-expression-copy-paste.gif"></p>

<p>Generator expressions are to generator functions as list comprehensions are to a simple <code>for</code> loop with an append and a condition.</p>

<p>Generator expressions are so similar to comprehensions, that you might even be tempted to say <strong>generator comprehension</strong> instead of generator expression.
That&rsquo;s not technically the correct name, but if you say it everyone will know what you&rsquo;re talking about.
Ned Batchelder actually proposed that we should all <a href="https://nedbatchelder.com/blog/201605/generator_comprehensions.html">start calling generator expressions generator comprehensions</a> and I tend to agree that this would be a clearer name.</p>

<h2>So what&rsquo;s the best way to make an iterator?</h2>

<p>To make an iterator you could create an iterator class, a generator function, or a generator expression.
Which way is the best way though?</p>

<p>Generator expressions are <strong>very succinct</strong>, but they&rsquo;re <strong>not nearly as flexible</strong> as generator functions.
Generator functions are flexible, but if you need to <strong>attach extra methods or attributes</strong> to your iterator object, you&rsquo;ll probably need to switch to using an iterator class.</p>

<p>I&rsquo;d recommend reaching for generator expressions the same way you reach for list comprehensions.
If you&rsquo;re doing a simple <strong>mapping or filtering operation</strong>, a <strong>generator expression</strong> is a great solution.
If you&rsquo;re doing something <strong>a bit more sophisticated</strong>, you&rsquo;ll likely need a <strong>generator function</strong>.</p>

<p>I&rsquo;d recommend using generator functions the same way you&rsquo;d use <code>for</code> loops that append to a list.
Everywhere you&rsquo;d see an <code>append</code> method, you&rsquo;d often see a <code>yield</code> statement instead.</p>

<p>And I&rsquo;d say that you should <strong>almost never create an iterator class</strong>.
If you find you need an iterator class, try to write a generator function that does what you need and see how it compares to your iterator class.</p>

<h2>Generators can help when making iterables too</h2>

<p>You&rsquo;ll see iterator classes in the wild, but there&rsquo;s rarely a good opportunity to write your own.</p>

<p>While it&rsquo;s rare to create your own iterator class, it&rsquo;s not as unusual to make your own iterable class.
And iterable classes require a <code>__iter__</code> method which returns an iterator.
Since generators are the easy way to make an iterator, we can use a generator function or a generator expression to create our <code>__iter__</code> methods.</p>

<p>For example here&rsquo;s an iterable that provides x-y coordinates:</p>

<pre><code class="python">class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y
    def __iter__(self):
        yield self.x
        yield self.y
</code></pre>

<p>Note that our <code>Point</code> class here creates an <strong>iterable</strong> when called (not an iterator).
That means our <code>__iter__</code> method must return an iterator.
The easiest way to create an iterator is by making a generator function, so that&rsquo;s just what we did.</p>

<p>We stuck <code>yield</code> in our <code>__iter__</code> to make it into a generator function and now our <code>Point</code> class can be looped over, just like any other iterable.</p>

<pre><code class="python">&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; x, y = p
&gt;&gt;&gt; print(x, y)
1 2
&gt;&gt;&gt; list(p)
[1, 2]
</code></pre>

<p>Generator functions are a natural fit for creating <code>__iter__</code> methods on your iterable classes.</p>

<h2>Generators are <em>the</em> way to make iterators</h2>

<p>Dictionaries are the typical way to make a mapping in Python.
Functions are the typical way to make a callable object in Python.
Likewise, <strong>generators are the typical way to make an iterator in Python</strong>.</p>

<p>So when you&rsquo;re thinking &ldquo;it sure would be nice to implement an iterable that lazily computes things as it&rsquo;s looped over,&rdquo; think of iterators.</p>

<p>And when you&rsquo;re considering <strong>how to create your own iterator</strong>, think of <strong>generator functions</strong> and <strong>generator expressions</strong>.</p>
]]></content>
  </entry>
  
</feed>
