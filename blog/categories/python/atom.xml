<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="https://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://treyhunner.com/"/>
  <updated>2022-11-22T22:08:53-08:00</updated>
  <id>https://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Black Friday &amp; Cyber Monday sales (2022)]]></title>
    <link href="https://treyhunner.com/2022/11/python-black-friday-and-cyber-monday-sales-2022/"/>
    <updated>2022-11-22T10:15:00-08:00</updated>
    <id>https://treyhunner.com/2022/11/python-black-friday-and-cyber-monday-sales-2022</id>
    <content type="html"><![CDATA[<p>It&rsquo;s that time of year againâ€¦ time for my annual compilation post of Black Friday and Cyber Monday deals for learning Python.</p>

<p>Note that Cyber Monday is a week away, so most sales aren&rsquo;t yet announced. I&rsquo;ll update this post when more details become available; it shouldn&rsquo;t be a long wait!</p>

<h2>Save up to $108 a year on Python Morsels</h2>

<p>Of course I&rsquo;m going to kick things off with my own sale. ðŸ˜‰</p>

<p><a href="https://trey.io/cyber-monday-sale-2022">Python Morsels</a> helps developers <strong>deepen their Python skills</strong> in a way that day-to-day coding simply can&rsquo;t.</p>

<p>Python Morsels is specifically crafted for:</p>

<ul>
<li>experienced developers frustrated with gaps in their Python knowledge</li>
<li>self-taught programmers seeking courage and confidence in their Python abilities</li>
<li>intermediate-level Python learners trying to deepen skills</li>
</ul>


<p>If you saw yourself in that list, subscribe now before prices increase on November 29, 2022!</p>

<p><a href="https://trey.io/cyber-monday-sale-2022" class="subscribe-btn form-big">ðŸ’° See the Python Morsels sale</a></p>

<h2>Python books, courses, templates, and exercises</h2>

<ul>
<li><strong><a href="https://store.lerner.co.il/?coupon=BF2022">Reuven Lerner</a></strong>: Reuven&rsquo;s Python courses are 40% off this week with the coupon <code>BF2022</code></li>
<li><strong>Sundeep Agarwal</strong>: Sundeep&rsquo;s <a href="https://learnbyexample.gumroad.com/l/all-books/FestiveOffer">all books bundle is 64% off</a> (it&rsquo;s $10), the <a href="https://learnbyexample.gumroad.com/l/python-bundle/FestiveOffer">Learn by example Python bundle</a> is 80% off (it&rsquo;s $3), and <a href="https://learnbyexample.gumroad.com/l/py_projects/FestiveOffer">Practice Python Projects</a> is free!</li>
<li><strong><a href="https://pythonspeed.com/products/docker/">Itamar Turner-Trauring</a></strong>: Itamar&rsquo;s Docker packaging products for Python are all 25% off through November with the code <code>FALL22</code></li>
<li><strong><a href="https://www.blog.pythonlibrary.org/2022/11/22/python-black-friday-cyber-monday-sales-2022/">Mike Driscoll</a></strong>: Mike is offering $10 off any of his books this year with the coupon code <code>black2022</code></li>
<li><strong><a href="https://pragprog.com/">Pragmatic Bookshelf</a></strong>: save 40% on Brian Okken&rsquo;s PyTest book or any other Pragmatic Bookshelf book with the coupon code <code>turkeysale2022</code></li>
<li><strong><a href="https://udemy.com">Udemy</a></strong>: various Python courses are also on sale on Udemy right now, including Al Sweigart&rsquo;s <a href="https://www.udemy.com/course/automate/">Automate the Boring Stuff with Python course</a></li>
</ul>


<h2>Python learning subscriptions</h2>

<p>I use a subscription model for <a href="https://trey.io/cyber-monday-sale-2022">Python Morsels</a> because subscriptions (when done well) can encourage habitual learning, which is often more effective than binge-learning.</p>

<p>Here are 3 subscriptions that also involve Python learning:</p>

<ul>
<li><strong><a href="https://www.oreilly.com/online-learning/cyber-monday-2022.html">O'Reilly Media</a></strong> subscriptions are $200 off with the coupon <a href="https://www.oreilly.com/online-learning/cyber-monday-2022.html">CYBERWEEK22</a></li>
<li><strong><a href="https://www.dunderdata.com/black-friday">Ted Petrou</a></strong> is offering 40% off his Dunder Data subscriptions (normally $399), plus an extra 50% off for completing 3 certificates within 3 months</li>
<li><strong><a href="https://www.datacamp.com/promo/black-friday-2022">DataCamp</a></strong> has a 50% off sale on their annual subscriptions right now as well</li>
</ul>


<p>And here&rsquo;s a Python-related service that&rsquo;s on sale (a subscription product, not a learning service):</p>

<ul>
<li><strong>Sorcery</strong>: <a href="https://sourcery.ai/pricing/">Sorcery Pro</a> is 33% off for the first 12 months with coupon <code>BLACKFRIDAY2022</code></li>
</ul>


<h2>Django sales</h2>

<p>Adam Johnson compiled many <a href="https://adamj.eu/tech/2022/11/21/django-black-friday-deals-2022/"><strong>Django-related Black Friday and Cyber Monday sales</strong></a>.</p>

<p>Here&rsquo;s a quick summary:</p>

<ul>
<li>Will Vincent is offering 50% off a bundle for newer Django developers (<a href="https://wsvincent.gumroad.com/l/bhylo/blackfriday2022">sale</a>)</li>
<li>Adam Johnson is offering 50% off his books for experienced Django developers (<a href="https://adamj.eu/tech/2022/11/21/django-black-friday-deals-2022/">announcement</a>)</li>
<li>Test Driven is selling a discounted bundle of courses on Django REST Framework, Celery, and search (<a href="https://testdriven.io/bundle/django-black-friday/">sale</a>)</li>
</ul>


<p>Plus other discounted books, apps, templates, and services from others: <a href="https://adamj.eu/tech/2022/11/21/django-black-friday-deals-2022/">read Adam&rsquo;s full post</a> for more details on the Django-related sales this year.</p>

<h2>Possible sales that aren&rsquo;t (yet) announced</h2>

<p>I&rsquo;m watching out for sales from these folks as well and will update this post with more details if/when more sales are announced:</p>

<ul>
<li><strong>Talk Python</strong>: Michael Kennedy usually offers all his courses in one $250 bundle each year (<a href="http://talkpython.fm/black-friday">this link <em>should</em> point to the sale on Friday</a>)</li>
<li><strong>Matt Harrison</strong>: Matt often offers a sale on his books and courses (<a href="https://store.metasnake.com">check his store here</a>)</li>
<li><strong>PyBites</strong>: Bob and Julian at <a href="https://pybit.es">PyBites</a> often offer a sale</li>
<li><strong>No Starch</strong>: <a href="https://nostarch.com/catalog/python">No Starch</a> usually holds a sale on their books, including many popular Python</li>
</ul>


<p>I&rsquo;ll update the above links as more sales are announced.</p>

<h2>Go get yourself some deals!</h2>

<p>Go hop on those sales! (But make sure to put an event in your calendar to actually use what you purchase. ðŸ˜‰)</p>

<p>And if you have questions about the <a href="https://trey.io/cyber-monday-sale-2022"><strong>Python Morsels Cyber Monday sale</strong></a> please comment below or <a href="mailto:he&amp;#108;p&amp;#64;&amp;#112;%7&amp;#57;th%6Fnmo&amp;#114;s%6&amp;#53;ls&amp;#46;&amp;#99;&amp;#111;m">email me</a>.</p>

<p>Happy Python-ing!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Overlooked facts about variables and objects in Python: it's all about pointers]]></title>
    <link href="https://treyhunner.com/2022/03/variables-objects-and-pointers-in-python/"/>
    <updated>2022-03-29T08:00:00-07:00</updated>
    <id>https://treyhunner.com/2022/03/variables-objects-and-pointers-in-python</id>
    <content type="html"><![CDATA[<p><em>This article was originally published <a href="https://www.pythonmorsels.com/pointers/">on Python Morsels</a>.</em></p>

<p>In Python, variables and data structures <strong>don&rsquo;t contain objects</strong>.
This fact is both commonly overlooked and tricky to internalize.</p>

<p>You can happily use Python for years without really understanding the below concepts, but this knowledge can certainly help alleviate <em>many</em> common Python gotchas.</p>

<p>Table of Contents:</p>

<ul data-toc=".entry-content"></ul>


<h2>Terminology</h2>

<p>Let&rsquo;s start with by introducing some terminology.
The last few definitions likely won&rsquo;t make sense until we define them in more detail later on.</p>

<p><strong>Object</strong> (a.k.a. <strong>value</strong>): a &ldquo;thing&rdquo;.
Lists, dictionaries, strings, numbers, tuples, functions, and modules are all objects.
&ldquo;Object&rdquo; defies definition because <a href="https://www.pythonmorsels.com/topics/everything-is-an-object/">everything is an object in Python</a>.</p>

<p><strong>Variable</strong> (a.k.a. <strong>name</strong>): a name used to refer to an object.</p>

<p><strong>Pointer</strong> (a.k.a. <strong>reference</strong>): describes where an object lives (often shown visually as an arrow)</p>

<p><strong>Equality</strong>: whether two objects represent the same data</p>

<p><strong>Identity</strong>: whether two pointers refer to the same object</p>

<p>These terms are best understood by their relationships to each other and that&rsquo;s the primarily purpose of this article.</p>

<h2>Python&rsquo;s variables are pointers, not buckets</h2>

<p>Variables in Python are not buckets containing things; they&rsquo;re <strong>pointers</strong> (they <em>point</em> to objects).</p>

<p>The word &ldquo;pointer&rdquo; may sound scary, but a lot of that scariness comes from related concepts (e.g. dereferencing) which aren&rsquo;t relevant in Python.
In Python a pointer just represents <strong>the connection between a variable and an objects</strong>.</p>

<p>Imagine <strong>variables</strong> living in <em>variable land</em> and <strong>objects</strong> living in <em>object land</em>.
A <strong>pointer</strong> is a little arrow that connects each variable to the object it <strong>points to</strong>.</p>

<p><img class="&ldquo;no-radius full-width&rdquo;" src="/images/variable-diagram-different-values.svg" title="Diagram showing variables on the left and objects on the right, with arrows between each. The numbers variable points to a list. The numbers2 variable points to a separate list. The name variable points to a string." ></p>

<p>This above diagram represents the state of our Python process after running this code:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; numbers2 = [11, 18, 29]
&gt;&gt;&gt; name = "Trey"
</code></pre>

<p>If the word <strong>pointer</strong> scares you, use the word <strong>reference</strong> instead.
Whenever you see pointer-based phrases in this article, do a mental translation to a reference-based phrase:</p>

<ul>
<li><strong>pointer</strong> &rArr; <strong>reference</strong></li>
<li><strong>point to</strong> &rArr; <strong>refer to</strong></li>
<li><strong>pointed to</strong> &rArr; <strong>referenced</strong></li>
<li><strong>point X to Y</strong> &rArr; <strong>cause X to refer to Y</strong></li>
</ul>


<h2>Assignments point a variable to an object</h2>

<p>Assignment statements point a variable to an object.
That&rsquo;s it.</p>

<p>If we run this code:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; numbers2 = numbers
&gt;&gt;&gt; name = "Trey"
</code></pre>

<p>The state of our variables and objects would look like this:</p>

<p><img class="&ldquo;no-radius full-width&rdquo;" src="/images/variable-diagram-same-value.svg" title="Diagram showing variables on the left and objects on the right, with arrows between each. The numbers and numbers2 variables have arrows coming out of them pointing to the same list. The name variable points to a string." ></p>

<p>Note that <code>numbers</code> and <code>numbers2</code> <strong>point to the same object</strong>.
If we <em>change</em> that object, both variables will seem to &ldquo;see&rdquo; that change:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers.pop()
7
&gt;&gt;&gt; numbers
[2, 1, 3, 4]
&gt;&gt;&gt; numbers2
[2, 1, 3, 4]
</code></pre>

<p>That strangeness was all due to this assignment statement:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers2 = numbers
</code></pre>

<p>Assignment statements don&rsquo;t copy anything: they just point a variable to an object.
So assigning one variable to another variable just <strong>points two variables to the same object</strong>.</p>

<h2>The 2 types of &ldquo;change&rdquo; in Python</h2>

<p>Python has 2 distinct types of &ldquo;change&rdquo;:</p>

<ol>
<li><strong>Assignment</strong> changes a variable (it changes <em>which</em> object it points to)</li>
<li><strong>Mutation</strong> changes an object (which any number of variables might point to)</li>
</ol>


<p>The word &ldquo;change&rdquo; is often ambiguous.
The phrase &ldquo;we changed <code>x</code>&rdquo; could mean &ldquo;we re-assigned <code>x</code>&rdquo; or it might mean &ldquo;we mutated the object <code>x</code> points to&rdquo;.</p>

<p><strong>Mutations change objects</strong>, not variables.
But variables <em>point to</em> objects.
So if another variable points to an object that <em>we&rsquo;ve just mutated</em>, that other variable will reflect the same change; not because the variable changed but because <strong>the object it points to</strong> changed.</p>

<h2>Equality compares objects and identity compares pointers</h2>

<p>Python&rsquo;s <code>==</code> operator checks that two objects <strong>represent the same data</strong> (a.k.a. <strong>equality</strong>):</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers = [2, 1, 3, 4]
&gt;&gt;&gt; your_numbers = [2, 1, 3, 4]
&gt;&gt;&gt; my_numbers == your_numbers
True
</code></pre>

<p>Python&rsquo;s <code>is</code> operator checks whether two objects <strong>are the same object</strong> (a.k.a. <strong>identity</strong>):</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers is your_numbers
False
</code></pre>

<p>The variables <code>my_numbers</code> and <code>your_numbers</code> point to <strong>objects representing the same data</strong>, but the objects they point to <strong>are not the same object</strong>.</p>

<p>So changing one object doesn&rsquo;t change the other:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers[0] = 7
&gt;&gt;&gt; my_numbers == your_numbers
False
</code></pre>

<p>If two variables point to the same object:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers_again = my_numbers
&gt;&gt;&gt; my_numbers is my_numbers_again
True
</code></pre>

<p>Changing the object one variable points also changes the object the other points to because they both point to the same object:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers_again.append(7)
&gt;&gt;&gt; my_numbers_again
[2, 1, 3, 4, 7]
&gt;&gt;&gt; my_numbers
[2, 1, 3, 4, 7]
</code></pre>

<p>The <code>==</code> operator checks for <strong>equality</strong> and the <code>is</code> operator checks for <strong>identity</strong>.
This distinction between identity and equality exists because variables <strong>don&rsquo;t contain objects</strong>, they <strong>point to objects</strong>.</p>

<p>In Python equality checks are very common and <a href="https://www.pythonmorsels.com/topics/equality-vs-identity/">identity checks are very rare</a>.</p>

<h2>There&rsquo;s no exception for immutable objects</h2>

<p>But wait, modifying a number <em>doesn&rsquo;t</em> change other variables pointing to the same number, right?</p>

<pre><code class="pycon">&gt;&gt;&gt; n = 3
&gt;&gt;&gt; m = n  # n and m point to the same number
&gt;&gt;&gt; n += 2
&gt;&gt;&gt; n  # n has changed
5
&gt;&gt;&gt; m  # but m hasn't changed!
3
</code></pre>

<p>Well, <strong>modifying a number is not possible</strong> in Python.
Numbers and strings are both <strong>immutable</strong>, meaning you can&rsquo;t mutate them.
You <strong>cannot change</strong> an immutable object.</p>

<p>So what about that <code>+=</code> operator above?
Didn&rsquo;t that mutate a number?
(It didn&rsquo;t.)</p>

<p>With immutable objects, these two statements are equivalent:</p>

<pre><code class="pycon">&gt;&gt;&gt; n += 2
&gt;&gt;&gt; n = n + 2
</code></pre>

<p>For immutable objects, augmented assignments (<code>+=</code>, <code>*=</code>, <code>%=</code>, etc.) perform an operation (which returns a new object) and then do an assignment (to that new object).</p>

<p>Any operation you might <em>think</em> changes a string or a number instead returns a new object.
Any operation on an immutable object always <strong>returns a new object</strong> instead of modifying the original.</p>

<h2>Data structures contain pointers</h2>

<p>Like variables, data structures <strong>don&rsquo;t contain objects</strong>, they <strong>contain pointers to objects</strong>.</p>

<p>Let&rsquo;s say we make a list-of-lists:</p>

<pre><code class="pycon">&gt;&gt;&gt; matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>

<p>And then we make a variable pointing to the second list in our list-of-lists:</p>

<pre><code class="pycon">&gt;&gt;&gt; row = matrix[1]
&gt;&gt;&gt; row
[4, 5, 6]
</code></pre>

<p>The state of our variables and objects now looks like this:</p>

<p><img class="&ldquo;no-radius full-width&rdquo;" src="/images/data-structures-diagram.svg" title="Diagram showing matrix variable which points to a list of 3 items. Each item has an arrow coming out of it, pointing to a separate list. Each of these sublists has 3 elements which each point to a separate integer object. There&rsquo;s also a row variable which points to a list that&rsquo;s also pointed to by index 1 of the matrix list." ></p>

<p>Our <code>row</code> variable <strong>points to the same object</strong> as index <code>1</code> in our <code>matrix</code> list:</p>

<pre><code class="pycon">&gt;&gt;&gt; row is matrix[1]
True
</code></pre>

<p>So if we mutate the list that <code>row</code> points to:</p>

<pre><code class="pycon">&gt;&gt;&gt; row[0] = 1000
</code></pre>

<p>We&rsquo;ll see that change in both places:</p>

<pre><code class="pycon">&gt;&gt;&gt; row
[1000, 5, 6]
&gt;&gt;&gt; matrix
[[1, 2, 3], [1000, 5, 6], [7, 8, 9]]
</code></pre>

<p>It&rsquo;s common to speak of data structures &ldquo;containing&rdquo; objects, but they actually only contain pointers to objects.</p>

<h2>Function arguments act like assignment statements</h2>

<p>Function calls also perform assignments.</p>

<p>If you mutate an object that was passed-in to your function, you&rsquo;ve mutated the original object:</p>

<pre><code class="pycon">&gt;&gt;&gt; def smallest_n(items, n):
...     items.sort()  # This mutates the list (it sorts in-place)
...     return items[:n]
...
&gt;&gt;&gt; numbers = [29, 7, 1, 4, 11, 18, 2]
&gt;&gt;&gt; smallest_n(numbers, 4)
[1, 2, 4, 7]
&gt;&gt;&gt; numbers
[1, 2, 4, 7, 11, 18, 29]
</code></pre>

<p>But if you reassign a variable to a different object, the original object will not change:</p>

<pre><code class="pycon">&gt;&gt;&gt; def smallest_n(items, n):
...     items = sorted(items)  # this makes a new list (original is unchanged)
...     return items[:n]
...
&gt;&gt;&gt; numbers = [29, 7, 1, 4, 11, 18, 2]
&gt;&gt;&gt; smallest_n(numbers, 4)
[1, 2, 4, 7]
&gt;&gt;&gt; numbers
[29, 7, 1, 4, 11, 18, 2]
</code></pre>

<p>We&rsquo;re reassigning the <code>items</code> variable here.
That reassignment changes <em>which</em> object the <code>items</code> variable points to, but it doesn&rsquo;t change the original object.</p>

<p>We <strong>changed an object</strong> in the first case and we <strong>changed a variable</strong> in the second case.</p>

<p>Here&rsquo;s another example you&rsquo;ll sometimes see:</p>

<pre><code class="python">class Widget:
    def __init__(self, attrs=(), choices=()):
        self.attrs = list(attrs)
        self.choices = list(choices)
</code></pre>

<p>Class <a href="https://www.pythonmorsels.com/topics/what-is-init/">initializer methods</a> often copy iterables given to them by making a new list out of their items.
This allows the class to accept any iterable (not just lists) and decouples the original iterable from the class (modifying these lists won&rsquo;t upset the original caller).
The above example was <a href="https://github.com/django/django/blob/4.0.2/django/forms/widgets.py#L560,L565">borrowed from Django</a>.</p>

<p><strong>Don&rsquo;t mutate the objects</strong> passed-in to your function unless the function caller expects you to.</p>

<h2>Copies are shallow and that&rsquo;s usually okay</h2>

<p>Need to copy a list in Python?</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2000, 1000, 3000]
</code></pre>

<p>You could call the <code>copy</code> method (if you&rsquo;re certain your iterable is a list):</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers = numbers.copy()
</code></pre>

<p>Or you could pass it to the <code>list</code> constructor (this works on <strong>any iterable</strong>):</p>

<pre><code class="pycon">&gt;&gt;&gt; my_numbers = list(numbers)
</code></pre>

<p>Both of these techniques make a new list which <strong>points to the same objects</strong> as the original list.</p>

<p>The two lists are distinct, but the objects within them are the same:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers is my_numbers
False
&gt;&gt;&gt; numbers[0] is my_numbers[0]
True
</code></pre>

<p>Since integers (and all numbers) are immutable in Python we don&rsquo;t really care that each list contains the same objects because we can&rsquo;t mutate those objects anyway.</p>

<p>With mutable objects, this distinction matters.
This makes two list-of-lists which each contain pointers to the same three lists:</p>

<pre><code class="pycon">&gt;&gt;&gt; matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; new_matrix = list(matrix)
</code></pre>

<p>These two lists aren&rsquo;t the same, but each item within them is the same:</p>

<pre><code class="pycon">&gt;&gt;&gt; matrix is new_matrix
False
&gt;&gt;&gt; matrix[0] is new_matrix[0]
True
</code></pre>

<p>Here&rsquo;s a rather complex visual representation of these two objects and the pointers they contain:</p>

<p><img class="&ldquo;no-radius full-width&rdquo;" src="/images/data-structures-same-pointers-diagram.svg" title="Diagram showing matrix variable which points to a list of 3 items and a new_matrix variable which points to a separate list of 3 items. Each corresponding item in each of these matrix and new_matrix lists points to the same sublist." ></p>

<p>So if we mutate the first item in one list, it&rsquo;ll mutate the same item within the other list:</p>

<pre><code class="pycon">&gt;&gt;&gt; matrix[0].append(100)
&gt;&gt;&gt; matrix
[[1, 2, 3, 100], [4, 5, 6], [7, 8, 9]]
&gt;&gt;&gt; new_matrix
[[1, 2, 3, 100], [4, 5, 6], [7, 8, 9]]
</code></pre>

<p>When you copy an object in Python, if that object <strong>points to other objects</strong>, you&rsquo;ll copy pointers to those other objects instead of copying the objects themselves.</p>

<p>New Python programmers respond to this behavior by sprinkling <code>copy.deepcopy</code> into their code.
The <code>deepcopy</code> function attempts to recursively copy an object along with all objects it points to.</p>

<p>Sometimes new Python programmers will use <code>deepcopy</code> to recursively copy data structures:</p>

<pre><code class="python">from copy import deepcopy
from datetime import datetime

tweet_data = [{"date": "Feb 04 2014", "text": "Hi Twitter"}, {"date": "Apr 16 2014", "text": "At #pycon2014"}]

# Parse date strings into datetime objects
processed_data = deepcopy(tweet_data)
for tweet in processed_data:
    tweet["date"] = datetime.strptime(tweet["date"], "%b %d %Y")
</code></pre>

<p>But in Python, we often prefer to make new objects instead of mutating existing objects.
So we could entirely remove that <code>deepcopy</code> usage above by making a new list of new dictionaries instead of deep-copying our old list-of-dictionaries.</p>

<pre><code class="python"># Parse date strings into datetime objects
processed_data = [
    {**tweet, "date": datetime.strptime(tweet["date"], "%b %d %Y")}
    for tweet in tweet_data
]
</code></pre>

<p>We tend to prefer shallow copies in Python.
If you <strong>don&rsquo;t mutate objects that don&rsquo;t belong to you</strong> you usually won&rsquo;t have any need for <code>deepcopy</code>.</p>

<p>The <code>deepcopy</code> function certainly has its uses, but it&rsquo;s often unnecessary.
&ldquo;How to avoid using <code>deepcopy</code>&rdquo; warrants a separate discussion in a future article.</p>

<h2>Summary</h2>

<p>Variables in Python are not buckets containing things; they&rsquo;re <strong>pointers</strong> (they <em>point</em> to objects).</p>

<p>Python&rsquo;s model of variables and objects boils down to two primary rules:</p>

<ol>
<li><strong>Mutation</strong> changes an object</li>
<li><strong>Assignment</strong> points a variable to an object</li>
</ol>


<p>As well as these corollary rules:</p>

<ol>
<li><strong>Reassigning</strong> a variable points it to <strong>a different object</strong>, leaving the original object unchanged</li>
<li><strong>Assignments don&rsquo;t copy</strong> anything, so it&rsquo;s up to you to copy objects as needed</li>
</ol>


<p>Furthermore, data structures work the same way: lists and dictionaries container <strong>pointers to objects</strong> rather than the objects themselves.
And attributes work the same way: <strong>attributes point to objects</strong> (just like any variable points to an object).
So <strong>objects cannot contain objects in Python</strong> (they can only <em>point to</em> objects).</p>

<p>And note that while <strong>mutations change objects</strong> (not variables), multiple variables <em>can</em> point to the same object.
If two variables point to the same object changes to that object will be seen when accessing either variable (because they both point to <em>the same</em> object).</p>

<p>For more on this topic see:</p>

<ul>
<li>My <a href="https://www.pythonmorsels.com/topics/playlist/assignment-and-mutation/">screencast series on Assignments and Mutation in Python</a></li>
<li>Ned Batchelder&rsquo;s <a href="https://nedbatchelder.com/text/names1.html">Python Names and Values</a> talk</li>
<li>Brandon Rhodes' <a href="https://pyvideo.org/pyohio-2011/pyohio-2011-names-objects-and-plummeting-from.html">Names, Objects, and Plummeting From The Cliff</a> talk</li>
</ul>


<p>This mental model of Python is tricky to internalize so it&rsquo;s okay if it still feels confusing!
Python&rsquo;s features and best practices <em>often</em> nudge us toward &ldquo;doing the right thing&rdquo; automatically.
But if your code is acting strangely, it might be due to changing an object you didn&rsquo;t mean to change.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Black Friday &amp; Cyber Monday Sales (2021)]]></title>
    <link href="https://treyhunner.com/2021/11/python-black-friday-and-cyber-monday-sales-2021/"/>
    <updated>2021-11-22T21:00:00-08:00</updated>
    <id>https://treyhunner.com/2021/11/python-black-friday-and-cyber-monday-sales-2021</id>
    <content type="html"><![CDATA[<p>This is my annual compilation post of Black Friday and Cyber Monday deals I&rsquo;ve found related to <strong>Python and Python learning</strong>.</p>

<p><strong>Note</strong>: Some sales likely aren&rsquo;t announced yet, so I will update this post on Black Friday and Cyber Monday.</p>

<h3>50% off dozens of Python screencasts (Python Morsels)</h3>

<p>Yes, the self-promotion comes first.</p>

<p>The Python Morsels Lite plan has evolved <em>a lot</em> since I first launched it and it&rsquo;s long overdue for a price increase.
This plan includes access to <strong>over 90 Python screencasts</strong> (a new one added each week) as well as a <strong>monthly Python exercise</strong> (your choice from novice to advanced Python).</p>

<p>From December 1, 2021 onward the price for the Python Morsels Lite plan will be $10/month or $100/year.
Until November 30, you can signup for <strong>$5/month</strong> or <strong>$50/year</strong> (and you&rsquo;ll lock-in that price for as long as you&rsquo;re subscribed).
This is the lowest price I&rsquo;ll ever offer this plan for.</p>

<p><strong>Save 50%</strong> on <a href="https://www.pythonmorsels.com/watch-python-screencasts/">the Python Morsels Lite plan</a> by signing up from now until Cyber Monday.</p>

<p><a href="https://www.pythonmorsels.com/watch-python-screencasts/">Get the Python Morsels Lite plan for just $50/year</a></p>

<h3>Reuven Lerner&rsquo;s Python courses and Weekly Python Exercise</h3>

<p>Reuven Lerner is offering <a href="https://store.lerner.co.il/?coupon=BF2021">30% off all his products</a> (intro Python bundle, advanced Python bundle, data analytics bundle, and Weekly Python Exercises, and more) through Monday.
Enter the coupon BF2021 if needed (though that link should apply the coupon already).</p>

<p>If you like Python Morsels, you might want to check out Reuven&rsquo;s Weekly Python exercise as well.
Both are based around exercise-driven learning.</p>

<h3>Matt Harrison&rsquo;s books and courses on Python, data science, and Pandas</h3>

<p>Matt Harrison is offering a 40% discount on all his courses and books (on Python, Pandas, and data science).
See his <a href="https://store.metasnake.com/?coupon=BF40">MetaSnake store</a> for more details.
Enter coupon code BF40 if needed (though the coupon code should already be applied when you click that link).</p>

<h3>Python Essentials for Data Scientists (Kevin Markham of Data School)</h3>

<p>Kevin Markham is offering 33% off his new course, <a href="https://courses.dataschool.io/python-essentials-for-data-scientists?coupon=BLACKFRIDAY">Python Essentials for Data Scientists</a>.
The course will be $33 instead of $49 from Black Friday through Cyber Monday.
The BLACKFRIDAY coupon is already applied from that link, but you&rsquo;ll need to wait until Friday (when enrollment to officially opens) to hit the Buy button.</p>

<h3>Talk Python course bundle</h3>

<p>You can get every Talk Python course that&rsquo;s been made so far <a href="http://talkpython.fm/black-friday">for just $250</a> (or less if you&rsquo;ve bought previous bundles).
There&rsquo;s 34 courses currently and the bundle also includes courses published before October 2022.</p>

<h3>PyBites books, courses, and Python exercises</h3>

<p>PyBites is offering 40% off Python courses, books, and exercises in their <a href="https://pybit.es/black-friday-2021/">Black Friday and Cyber Monday sale</a>.</p>

<h3>Mike Driscoll&rsquo;s Python books</h3>

<p>Mike Driscoll is offering $10 off any of his <a href="https://driscollis.gumroad.com/">Python books</a> with the coupon code <strong>black21</strong>.
Remember to apply that coupon code (it&rsquo;s not auto-applied in that link).</p>

<h3>Brian Okken&rsquo;s Pytest book (Pragmatic Bookshelf)</h3>

<p>Pragmatic Bookshelf is offering 40% off all books with the code <strong>turkeysale2021</strong>, including <a href="https://pragprog.com/titles/bopytest2/python-testing-with-pytest-second-edition/"><strong>Brian Okken&rsquo;s Pytest book</strong></a> which is just under $15 with the coupon.</p>

<h3>Learning Python By Example</h3>

<p>Sundeep Agarwal is offering his <a href="https://learnbyexample.gumroad.com/l/py_projects/blackfriday">Practice Python Projects</a> for free this week (normally $10) as well as a <a href="https://learnbyexample.gumroad.com/l/python-bundle/blackfriday">Learn by example Python bundle</a> (which includes Practice Python Projects) for $2 (normally $12).</p>

<h3>Python Problem-Solving Bootcamp</h3>

<p>Rodrigo of Mathspp is offering 40% off his <a href="https://mathspp.gumroad.com/l/pythonbootcamp/blackfriday">Python Problem-Solving Bootcamp</a> which involves a community that will be solving Advent of Code 2021 exercises together during December 2021 as well as Jupyter notebooks and an eBook of analysis around the challenges.</p>

<h3>Django-specific sales</h3>

<p>Adam Johnson&rsquo;s Speed Up Your Django Tests is <a href="https://adamchainz.gumroad.com/l/suydt">on sale for 50% off</a> (it&rsquo;s normally $49).
If you&rsquo;re using Django and writing automated tests (you should be!) check out Adam&rsquo;s book.</p>

<p>Will Vincent is also offering a 50% discount on his Django books, via <a href="https://wsvincent.gumroad.com/l/bhylo/blackfriday2021">a 3 book bundle</a>.
Each of Will&rsquo;s Django books is normally $40, but during his Black Friday sale you can get all 3 books for $59.</p>

<p>Test Driven is offering a 25% discount on a <a href="https://testdriven.io/bundle/django-black-friday/">3 Django course bundle</a> from Michael Herman and friends.
You can get three $30 courses for just $68 in total.</p>

<p>Check out Adam Johnson&rsquo;s <a href="https://adamj.eu/tech/2021/11/22/django-black-friday-deals/">Django-related deals for Black Friday and Cyber Monday</a> post for more Django-related deals.</p>

<h3>More Sales To Watch Out For</h3>

<p><strong>No Starch</strong> press often offers Black Friday discounts on lots of <a href="https://nostarch.com/catalog/python">Python books</a> (Al Sweigart, Eric Mathes, and more).</p>

<h3>Lots of screencasts, exercises, books, and courses on sale</h3>

<p>This blog post is not up-to-date yet.
<strong>Check back on Black Friday</strong> for more Python-related sales as I hear about them (and feel free to comment below if you find more).</p>

<p>Also don&rsquo;t go too wild on sales!
If you don&rsquo;t have time to work through a Python course, don&rsquo;t buy it.
If you&rsquo;re unlikely to ever read that Python book, don&rsquo;t get it.
And if you can&rsquo;t commit to weekly Python learning, don&rsquo;t subscribe!</p>

<p>Consider picking a few things that look like you&rsquo;ll actually use them, and buy them.
Python educators love your support, but we also like happy customers who use and love our services.</p>

<p>Also if you have money to spend but nothing to spend it on (that&rsquo;s a great problem to have&hellip;), do as Python educator <a href="https://twitter.com/AllenDowney/status/1462856493716459526">Allen Downey suggested</a> and <strong>donate to charity</strong>.
You could <a href="https://psfmember.org/">become a PSF member</a> or give to highly effective charities via <a href="https://www.givewell.org/">GiveWell</a> or <a href="https://www.thelifeyoucansave.org/">The Life You Can Save</a>.</p>

<p>If you have a question about <a href="https://www.pythonmorsels.com/watch-python-screencasts/">the Python Morsels sale</a> please <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a>.
If you have a question about the other sales, reach out to the folks running it.</p>

<p>Happy coding!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to sort a dictionary in Python]]></title>
    <link href="https://treyhunner.com/2021/11/how-to-sort-a-dictionary-in-python/"/>
    <updated>2021-11-17T07:30:00-08:00</updated>
    <id>https://treyhunner.com/2021/11/how-to-sort-a-dictionary-in-python</id>
    <content type="html"><![CDATA[<p>Dictionaries are best used for key-value lookups: <strong>we provide a key</strong> and the dictionary <em>very</em> quickly <strong>returns the corresponding value</strong>.</p>

<p>But what if you need both key-value lookups and iteration?
It is possible to loop over a dictionary and when looping, we <em>might</em> care about <strong>the order of the items</strong> in the dictionary.</p>

<p>With dictionary item order in mind, you might wonder how can we <em>sort</em> a dictionary?</p>

<h3>Dictionaries are ordered</h3>

<p>As of Python 3.6 dictionaries are <strong>ordered</strong> (technically the ordering <a href="https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights">became official in 3.7</a>).</p>

<p>Dictionary keys are stored in <strong>insertion order</strong>, meaning whenever a new key is added it gets added at the very end.</p>

<pre><code class="pycon">&gt;&gt;&gt; color_amounts = {"purple": 6, "green": 3, "blue": 2}
&gt;&gt;&gt; color_amounts["pink"] = 4
&gt;&gt;&gt; color_amounts
{'purple': 6, 'green': 3, 'blue': 2, 'pink': 4}
</code></pre>

<p>But if we update a key-value pair, the key remains where it was before:</p>

<pre><code class="pycon">&gt;&gt;&gt; color_amounts["green"] = 5
&gt;&gt;&gt; color_amounts
{'purple': 6, 'green': 5, 'blue': 2, 'pink': 4}
</code></pre>

<p>So if you plan to populate a dictionary with some specific data and then leave that dictionary as-is, all you need to do is make sure that original data is in the order you&rsquo;d like.</p>

<p>For example if we have a CSV file of US state abbreviations and our file is ordered alphabetically by state name, our dictionary will be ordered the same way:</p>

<pre><code class="pycon">&gt;&gt;&gt; import csv
&gt;&gt;&gt; state_abbreviations = {}
&gt;&gt;&gt; for name, abbreviation in csv.reader("state-abbreviations.csv")
...     state_abbreviations[name] = abbreviation
...
&gt;&gt;&gt; state_abbreviations
{'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA', ...}
</code></pre>

<p>If our input data is already ordered correctly, our dictionary will end up ordered correctly as well.</p>

<h3>How to sort a dictionary by its keys</h3>

<p>What if our data isn&rsquo;t sorted yet?</p>

<p>Say we have a dictionary that mapps meeting rooms to their corresponding room numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
</code></pre>

<p>And we&rsquo;d like to sort this dictionary by its keys.</p>

<p>We could use the <code>items</code> method on our dictionary to get iterables of key-value tuples and then use the <code>sorted</code> function to sort these tuples:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms.items()
dict_items([('Pink', 'Rm 403'), ('Space', 'Rm 201'), ('Quail', 'Rm 500'), ('Lime', 'Rm 503')])
&gt;&gt;&gt; sorted(rooms.items())
[('Lime', 'Rm 503'), ('Pink', 'Rm 403'), ('Quail', 'Rm 500'), ('Space', 'Rm 201')]
</code></pre>

<p>The <code>sorted</code> function uses the <code>&lt;</code> operator to compare many items in the given iterable and return a sorted list.
The <code>sorted</code> function always returns a list.</p>

<p>To make these key-value pairs into a dictionary, we can pass them straight to the <code>dict</code> constructor:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items()))
&gt;&gt;&gt; sorted_rooms
{'Lime': 'Rm 503', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Space': 'Rm 201'}
</code></pre>

<p>The <code>dict</code> constructor will accept a list of 2-item tuples (or any iterable of 2-item iterables) and make a dictionary out of it, using the first item from each tuple as a key and the second as the corresponding value.</p>

<h3>Key-value pairs are sorted lexicographically&hellip; what?</h3>

<p>We&rsquo;re sorting tuples of the key-value pairs before making a dictionary out of them.
But how does sorting tuples work?</p>

<pre><code class="pycon">&gt;&gt;&gt; some_tuples = [(1, 3), (3, 1), (1, 9), (0, 3)]
&gt;&gt;&gt; sorted(some_tuples)
[(0, 3), (1, 3), (1, 9), (3, 1)]
</code></pre>

<p>When sorting tuples, Python uses lexicographical ordering (which sounds fancier than it is).
Comparing a 2-item tuple basically boils down to this algorithm:</p>

<pre><code class="python">def compare_two_item_tuples(a, b):
    """This is the same as a &lt; b for two 2-item tuples."""
    if a[0] != b[0]:  # If the first item of each tuple is unequal
        return a[0] &lt; b[0]  # Compare the first item from each tuple
    else:
        return a[1] &lt; b[1]  # Compare the second item from each tuple
</code></pre>

<p>I&rsquo;ve written <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/">an article on tuple ordering</a> that explains this in more detail.</p>

<p>You might be thinking: <strong>it seems like this sorts not just by keys but by keys <em>and</em> values</strong>.
And you&rsquo;re right!
But only sort of.</p>

<p>The keys in a dictionary <em>should</em> always compare as unequal (if two keys are equal, they&rsquo;re seen as <em>the same key</em>).
So as long as the keys are comparable to each other with the less than operator (<code>&lt;</code>), sorting 2-item tuples of key-value pairs should always sort by the keys.</p>

<h3>Dictionaries can&rsquo;t be sorted in-place</h3>

<p>What if we already have our items <em>in</em> a dictionary and we&rsquo;d like to sort that dictionary?
Unlike lists, <strong>there&rsquo;s no <code>sort</code> method on dictionaries</strong>.</p>

<p>We can&rsquo;t sort a dictionary in-place, but we could get the items from our dictionary, sort those items using the same technique we used before, and then turn those items into a new dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items()))
&gt;&gt;&gt; sorted_rooms
{'Lime': 'Rm 503', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Space': 'Rm 201'}
</code></pre>

<p>That creates a new dictionary object.
If we <em>really</em> wanted to update our original dictionary object, we could take the items from the dictionary, sort them, clear the dictionary of all its items, and then add all the items back into the dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; old_dictionary = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
&gt;&gt;&gt; sorted_items = sorted(old_dictionary.items())
&gt;&gt;&gt; old_dictionary.clear()
&gt;&gt;&gt; old_dictionary.update(sorted_items)
</code></pre>

<p>But why bother?
We don&rsquo;t usually <em>want</em> to operate on data structures in-place in Python: we tend to prefer making a new data structure rather than re-using an old one (this preference is partly thanks to <a href="https://www.pythonmorsels.com/topics/variables-are-pointers/">how variables work in Python</a>).</p>

<h3>How to sort a dictionary by its values</h3>

<p>What if we wanted to sort a dictionary by its values instead of its keys?</p>

<p>We could make a new list of value-key tuples (actually a generator in our case below), sort that, then flip them back to key-value tuples and recreate our dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
&gt;&gt;&gt; room_to_name = sorted((room, name) for (name, room) in rooms.items())
&gt;&gt;&gt; sorted_rooms = {
...     name: room
...     for room, name in room_to_name
... }
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>This works but it&rsquo;s a bit long.
Also this technique actually sorts both our values and our keys (giving the values precedence in the sorting).</p>

<p>What if we wanted to <em>just</em> sort our dictionary by its values, ignoring the contents of the keys entirely?
Python&rsquo;s <code>sorted</code> function accepts a <code>key</code> argument that we can use for this!</p>

<pre><code class="pycon">&gt;&gt;&gt; help(sorted)
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.

    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.
</code></pre>

<p>The key function we pass to sorted should accept an item from the iterable we&rsquo;re sorting and return the <em>key</em> to sort by.
Note that the word &ldquo;key&rdquo; here isn&rsquo;t related to dictionary keys.
Dictionary keys are used for looking up dictionary values whereas this key function returns an object that determines how to order items in an iterable.</p>

<p>If we want to sort the dictionary by its values, we could make a key function that accepts each item in our list of 2-item tuples and <strong>returns just the value</strong>:</p>

<pre><code class="python">def value_from_item(item):
    """Return just the value from a given (key, value) tuple."""
    key, value = item
    return value
</code></pre>

<p>Then we&rsquo;d use our key function by passing it to the <code>sorted</code> function (yes <a href="https://treyhunner.com/2020/01/passing-functions-as-arguments/">functions can be passed to other functions in Python</a>) and pass the result to <code>dict</code> to create a new dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=value_from_item))
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>If you prefer not to create a custom key function just to use it once, you could use a lambda function (which I <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/">don&rsquo;t usually recommend</a>):</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=lambda item: item[1]))
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>Or you could use <code>operator.itemgetter</code> to make a key function that gets the second item from each key-value tuple:</p>

<pre><code class="pycon">&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=itemgetter(1)))
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>I discussed my preference for <code>itemgetter</code> <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/#Overuse:_using_lambda_for_very_simple_operations">in my article on lambda functions</a>.</p>

<h3>Ordering a dictionary in some other way</h3>

<p>What if we needed to sort our dictionary by something other than just a key or a value?
For example what if our room number strings include numbers that aren&rsquo;t always the same length:</p>

<pre><code class="python">rooms = {
    "Pink": "Rm 403",
    "Space": "Rm 201",
    "Quail": "Rm 500",
    "Lime": "Rm 503",
    "Ocean": "Rm 2000",
    "Big": "Rm 30",
}
</code></pre>

<p>If we sorted these rooms by value, those strings wouldn&rsquo;t be sorted in the numerical way we&rsquo;re hoping for:</p>

<pre><code class="pycon">&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=itemgetter(1)))
&gt;&gt;&gt; sorted_rooms
{'Ocean': 'Rm 2000', 'Space': 'Rm 201', 'Big': 'Rm 30', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p><strong>Rm 30</strong> should be first and <strong>Rm 2000</strong> should be last.
But we&rsquo;re sorting strings, which are ordered character-by-character based on the unicode value of each character (I <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/#String_comparisons_in_Python">noted this</a> in my article on tuple ordering).</p>

<p>We could customize the <code>key</code> function we&rsquo;re using to sort numerically instead:</p>

<pre><code class="python">def by_room_number(item):
    """Return numerical room given a (name, room_number) tuple."""
    name, room = item
    _, number = room.split()
    return int(number)
</code></pre>

<p>When we use this key function to sort our dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=by_room_number))
</code></pre>

<p>It will be sorted by the integer room number, as expected:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms
{'Big': 'Rm 30', 'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503', 'Ocean': 'Rm 2000'}
</code></pre>

<h3>Should you sort a dictionary?</h3>

<p>When you&rsquo;re about to sort a dictionary, first ask yourself &ldquo;do I need to do this&rdquo;?
In fact, when you&rsquo;re considering looping over a dictionary you might ask &ldquo;do I really need a dictionary here&rdquo;?</p>

<p>Dictionaries are used for key-value lookups: you can quickly get a value given a key.
They&rsquo;re very fast at retrieving values for keys.
But dictionaries take up more space than a list of tuples.</p>

<p>If you can get away with using a list of tuples in your code (because you don&rsquo;t actually need a key-value lookup), you probably <em>should</em> use a list of tuples instead of a dictionary.</p>

<p>But if key lookups are what you need, it&rsquo;s unlikely that you also need to loop over your dictionary.</p>

<p>Now it&rsquo;s certainly possible that right now you do in fact have a good use case for sorting a dictionary (for example maybe you&rsquo;re <a href="https://gist.github.com/treyhunner/7adcbc96870b79642f1754c3cc602ac6">sorting keys in a dictionary of attributes</a>), but keep in mind that you&rsquo;ll need to sort a dictionary <strong>very rarely</strong>.</p>

<h3>Summary</h3>

<p>Dictionaries are used for quickly looking up a value based on a key.
The <em>order</em> of a dictionary&rsquo;s items is rarely important.</p>

<p>In the rare case that you care about the order of your dictionary&rsquo;s items, keep in mind that dictionaries are ordered by the <em>insertion order</em> of their keys (as of Python 3.6).
So the keys in your dictionary will remain in the order they were added to the dictionary.</p>

<p>If you&rsquo;d like to sort a dictionary by its keys, you can use the built-in <code>sorted</code> function along with the <code>dict</code> constructor:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_dictionary = dict(sorted(old_dictionary.items()))
</code></pre>

<p>If you&rsquo;d like to sort a dictionary by its values, you can pass a custom <code>key</code> function (one which returns the value for each item) to <code>sorted</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; def value_from_item(item):
...     key, value = item
...     return value
...
&gt;&gt;&gt; sorted_dictionary = dict(sorted(old_dictionary.items(), key=value_from_item))
</code></pre>

<p>But remember, it&rsquo;s not often that we care about the order of a dictionary.
Whenever you&rsquo;re sorting a dictionary, please remember to ask yourself <strong>do I really need to sort this data structure</strong> and <strong>would a list of tuples be more suitable than a dictionary here</strong>?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to flatten a list in Python]]></title>
    <link href="https://treyhunner.com/2021/11/how-to-flatten-a-list-in-python/"/>
    <updated>2021-11-01T08:00:00-07:00</updated>
    <id>https://treyhunner.com/2021/11/how-to-flatten-a-list-in-python</id>
    <content type="html"><![CDATA[<p>You&rsquo;ve somehow ended up with lists nested inside of lists, possibly like this one:</p>

<pre><code class="pycon">&gt;&gt;&gt; groups = [["Hong", "Ryan"], ["Anthony", "Wilhelmina"], ["Margaret", "Adrian"]]
</code></pre>

<p>But you <em>want</em> just a single list (without the nesting) like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; expected_output = ["Hong", "Ryan", "Anthony", "Wilhelmina", "Margaret", "Adrian"]
</code></pre>

<p>You need to flatten your list-of-lists.</p>

<h3>We&rsquo;re looking for a &ldquo;shallow&rdquo; flatten</h3>

<p>We can think of this as a <strong>shallow flatten</strong> operation, meaning we&rsquo;re flattening this list by one level.
A <strong>deep flatten</strong> operation would handle lists-of-lists-of-lists-of-lists (and so on) and that&rsquo;s a bit more than we need for our use case.</p>

<p>The flattening strategy we come up with should work on lists-of-lists as well as any other type of <a href="https://www.pythonmorsels.com/topics/iterable/">iterable</a>-of-iterables.
For example lists of tuples should be flattenable:</p>

<pre><code class="pycon">&gt;&gt;&gt; groups = [("Hong", "Ryan"), ("Anthony", "Wilhelmina"), ("Margaret", "Adrian")]
</code></pre>

<p>And even an odd type like a <code>dict_items</code> object (which we get from asking a dictionary for its items) should be flattenable:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruit_counts = {"apple": 3, "lime": 2, "watermelon": 1, "mandarin": 4}
&gt;&gt;&gt; fruit_counts.items()
dict_items([('apple', 3), ('lime', 2), ('watermelon', 1), ('mandarin', 4)])
&gt;&gt;&gt; flattened_counts = ['apple', 3, 'lime', 2, 'watermelon', 1, 'mandarin', 4]
</code></pre>

<h3>Flattening iterables-of-iterables with a <code>for</code> loop</h3>

<p>One way to flatten an iterable-of-iterables is with a <code>for</code> loop.
We can loop one level deep to get each of the inner iterables.</p>

<pre><code class="python">for group in groups:
    ...
</code></pre>

<p>And then we loop a second level deep to get each item from each inner iterable.</p>

<pre><code class="python">for group in groups:
    for name in group:
        ...
</code></pre>

<p>And then append each item to a new list:</p>

<pre><code class="python">names = []
for group in groups:
    for name in group:
        names.append(name)
</code></pre>

<p>There&rsquo;s also a list method that makes this a bit shorter, the <code>extend</code> method:</p>

<pre><code class="python">names = []
for group in groups:
    names.extend(group)
</code></pre>

<p>The list <code>extend</code> method accepts an iterable and appends every item in the iterable you give to it.</p>

<p>Or we could use the <code>+=</code> operator to concatenate each list to our new list:</p>

<pre><code class="python">names = []
for group in groups:
    names += group
</code></pre>

<p>You can think of <code>+=</code> on lists as calling the <code>extend</code> method.
With lists these two operations (<code>+=</code> and <code>extend</code>) are equivalent.</p>

<h3>Flattening iterables-of-iterables with a comprehension</h3>

<p>This nested <code>for</code> loop with an <code>append</code> call might look familiar:</p>

<pre><code class="python">names = []
for group in groups:
    for name in group:
        names.append(name)
</code></pre>

<p>The structure of this code looks like something we could <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-paste into a list comprehension</a>.</p>

<p>Inside our square brackets we&rsquo;d copy the thing we&rsquo;re appending first, and then the logic for our first loop, and then the logic for our second loop:</p>

<pre><code class="python">names = [
    name
    for group in groups
    for name in group
]
</code></pre>

<p>This comprehension loops two levels deep, just like our nested <code>for</code> loops did.
Note that the order of the <code>for</code> clauses in the comprehension <strong>must remain the same as the order of the <code>for</code> loops</strong>.</p>

<p>The (sometimes confusing) order of those <code>for</code> clauses is partly why I recommend <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-pasting into a comprehension</a>.
When turning a <code>for</code> loop into a comprehension, the <code>for</code> and <code>if</code> clauses remain in the same relative place, but the thing you&rsquo;re appending moves from the end to the beginning.</p>

<h3>Could we flatten with <code>*</code> in a comprehension?</h3>

<p>But what about Python&rsquo;s <code>*</code> operator?
I&rsquo;ve written about the many uses for <a href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/">the prefixed asterisk symbol in Python</a>.</p>

<p>We can use <code>*</code> in Python&rsquo;s list literal syntax (<code>[</code>&hellip;<code>]</code>) to unpack an iterable into a new list:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [3, 4, 7]
&gt;&gt;&gt; more_numbers = [2, 1, *numbers, 11, 18]
&gt;&gt;&gt; more_numbers
[2, 1, 3, 4, 7, 11, 18]
</code></pre>

<p>Could we use that <code>*</code> operator to unpack an iterable within a comprehension?</p>

<pre><code class="python">names = [
    *group
    for group in groups
]
</code></pre>

<p>We can&rsquo;t.
If we try to do this Python will specifically tell us that the <code>*</code> operator can&rsquo;t be used like this in a comprehension:</p>

<pre><code class="pycon">&gt;&gt;&gt; names = [
...     *group
...     for group in groups
... ]
  File "&lt;stdin&gt;", line 2
    ]
     ^
SyntaxError: iterable unpacking cannot be used in comprehension
</code></pre>

<p>This feature was specifically excluded from <a href="https://www.python.org/dev/peps/pep-0448/#variations">PEP 448</a>, the Python Enhancement Proposal that added this <code>*</code>-in-list-literal syntax to Python due to readability concerns.</p>

<h3>Can&rsquo;t we use <code>sum</code>?</h3>

<p>Here&rsquo;s another list flattening trick I&rsquo;ve seen a few times:</p>

<pre><code class="pycon">&gt;&gt;&gt; names = sum(groups, [])
</code></pre>

<p>This <em>does</em> work:</p>

<pre><code class="pycon">&gt;&gt;&gt; names
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>But I find this technique pretty unintuitive.</p>

<p>We use the <code>+</code> operator in Python for both adding numbers and concatenating sequences and the <code>sum</code> function happens to work with anything that supports the <code>+</code> operator (thanks to <a href="https://www.pythonmorsels.com/topics/duck-typing/">duck typing</a>).
But in my mind, the word &ldquo;sum&rdquo; implies arithmetic: <strong>summing adds numbers together</strong>.</p>

<p>I find it confusing to &ldquo;sum&rdquo; lists, so <strong>I don&rsquo;t recommend this approach</strong>.</p>

<p><strong>Quick Aside</strong>: The algorithm <code>sum</code> uses also makes list flattening <em>really</em> slow (<a href="https://gist.github.com/treyhunner/f0c069496a1e41aadcf0d7050e475eb3">timing comparison here</a>).
In <a href="https://www.youtube.com/watch?v=duvZ-2UK0fc">Big-O</a> terms (for the time complexity nerds), <code>sum</code> with lists is <code>O(n**2)</code> instead of <code>O(n)</code>.</p>

<h3>What about <code>itertools.chain</code>?</h3>

<p>There is one more tool that&rsquo;s often used for flattening: the <code>chain</code> utility in the <code>itertools</code> module.</p>

<p><code>chain</code> accepts any number arguments and it returns an <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">iterator</a>:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; chain(*groups)
&lt;itertools.chain object at 0x7fc1b2d65bb0&gt;
</code></pre>

<p>We can loop over that iterator or turn it into another iterable, like a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(chain(*groups))
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>There&rsquo;s actually a method on <code>chain</code> that&rsquo;s specifically for flattening a single iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(chain.from_iterable(groups))
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>Using <code>chain.from_iterable</code> is more performant than using <code>chain</code> with <code>*</code> because <code>*</code> unpacks the whole iterable immediately when <code>chain</code> is called.</p>

<h3>Recap: comparing list flattening techniques</h3>

<p>If you want to flatten an iterable-of-iterables lazily, I would use <code>itertools.chain.from_iterable</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; flattened = chain.from_iterable(groups)
</code></pre>

<p>This will return an <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">iterator</a>, meaning no work will be done until the returned iterable is looped over:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(flattened)
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>And it will be consumed as we loop, so looping twice will result in an empty iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(flattened)
[]
</code></pre>

<p>If you find <code>itertools.chain</code> a bit too cryptic, you might prefer a <code>for</code> loop that calls the <code>extend</code> method on a new list to repeatedly extend the values in each iterable:</p>

<pre><code class="python">names = []
for group in groups:
    names.extend(group)
</code></pre>

<p>Or a <code>for</code> loop that uses the <code>+=</code> operator on our new list:</p>

<pre><code class="python">names = []
for group in groups:
    names += group
</code></pre>

<p>Unlike <code>chain.from_iterable</code>, both of these <code>for</code> loops build up new list rather than a lazy iterator object.</p>

<p>If you find list comprehensions readable (I love them for signaling &ldquo;look we&rsquo;re building up a list&rdquo;) then you might prefer a comprehension instead:</p>

<pre><code class="python">names = [
    name
    for group in groups
    for name in group
]
</code></pre>

<p>And if you <em>do</em> want laziness (an iterator) but you don&rsquo;t like <code>itertools.chain</code> you could make a <a href="https://www.pythonmorsels.com/topics/how-write-generator-expression/">generator expression</a> that does the same thing as <code>itertools.chain.from_iterable</code>:</p>

<pre><code class="python">names = (
    name
    for group in groups
    for name in group
)
</code></pre>

<p>Happy list flattening!</p>
]]></content>
  </entry>
  
</feed>
