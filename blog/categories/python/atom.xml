<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="https://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://treyhunner.com/"/>
  <updated>2021-11-22T20:37:40-08:00</updated>
  <id>https://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Black Friday &amp; Cyber Monday Sales (2021)]]></title>
    <link href="https://treyhunner.com/2021/11/python-black-friday-and-cyber-monday-sales-2021/"/>
    <updated>2021-11-22T21:00:00-08:00</updated>
    <id>https://treyhunner.com/2021/11/python-black-friday-and-cyber-monday-sales-2021</id>
    <content type="html"><![CDATA[<p>This is my annual compilation post of Black Friday and Cyber Monday deals I&rsquo;ve found related to <strong>Python and Python learning</strong>.</p>

<p><strong>Note</strong>: Some sales likely aren&rsquo;t announced yet, so I will update this post on Black Friday and Cyber Monday.</p>

<h3>50% off dozens of Python screencasts (Python Morsels)</h3>

<p>Yes, the self-promotion comes first.</p>

<p>The Python Morsels Lite plan has evolved <em>a lot</em> since I first launched it and it&rsquo;s long overdue for a price increase.
This plan includes access to <strong>over 90 Python screencasts</strong> (a new one added each week) as well as a <strong>monthly Python exercise</strong> (your choice from novice to advanced Python).</p>

<p>From December 1, 2021 onward the price for the Python Morsels Lite plan will be $10/month or $100/year.
Until November 30, you can signup for <strong>$5/month</strong> or <strong>$50/year</strong> (and you&rsquo;ll lock-in that price for as long as you&rsquo;re subscribed).
This is the lowest price I&rsquo;ll ever offer this plan for.</p>

<p><strong>Save 50%</strong> on <a href="https://www.pythonmorsels.com/watch-python-screencasts/">the Python Morsels Lite plan</a> by signing up from now until Cyber Monday.</p>

<p><a href="https://www.pythonmorsels.com/watch-python-screencasts/">Get the Python Morsels Lite plan for just $50/year</a></p>

<h3>Reuven Lerner&rsquo;s Python courses and Weekly Python Exercise</h3>

<p>Reuven Lerner is offering <a href="https://store.lerner.co.il/?coupon=BF2021">30% off all his products</a> (intro Python bundle, advanced Python bundle, data analytics bundle, and Weekly Python Exercises, and more) through Monday.
Enter the coupon BF2021 if needed (though that link should apply the coupon already).</p>

<p>If you like Python Morsels, you might want to check out Reuven&rsquo;s Weekly Python exercise as well.
Both are based around exercise-driven learning.</p>

<h3>Matt Harrison&rsquo;s books and courses on Python, data science, and Pandas</h3>

<p>Matt Harrison is offering a 40% discount on all his courses and books (on Python, Pandas, and data science).
See his <a href="https://store.metasnake.com/?coupon=BF40">MetaSnake store</a> for more details.
Enter coupon code BF40 if needed (though the coupon code should already be applied when you click that link).</p>

<h3>Python Essentials for Data Scientists (Kevin Markham of Data School)</h3>

<p>Kevin Markham is offering 33% off his new course, <a href="https://courses.dataschool.io/python-essentials-for-data-scientists?coupon=BLACKFRIDAY">Python Essentials for Data Scientists</a>.
The course will be $33 instead of $49 from Black Friday through Cyber Monday.
The BLACKFRIDAY coupon is already applied from that link, but you&rsquo;ll need to wait until Friday (when enrollment to officially opens) to hit the Buy button.</p>

<h3>Brian Okken&rsquo;s Pytest book (Pragmatic Bookshelf)</h3>

<p>Pragmatic Bookshelf is offering 40% off all books with the code turkeysale2021, including <a href="https://pragprog.com/titles/bopytest/python-testing-with-pytest/"><strong>Brian Okken&rsquo;s Pytest book</strong></a> which is just under $15 with the coupon.</p>

<h3>Django-specific sales</h3>

<p>Adam Johnson&rsquo;s Speed Up Your Django Tests is <a href="https://adamchainz.gumroad.com/l/suydt">on sale for 50% off</a> (it&rsquo;s normally $49).
If you&rsquo;re using Django and writing automated tests (you should be!) check out Adam&rsquo;s book.</p>

<p>Will Vincent is also offering a 50% discount on his Django books, via <a href="https://wsvincent.gumroad.com/l/bhylo/blackfriday2021">a 3 book bundle</a>.
Each of Will&rsquo;s Django books is normally $40, but during his Black Friday sale you can get all 3 books for $59.</p>

<p>Test Driven is offering a 25% discount on a <a href="https://testdriven.io/bundle/django-black-friday/">3 Django course bundle</a> from Michael Herman and friends.
You can get three $30 courses for just $68 in total.</p>

<p>Check out Adam Johnson&rsquo;s <a href="https://adamj.eu/tech/2021/11/22/django-black-friday-deals/">Django-related deals for Black Friday and Cyber Monday</a> post for more Django-related deals.</p>

<h3>More Sales To Watch Out For</h3>

<p><strong>Talk Python</strong> has been offering a Black Friday sale on their <a href="https://training.talkpython.fm/courses/bundle/everything-bundle-2021-q4">everything bundle</a> every year for a while now (often a discount of $50 or more).
They&rsquo;ll likely offer another sale this year so check their site on Black Friday for details.</p>

<p><strong>Mike Driscoll</strong> often offers Black Friday and Cyber Monday sales on his <a href="https://www.blog.pythonlibrary.org/">Python books</a>.</p>

<p><strong>No Starch</strong> press often offers Black Friday discounts on lots of <a href="https://nostarch.com/catalog/python">Python books</a> (Al Sweigart, Eric Mathes, and more).</p>

<p><strong>PyBites</strong> sometimes holds Black Friday and Cyber Monday sales.
Check <a href="https://pybit.es/">the PyBites site</a> on Black Friday in case they&rsquo;re holding a sale.</p>

<h3>Lots of screencasts, exercises, books, and courses on sale</h3>

<p>This blog post is not up-to-date yet.
<strong>Check back on Black Friday</strong> for more Python-related sales as I hear about them (and feel free to comment below if you find more).</p>

<p>Also don&rsquo;t go too wild on sales!
If you don&rsquo;t have time to work through a Python course, don&rsquo;t buy it.
If you&rsquo;re unlikely to ever read that Python book, don&rsquo;t get it.
And if you can&rsquo;t commit to weekly Python learning, don&rsquo;t subscribe!</p>

<p>Consider picking a few things that look like you&rsquo;ll actually use them, and buy them.
Python educators love your support, but we also like happy customers who use and love our services.</p>

<p>Also if you have money to spend but nothing to spend it on (that&rsquo;s a great problem to have&hellip;), do as Python educator <a href="https://twitter.com/AllenDowney/status/1462856493716459526">Allen Downey suggested</a> and <strong>donate to charity</strong>.
You could <a href="https://psfmember.org/">become a PSF member</a> or give to highly effective charities via <a href="https://www.givewell.org/">GiveWell</a> or <a href="https://www.thelifeyoucansave.org/">The Life You Can Save</a>.</p>

<p>If you have a question about <a href="https://www.pythonmorsels.com/watch-python-screencasts/">the Python Morsels sale</a> please <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a>.
If you have a question about the other sales, reach out to the folks running it.</p>

<p>Happy coding!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to sort a dictionary in Python]]></title>
    <link href="https://treyhunner.com/2021/11/how-to-sort-a-dictionary-in-python/"/>
    <updated>2021-11-17T07:30:00-08:00</updated>
    <id>https://treyhunner.com/2021/11/how-to-sort-a-dictionary-in-python</id>
    <content type="html"><![CDATA[<p>Dictionaries are best used for key-value lookups: <strong>we provide a key</strong> and the dictionary <em>very</em> quickly <strong>returns the corresponding value</strong>.</p>

<p>But what if you need both key-value lookups and iteration?
It is possible to loop over a dictionary and when looping, we <em>might</em> care about <strong>the order of the items</strong> in the dictionary.</p>

<p>With dictionary item order in mind, you might wonder how can we <em>sort</em> a dictionary?</p>

<h3>Dictionaries are ordered</h3>

<p>As of Python 3.6 dictionaries are <strong>ordered</strong> (technically the ordering <a href="https://docs.python.org/3/whatsnew/3.7.html#summary-release-highlights">became official in 3.7</a>).</p>

<p>Dictionary keys are stored in <strong>insertion order</strong>, meaning whenever a new key is added it gets added at the very end.</p>

<pre><code class="pycon">&gt;&gt;&gt; color_amounts = {"purple": 6, "green": 3, "blue": 2}
&gt;&gt;&gt; color_amounts["pink"] = 4
&gt;&gt;&gt; color_amounts
{'purple': 6, 'green': 3, 'blue': 2, 'pink': 4}
</code></pre>

<p>But if we update a key-value pair, the key remains where it was before:</p>

<pre><code class="pycon">&gt;&gt;&gt; color_amounts["green"] = 5
&gt;&gt;&gt; color_amounts
{'purple': 6, 'green': 5, 'blue': 2, 'pink': 4}
</code></pre>

<p>So if you plan to populate a dictionary with some specific data and then leave that dictionary as-is, all you need to do is make sure that original data is in the order you&rsquo;d like.</p>

<p>For example if we have a CSV file of US state abbreviations and our file is ordered alphabetically by state name, our dictionary will be ordered the same way:</p>

<pre><code class="pycon">&gt;&gt;&gt; import csv
&gt;&gt;&gt; state_abbreviations = {}
&gt;&gt;&gt; for name, abbreviation in csv.reader("state-abbreviations.csv")
...     state_abbreviations[name] = abbreviation
...
&gt;&gt;&gt; state_abbreviations
{'Alabama': 'AL', 'Alaska': 'AK', 'Arizona': 'AZ', 'Arkansas': 'AR', 'California': 'CA', ...}
</code></pre>

<p>If our input data is already ordered correctly, our dictionary will end up ordered correctly as well.</p>

<h3>How to sort a dictionary by its keys</h3>

<p>What if our data isn&rsquo;t sorted yet?</p>

<p>Say we have a list-of-tuples that pair meeting rooms to their corresponding room numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms = [("Pink", "Rm 403"), ("Space", "Rm 201"), ("Quail", "Rm 500"), ("Lime", "Rm 503")]
</code></pre>

<p>And we&rsquo;d like to sort this dictionary by its keys.</p>

<p>We could use the built-in <code>sorted</code> function to sort it:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted(rooms)
[('Lime', 'Rm 503'), ('Pink', 'Rm 403'), ('Quail', 'Rm 500'), ('Space', 'Rm 201')]
</code></pre>

<p>The <code>sorted</code> function uses the <code>&lt;</code> operator to compare many items in the given iterable and return a sorted list.
The <code>sorted</code> function always returns a list.</p>

<p>To make these key-value pairs into a dictionary, we can pass them straight to the <code>dict</code> constructor:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms))
&gt;&gt;&gt; sorted_rooms
{'Lime': 'Rm 503', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Space': 'Rm 201'}
</code></pre>

<p>The <code>dict</code> constructor will accept a list of 2-item tuples (or any iterable of 2-item iterables) and make a dictionary out of it, using the first item from each tuple as a key and the second as the corresponding value.</p>

<h3>Key-value pairs are sorted lexicographically&hellip; what?</h3>

<p>We&rsquo;re sorting tuples of the key-value pairs before making a dictionary out of them.
But how does sorting tuples work?</p>

<pre><code class="pycon">&gt;&gt;&gt; some_tuples = [(1, 3), (3, 1), (1, 9), (0, 3)]
&gt;&gt;&gt; sorted(some_tuples)
[(0, 3), (1, 3), (1, 9), (3, 1)]
</code></pre>

<p>When sorting tuples, Python uses lexicographical ordering (which sounds fancier than it is).
Comparing a 2-item tuple basically boils down to this algorithm:</p>

<pre><code class="python">def compare_two_item_tuples(a, b):
    """This is the same as a &lt; b for two 2-item tuples."""
    if a[0] != b[0]:  # If the first item of each tuple is unequal
        return a[0] &lt; b[0]  # Compare the first item from each tuple
    else:
        return a[1] &lt; b[1]  # Compare the second item from each tuple
</code></pre>

<p>I&rsquo;ve written <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/">an article on tuple ordering</a> that explains this in more detail.</p>

<p>You might be thinking: <strong>it seems like this sorts not just by keys but by keys <em>and</em> values</strong>.
And you&rsquo;re right!
But only sort of.</p>

<p>The keys in a dictionary <em>should</em> always compare as unequal (if two keys are equal, they&rsquo;re seen as <em>the same key</em>).
So as long as the keys are comparable to each other with the less than operator (<code>&lt;</code>), sorting 2-item tuples of key-value pairs should always sort by the keys.</p>

<h3>Dictionaries can&rsquo;t be sorted in-place</h3>

<p>What if we already have our items <em>in</em> a dictionary and we&rsquo;d like to sort that dictionary?
Unlike lists, <strong>there&rsquo;s no <code>sort</code> method on dictionaries</strong>.</p>

<p>We can&rsquo;t sort a dictionary in-place, but we could get the items from our dictionary, sort those items using the same technique we used before, and then turn those items into a new dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items()))
&gt;&gt;&gt; sorted_rooms
{'Lime': 'Rm 503', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Space': 'Rm 201'}
</code></pre>

<p>That creates a new dictionary object.
If we <em>really</em> wanted to update our original dictionary object, we could take the items from the dictionary, sort them, clear the dictionary of all its items, and then add all the items back into the dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; old_dictionary = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
&gt;&gt;&gt; sorted_items = sorted(old_dictionary.items())
&gt;&gt;&gt; old_dictionary.clear()
&gt;&gt;&gt; old_dictionary.update(sorted_items)
</code></pre>

<p>But why bother?
We don&rsquo;t usually <em>want</em> to operate on data structures in-place in Python: we tend to prefer making a new data structure rather than re-using an old one (this preference is partly thanks to <a href="https://www.pythonmorsels.com/topics/variables-are-pointers/">how variables work in Python</a>).</p>

<h3>How to sort a dictionary by its values</h3>

<p>What if we wanted to sort a dictionary by its values instead of its keys?</p>

<p>We could make a new list of value-key tuples (actually a generator in our case below), sort that, then flip them back to key-value tuples and recreate our dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; rooms = {"Pink": "Rm 403", "Space": "Rm 201", "Quail": "Rm 500", "Lime": "Rm 503"}
&gt;&gt;&gt; room_to_name = sorted((room, name) for (name, room) in rooms.items())
&gt;&gt;&gt; sorted_rooms = {
...     name: room
...     for room, name in room_to_name
... }
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>This works but it&rsquo;s a bit long.
Also this technique actually sorts both our values and our keys (giving the values precedence in the sorting).</p>

<p>What if we wanted to <em>just</em> sort our dictionary by its values, ignoring the contents of the keys entirely?
Python&rsquo;s <code>sorted</code> function accepts a <code>key</code> argument that we can use for this!</p>

<pre><code class="pycon">&gt;&gt;&gt; help(sorted)
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.

    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.
</code></pre>

<p>The key function we pass to sorted should accept an item from the iterable we&rsquo;re sorting and return the <em>key</em> to sort by.
Note that the word &ldquo;key&rdquo; here isn&rsquo;t related to dictionary keys.
Dictionary keys are used for looking up dictionary values whereas this key function returns an object that determines how to order items in an iterable.</p>

<p>If we want to sort the dictionary by its values, we could make a key function that accepts each item in our list of 2-item tuples and <strong>returns just the value</strong>:</p>

<pre><code class="python">def value_from_item(item):
    """Return just the value from a given (key, value) tuple."""
    key, value = item
    return value
</code></pre>

<p>Then we&rsquo;d use our key function by passing it to the <code>sorted</code> function (yes <a href="https://treyhunner.com/2020/01/passing-functions-as-arguments/">functions can be passed to other functions in Python</a>) and pass the result to <code>dict</code> to create a new dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=value_from_item))
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>If you prefer not to create a custom key function just to use it once, you could use a lambda function (which I <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/">don&rsquo;t usually recommend</a>):</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=lambda item: item[1]))
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>Or you could use <code>operator.itemgetter</code> to make a key function that gets the second item from each key-value tuple:</p>

<pre><code class="pycon">&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=itemgetter(1)))
&gt;&gt;&gt; sorted_rooms
{'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p>I discussed my preference for <code>itemgetter</code> <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/#Overuse:_using_lambda_for_very_simple_operations">in my article on lambda functions</a>.</p>

<h3>Ordering a dictionary in some other way</h3>

<p>What if we needed to sort our dictionary by something other than just a key or a value?
For example what if our room number strings include numbers that aren&rsquo;t always the same length:</p>

<pre><code class="python">rooms = {
    "Pink": "Rm 403",
    "Space": "Rm 201",
    "Quail": "Rm 500",
    "Lime": "Rm 503",
    "Ocean": "Rm 2000",
    "Big": "Rm 30",
}
</code></pre>

<p>If we sorted these rooms by value, those strings wouldn&rsquo;t be sorted in the numerical way we&rsquo;re hoping for:</p>

<pre><code class="pycon">&gt;&gt;&gt; from operator import itemgetter
&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=itemgetter(1)))
&gt;&gt;&gt; sorted_rooms
{'Ocean': 'Rm 2000', 'Space': 'Rm 201', 'Big': 'Rm 30', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503'}
</code></pre>

<p><strong>Rm 30</strong> should be first and <strong>Rm 2000</strong> should be last.
But we&rsquo;re sorting strings, which are ordered character-by-character based on the unicode value of each character (I <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/#String_comparisons_in_Python">noted this</a> in my article on tuple ordering).</p>

<p>We could customize the <code>key</code> function we&rsquo;re using to sort numerically instead:</p>

<pre><code class="python">def by_room_number(item):
    """Return numerical room given a (name, room_number) tuple."""
    name, room = item
    _, number = room.split()
    return int(number)
</code></pre>

<p>When we use this key function to sort our dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms = dict(sorted(rooms.items(), key=by_room_number))
</code></pre>

<p>It will be sorted by the integer room number, as expected:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_rooms
{'Big': 'Rm 30', 'Space': 'Rm 201', 'Pink': 'Rm 403', 'Quail': 'Rm 500', 'Lime': 'Rm 503', 'Ocean': 'Rm 2000'}
</code></pre>

<h3>Should you sort a dictionary?</h3>

<p>When you&rsquo;re about to sort a dictionary, first ask yourself &ldquo;do I need to do this&rdquo;?
In fact, when you&rsquo;re considering looping over a dictionary you might ask &ldquo;do I really need a dictionary here&rdquo;?</p>

<p>Dictionaries are used for key-value lookups: you can quickly get a value given a key.
They&rsquo;re very fast at retrieving values for keys.
But dictionaries take up more space than a list of tuples.</p>

<p>If you can get away with using a list of tuples in your code (because you don&rsquo;t actually need a key-value lookup), you probably <em>should</em> use a list of tuples instead of a dictionary.</p>

<p>But if key lookups are what you need, it&rsquo;s unlikely that you also need to loop over your dictionary.</p>

<p>Now it&rsquo;s certainly possible that right now you do in fact have a good use case for sorting a dictionary (for example maybe you&rsquo;re <a href="https://gist.github.com/treyhunner/7adcbc96870b79642f1754c3cc602ac6">sorting keys in a dictionary of attributes</a>), but keep in mind that you&rsquo;ll need to sort a dictionary <strong>very rarely</strong>.</p>

<h3>Summary</h3>

<p>Dictionaries are used for quickly looking up a value based on a key.
The <em>order</em> of a dictionary&rsquo;s items is rarely important.</p>

<p>In the rare case that you care about the order of your dictionary&rsquo;s items, keep in mind that dictionaries are ordered by the <em>insertion order</em> of their keys (as of Python 3.6).
So the keys in your dictionary will remain in the order they were added to the dictionary.</p>

<p>If you&rsquo;d like to sort a dictionary by its keys, you can use the built-in <code>sorted</code> function along with the <code>dict</code> constructor:</p>

<pre><code class="pycon">&gt;&gt;&gt; sorted_dictionary = dict(sorted(old_dictionary.items()))
</code></pre>

<p>If you&rsquo;d like to sort a dictionary by its values, you can pass a custom <code>key</code> function (one which returns the value for each item) to <code>sorted</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; def value_from_item(item):
...     key, value = item
...     return value
...
&gt;&gt;&gt; sorted_dictionary = dict(sorted(old_dictionary.items(), key=value_from_item))
</code></pre>

<p>But remember, it&rsquo;s not often that we care about the order of a dictionary.
Whenever you&rsquo;re sorting a dictionary, please remember to ask yourself <strong>do I really need to sort this data structure</strong> and <strong>would a list of tuples be more suitable than a dictionary here</strong>?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to flatten a list in Python]]></title>
    <link href="https://treyhunner.com/2021/11/how-to-flatten-a-list-in-python/"/>
    <updated>2021-11-01T08:00:00-07:00</updated>
    <id>https://treyhunner.com/2021/11/how-to-flatten-a-list-in-python</id>
    <content type="html"><![CDATA[<p>You&rsquo;ve somehow ended up with lists nested inside of lists, possibly like this one:</p>

<pre><code class="pycon">&gt;&gt;&gt; groups = [["Hong", "Ryan"], ["Anthony", "Wilhelmina"], ["Margaret", "Adrian"]]
</code></pre>

<p>But you <em>want</em> just a single list (without the nesting) like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; expected_output = ["Hong", "Ryan", "Anthony", "Wilhelmina", "Margaret", "Adrian"]
</code></pre>

<p>You need to flatten your list-of-lists.</p>

<h3>We&rsquo;re looking for a &ldquo;shallow&rdquo; flatten</h3>

<p>We can think of this as a <strong>shallow flatten</strong> operation, meaning we&rsquo;re flattening this list by one level.
A <strong>deep flatten</strong> operation would handle lists-of-lists-of-lists-of-lists (and so on) and that&rsquo;s a bit more than we need for our use case.</p>

<p>The flattening strategy we come up with should work on lists-of-lists as well as any other type of <a href="https://www.pythonmorsels.com/topics/iterable/">iterable</a>-of-iterables.
For example lists of tuples should be flattenable:</p>

<pre><code class="pycon">&gt;&gt;&gt; groups = [("Hong", "Ryan"), ("Anthony", "Wilhelmina"), ("Margaret", "Adrian")]
</code></pre>

<p>And even an odd type like a <code>dict_items</code> object (which we get from asking a dictionary for its items) should be flattenable:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruit_counts = {"apple": 3, "lime": 2, "watermelon": 1, "mandarin": 4}
&gt;&gt;&gt; fruit_counts.items()
dict_items([('apple', 3), ('lime', 2), ('watermelon', 1), ('mandarin', 4)])
&gt;&gt;&gt; flattened_counts = ['apple', 3, 'lime', 2, 'watermelon', 1, 'mandarin', 4]
</code></pre>

<h3>Flattening iterables-of-iterables with a <code>for</code> loop</h3>

<p>One way to flatten an iterable-of-iterables is with a <code>for</code> loop.
We can loop one level deep to get each of the inner iterables.</p>

<pre><code class="python">for group in groups:
    ...
</code></pre>

<p>And then we loop a second level deep to get each item from each inner iterable.</p>

<pre><code class="python">for group in groups:
    for name in group:
        ...
</code></pre>

<p>And then append each item to a new list:</p>

<pre><code class="python">names = []
for group in groups:
    for name in group:
        names.append(name)
</code></pre>

<p>There&rsquo;s also a list method that makes this a bit shorter, the <code>extend</code> method:</p>

<pre><code class="python">names = []
for group in groups:
    names.extend(group)
</code></pre>

<p>The list <code>extend</code> method accepts an iterable and appends every item in the iterable you give to it.</p>

<p>Or we could use the <code>+=</code> operator to concatenate each list to our new list:</p>

<pre><code class="python">names = []
for group in groups:
    names += group
</code></pre>

<p>You can think of <code>+=</code> on lists as calling the <code>extend</code> method.
With lists these two operations (<code>+=</code> and <code>extend</code>) are equivalent.</p>

<h3>Flattening iterables-of-iterables with a comprehension</h3>

<p>This nested <code>for</code> loop with an <code>append</code> call might look familiar:</p>

<pre><code class="python">names = []
for group in groups:
    for name in group:
        names.append(name)
</code></pre>

<p>The structure of this code looks like something we could <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-paste into a list comprehension</a>.</p>

<p>Inside our square brackets we&rsquo;d copy the thing we&rsquo;re appending first, and then the logic for our first loop, and then the logic for our second loop:</p>

<pre><code class="python">names = [
    name
    for group in groups
    for name in group
]
</code></pre>

<p>This comprehension loops two levels deep, just like our nested <code>for</code> loops did.
Note that the order of the <code>for</code> clauses in the comprehension <strong>must remain the same as the order of the <code>for</code> loops</strong>.</p>

<p>The (sometimes confusing) order of those <code>for</code> clauses is partly why I recommend <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-pasting into a comprehension</a>.
When turning a <code>for</code> loop into a comprehension, the <code>for</code> and <code>if</code> clauses remain in the same relative place, but the thing you&rsquo;re appending moves from the end to the beginning.</p>

<h3>Could we flatten with <code>*</code> in a comprehension?</h3>

<p>But what about Python&rsquo;s <code>*</code> operator?
I&rsquo;ve written about the many uses for <a href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/">the prefixed asterisk symbol in Python</a>.</p>

<p>We can use <code>*</code> in Python&rsquo;s list literal syntax (<code>[</code>&hellip;<code>]</code>) to unpack an iterable into a new list:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [3, 4, 7]
&gt;&gt;&gt; more_numbers = [2, 1, *numbers, 11, 18]
&gt;&gt;&gt; more_numbers
[2, 1, 3, 4, 7, 11, 18]
</code></pre>

<p>Could we use that <code>*</code> operator to unpack an iterable within a comprehension?</p>

<pre><code class="python">names = [
    *group
    for group in groups
]
</code></pre>

<p>We can&rsquo;t.
If we try to do this Python will specifically tell us that the <code>*</code> operator can&rsquo;t be used like this in a comprehension:</p>

<pre><code class="pycon">&gt;&gt;&gt; names = [
...     *group
...     for group in groups
... ]
  File "&lt;stdin&gt;", line 2
    ]
     ^
SyntaxError: iterable unpacking cannot be used in comprehension
</code></pre>

<p>This feature was specifically excluded from <a href="https://www.python.org/dev/peps/pep-0448/#variations">PEP 448</a>, the Python Enhancement Proposal that added this <code>*</code>-in-list-literal syntax to Python due to readability concerns.</p>

<h3>Can&rsquo;t we use <code>sum</code>?</h3>

<p>Here&rsquo;s another list flattening trick I&rsquo;ve seen a few times:</p>

<pre><code class="pycon">&gt;&gt;&gt; names = sum(groups, [])
</code></pre>

<p>This <em>does</em> work:</p>

<pre><code class="pycon">&gt;&gt;&gt; names
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>But I find this technique pretty unintuitive.</p>

<p>We use the <code>+</code> operator in Python for both adding numbers and concatenating sequences and the <code>sum</code> function happens to work with anything that supports the <code>+</code> operator (thanks to <a href="https://www.pythonmorsels.com/topics/duck-typing/">duck typing</a>).
But in my mind, the word &ldquo;sum&rdquo; implies arithmetic: <strong>summing adds numbers together</strong>.</p>

<p>I find it confusing to &ldquo;sum&rdquo; lists, so <strong>I don&rsquo;t recommend this approach</strong>.</p>

<p><strong>Quick Aside</strong>: The algorithm <code>sum</code> uses also makes list flattening <em>really</em> slow (<a href="https://gist.github.com/treyhunner/f0c069496a1e41aadcf0d7050e475eb3">timing comparison here</a>).
In <a href="https://www.youtube.com/watch?v=duvZ-2UK0fc">Big-O</a> terms (for the time complexity nerds), <code>sum</code> with lists is <code>O(n**2)</code> instead of <code>O(n)</code>.</p>

<h3>What about <code>itertools.chain</code>?</h3>

<p>There is one more tool that&rsquo;s often used for flattening: the <code>chain</code> utility in the <code>itertools</code> module.</p>

<p><code>chain</code> accepts any number arguments and it returns an <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">iterator</a>:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; chain(*groups)
&lt;itertools.chain object at 0x7fc1b2d65bb0&gt;
</code></pre>

<p>We can loop over that iterator or turn it into another iterable, like a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(chain(*groups))
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>There&rsquo;s actually a method on <code>chain</code> that&rsquo;s specifically for flattening a single iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(chain.from_iterable(groups))
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>Using <code>chain.from_iterable</code> is more performant than using <code>chain</code> with <code>*</code> because <code>*</code> unpacks the whole iterable immediately when <code>chain</code> is called.</p>

<h3>Recap: comparing list flattening techniques</h3>

<p>If you want to flatten an iterable-of-iterables lazily, I would use <code>itertools.chain.from_iterable</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; flattened = chain.from_iterable(groups)
</code></pre>

<p>This will return an <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">iterator</a>, meaning no work will be done until the returned iterable is looped over:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(flattened)
['Hong', 'Ryan', 'Anthony', 'Wilhelmina', 'Margaret', 'Adrian']
</code></pre>

<p>And it will be consumed as we loop, so looping twice will result in an empty iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(flattened)
[]
</code></pre>

<p>If you find <code>itertools.chain</code> a bit too cryptic, you might prefer a <code>for</code> loop that calls the <code>extend</code> method on a new list to repeatedly extend the values in each iterable:</p>

<pre><code class="python">names = []
for group in groups:
    names.extend(group)
</code></pre>

<p>Or a <code>for</code> loop that uses the <code>+=</code> operator on our new list:</p>

<pre><code class="python">names = []
for group in groups:
    names += group
</code></pre>

<p>Unlike <code>chain.from_iterable</code>, both of these <code>for</code> loops build up new list rather than a lazy iterator object.</p>

<p>If you find list comprehensions readable (I love them for signaling &ldquo;look we&rsquo;re building up a list&rdquo;) then you might prefer a comprehension instead:</p>

<pre><code class="python">names = [
    name
    for group in groups
    for name in group
]
</code></pre>

<p>And if you <em>do</em> want laziness (an iterator) but you don&rsquo;t like <code>itertools.chain</code> you could make a <a href="https://www.pythonmorsels.com/topics/how-write-generator-expression/">generator expression</a> that does the same thing as <code>itertools.chain.from_iterable</code>:</p>

<pre><code class="python">names = (
    name
    for group in groups
    for name in group
)
</code></pre>

<p>Happy list flattening!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's great about Python 3.10?]]></title>
    <link href="https://treyhunner.com/2021/10/whats-great-about-python-3-dot-10/"/>
    <updated>2021-10-08T08:30:30-07:00</updated>
    <id>https://treyhunner.com/2021/10/whats-great-about-python-3-dot-10</id>
    <content type="html"><![CDATA[<p>What changed in Python 3.10 and which of those changes matter for you?</p>

<p>I&rsquo;ve spent this week playing with Python 3.10.
I&rsquo;ve primarily been working on solutions to Python Morsels exercises that embrace new Python 3.10 features.
I&rsquo;d like to share what I&rsquo;ve found.</p>

<h2>Easier troubleshooting with improved error messages</h2>

<p>The biggest Python 3.10 improvements by far are all related improved error messages.
I make typos all the time.
Error messages that help me quickly figure out what&rsquo;s wrong are <em>really</em> important.</p>

<p>I&rsquo;ve already grown accustom to the process of deciphering many of Python&rsquo;s more cryptic error messages.
So while improved error messages <em>are</em> great for me, this change is <em>especially</em> big for new Python learners.</p>

<p>When I teach an introduction to Python course, some of the most common errors I help folks debug are:</p>

<ol>
<li>Missing colons at the end of a block of code</li>
<li>Missing indentation or incorrect indentation in a block of code</li>
<li>Misspelled variable names</li>
<li>Brackets and braces that were never closed</li>
</ol>


<p>Python 3.10 makes all of these errors (and more) much clearer for Python learners.</p>

<p>New Python users often forget to put a <code>:</code> to begin their code blocks.
In Python 3.9 users would see this cryptic error message:</p>

<pre><code class="bash">$ python3.10 temp.py 70
  File "/home/trey/temp.py", line 4
    if temperature &lt; 65
                       ^
SyntaxError: invalid syntax
</code></pre>

<p>Python 3.10 makes this much clearer:</p>

<pre><code class="bash">$ python3.10 temp.py 70
  File "/home/trey/temp.py", line 4
    if temperature &lt; 65
                       ^
SyntaxError: expected ':'
</code></pre>

<p>Indentation errors are clearer too (that <code>after 'if' statement on line 4</code> is new):</p>

<pre><code class="bash">$ python3.10 temp.py 70
  File "/home/trey/temp.py", line 5
    print("Too cold")
    ^
IndentationError: expected an indented block after 'if' statement on line 4
</code></pre>

<p>And incorrect variable and attribute names now show a suggestion:</p>

<pre><code class="bash">$ python3.10 temp.py 70
Traceback (most recent call last):
  File "/home/trey/temp.py", line 4, in &lt;module&gt;
    if temparature &lt; 65:
NameError: name 'temparature' is not defined. Did you mean: 'temperature'?
</code></pre>

<p>I&rsquo;m really excited about that one because I make typos in variable names pretty much daily.</p>

<p>The error message shown for unclosed brackets, braces, and parentheses is also <em>much</em> more helpful.</p>

<p>Python used to show us the <em>next</em> line of code after an unclosed brace:</p>

<pre><code class="bash">$ python3.9 temp.py 70
  File "/home/trey/temp.py", line 6
    elif temperature &gt; 80:
    ^
SyntaxError: invalid syntax
</code></pre>

<p>Now it instead points to the opening brace that was left unclosed:</p>

<pre><code class="bash">$ python3.10 temp.py 70
  File "/home/trey/temp.py", line 5
    print("Too cold"
         ^
SyntaxError: '(' was never closed
</code></pre>

<p>You can find more details on these improved error messages in the <a href="https://docs.python.org/3.10/whatsnew/3.10.html#better-error-messages">better error messages</a> section of the &ldquo;What&rsquo;s new in Python 3.10&rdquo; documentation.</p>

<p>While Python 3.10 does include other changes (read on if you&rsquo;re interested), these improved error messages are the one 3.10 improvement that <strong>all Python users will notice</strong>.</p>

<h2>IDLE is more visually consistent</h2>

<p>Here&rsquo;s another feature that affects new Python users: the look of IDLE <a href="https://twitter.com/sjoerdjob/status/1446172628922867712">improved a bit</a>.
IDLE now uses spaces for indentation instead of tabs (unlike the built-in REPL) and the familiar <code>...</code> in front of REPL continuation lines is now present in IDLE within a sidebar.</p>

<p>Before IDLE looked like this:</p>

<p><img src="/images/idle3.9.png" title="An IDLE Shell window with an if-else block that has no &hellip; prefixes and uses tabs for indentation" ></p>

<p>Now IDLE looks like this:</p>

<p><img src="/images/idle3.10.png" title="An IDLE Shell window with an if-else block that has &hellip; prefixes and uses 4 spaces for indentation" ></p>

<p>Looks a lot more like the Python REPL on the command-prompt, right?</p>

<h2>Length-checking for the zip function</h2>

<p>There&rsquo;s a Python Morsels exercise called <code>strict_zip</code>.
It&rsquo;s now become a &ldquo;re-implement this already built-in functionality&rdquo; exercise.
Still useful for the sake of learning how <code>zip</code> is implemented, but no longer useful day-to-day code.</p>

<p>Why isn&rsquo;t it useful?
Because <code>zip</code> now accepts a <code>strict</code> argument!
So if you&rsquo;re working with iterables that <em>might</em> be different lengths but <em>shouldn&rsquo;t</em> be, passing <code>strict=True</code> is now <a href="https://docs.python.org/3.10/library/functions.html#zip">recommended when using zip</a>.</p>

<h2>Structural pattern matching</h2>

<p>The big Python 3.10 feature everyone is talking about is structural pattern matching.
This feature is very powerful but probably not very relevant for most Python users.</p>

<p>One important note about this feature: <code>match</code> and <code>case</code> are still allowable variable names so all your existing code should keep working (they&rsquo;re <a href="https://www.python.org/dev/peps/pep-0622/#the-match-statement">soft keywords</a>).</p>

<h3>Matching the shape and contents of an iterable</h3>

<p>You could look at the new <code>match</code>/<code>case</code> statement as <strong>like tuple unpacking with a lot more than just length-checking</strong>.</p>

<p>Compare this snippet of code <a href="https://github.com/django/django/blob/main/django/templatetags/i18n.py#L243..L246">from a Django template tag</a>:</p>

<pre><code class="python">    args = token.split_contents()
    if len(args) != 5 or args[1] != 'for' or args[3] != 'as':
        raise TemplateSyntaxError("'%s' requires 'for string as variable' (got %r)" % (args[0], args[1:]))
    return GetLanguageInfoNode(parser.compile_filter(args[2]), args[4])
</code></pre>

<p>To the same snippet refactored to use structural pattern matching:</p>

<pre><code class="python">    match token.split_contents():
        case [name, "for", code, "as", info]:
            return GetLanguageInfoNode(parser.compile_filter(code), info)
        case [name, *rest]:
            raise TemplateSyntaxError(f"'{name}' requires 'for string as variable' (got {rest!r})")
</code></pre>

<p>Notice that the second approach allows us to describe both the number of variables we&rsquo;re unpacking our data into and the names to unpack into (just like tuple unpacking) while also matching the second and third values against the strings <code>for</code> and <code>as</code>.
If those strings don&rsquo;t show up in the expected positions, we raise an appropriate exception.</p>

<p>Structural pattern matching is <em>really</em> handy for implementing simple parsers, like Django&rsquo;s template language.
I&rsquo;m looking forward to seeing Django&rsquo;s refactored template code in 2025 (after Python 3.9 support ends).</p>

<h3>Complex type checking</h3>

<p>Structural pattern matching also excels at type checking.
Strong type checking is usually discouraged in Python, but it does come crop up from time to time.</p>

<p>The most common place I see <code>isinstance</code> checks is in operator overloading dunder methods (<code>__eq__</code>, <code>__lt__</code>, <code>__add__</code>, <code>__sub__</code>, etc).
I&rsquo;ve already upgraded some Python Morsels solutions to compare and contrast <code>match</code>-<code>case</code> and <code>isinstance</code> and I&rsquo;m finding it more verbose in some cases but also occasionally somewhat clearer.</p>

<p>For example this code snippet (again <a href="https://github.com/django/django/blob/3.2/django/utils/formats.py#L195..L209">from Django</a>):</p>

<pre><code class="python">    if isinstance(value, str):  # Handle strings first for performance reasons.
        return value
    elif isinstance(value, bool):  # Make sure booleans don't get treated as numbers
        return str(value)
    elif isinstance(value, (decimal.Decimal, float, int)):
        if use_l10n is False:
            return str(value)
        return number_format(value, use_l10n=use_l10n)
    elif isinstance(value, datetime.datetime):
        return date_format(value, 'DATETIME_FORMAT', use_l10n=use_l10n)
    elif isinstance(value, datetime.date):
        return date_format(value, use_l10n=use_l10n)
    elif isinstance(value, datetime.time):
        return time_format(value, 'TIME_FORMAT', use_l10n=use_l10n)
    return value
</code></pre>

<p>Can be replaced by this code snippet instead:</p>

<pre><code class="python">    match value:
        case str():  # Handle strings first for performance reasons.
            return value
        case bool():  # Make sure booleans don't get treated as numbers
            return str(value)
        case decimal.Decimal() | float() | int():
            if use_l10n is False:
                return str(value)
            return number_format(value, use_l10n=use_l10n)
        case datetime.datetime():
            return date_format(value, 'DATETIME_FORMAT', use_l10n=use_l10n)
        case datetime.date():
            return date_format(value, use_l10n=use_l10n)
        case datetime.time():
            return time_format(value, 'TIME_FORMAT', use_l10n=use_l10n)
        case _:
            return value
</code></pre>

<p>Note how much shorter each condition is.
That <code>case</code> syntax definitely takes some getting used to, but I do find it a bit easier to read in long <code>isinstance</code> chains like this.</p>

<h2>Bisecting with a key</h2>

<p>Python&rsquo;s <code>bisect</code> module is really handy for quickly finding an item within a sorted list.</p>

<p>For me, the <code>bisect</code> module is mostly a reminder of how infrequently I need to care about the <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a> algorithms I learned in Computer Science classes.
But for those times you do need to find an item in a sorted list, <code>bisect</code> is great.</p>

<p>As of Python 3.10, all the binary search helpers in the <code>bisect</code> module now accept a <code>key</code> argument.
So you can now quickly search within a case insensitively-sorted list of strings for the string you&rsquo;re looking for.</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = sorted(['Watermelon','loquat', 'Apple', 'jujube'], key=str.lower)
&gt;&gt;&gt; fruits
['Apple', 'jujube', 'loquat', 'Watermelon']
&gt;&gt;&gt; import bisect
&gt;&gt;&gt; bisect.insort(fruits, 'Lemon', key=str.lower)
&gt;&gt;&gt; fruits
['Apple', 'jujube', 'Lemon', 'loquat', 'Watermelon']
&gt;&gt;&gt; i = bisect.bisect(fruits, 'lime', key=str.lower)
&gt;&gt;&gt; fruits[i] == 'lime'
False
&gt;&gt;&gt; fruits[i]
'loquat'
</code></pre>

<p>Doing a search that involved a <code>key</code> function was <a href="https://stackoverflow.com/a/55007379/98187">surprisingly tricky</a> before Python 3.10.</p>

<h2>Slots for data classes</h2>

<p>Have a data class (especially a frozen one) and want to make it more memory-efficient?
You can add a <code>__slots__</code> attribute but you&rsquo;ll need to type all the field names out yourself.</p>

<pre><code class="python">from dataclasses import dataclass

@dataclass
class Point:
    __slots__ = ('x', 'y')
    x: float
    y: float
</code></pre>

<p>In Python 3.10 you can now use <code>slots=True</code> instead:</p>

<pre><code class="python">from dataclasses import dataclass

@dataclass(slots=True)
class Point:
    x: float
    y: float
</code></pre>

<p>This feature was actually included in the original dataclass implementation but <a href="https://github.com/ericvsmith/dataclasses/issues/28">removed</a> before Python 3.7&rsquo;s release (Guido suggested including it in a later Python version if users expressed interest and we did).</p>

<p>Creating a dataclass with <code>__slots__</code> added manually <a href="https://stackoverflow.com/questions/50180735/how-can-dataclasses-be-made-to-work-better-with-slots">won&rsquo;t allow for default field values</a>, which is why <code>slots=True</code> is so handy.
There&rsquo;s a very smaller quirk with <code>slots=True</code> though: <code>super</code> calls break when <code>slots=True</code> is used because this causes a <em>new</em> class object to be created which breaks the <a href="https://stackoverflow.com/questions/19608134/why-is-python-3-xs-super-magic/19609168#19609168">magic of super</a>.
But unless you&rsquo;re using calling <code>super().__setattr__</code> in the <code>__post_init__</code> method of a frozen dataclass <a href="https://stackoverflow.com/a/54119384/98187">instead of</a> calling <code>object.__setattr__</code>, this quirk likely won&rsquo;t affect you.</p>

<h3>Type annotation improvements</h3>

<p>If you use type annotations, <a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-604-new-type-union-operator">type unions</a> are even easier now using the <code>|</code> operator (in addition to <code>typing.Union</code>).
Other big additions in type annotation land include <a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-612-parameter-specification-variables">parameter specification variables</a>, <a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-613-typealias">type aliases</a>, and <a href="https://docs.python.org/3.10/whatsnew/3.10.html#pep-647-user-defined-type-guards">user-defined type guards</a>.
I still don&rsquo;t use type annotations often, but these features are a pretty big deal for Python devs who do.</p>

<p>Also if you&rsquo;re introspecting annotations, calling the <code>inspect.get_annotations</code> function is <a href="https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-10-and-newer">recommended</a> over accessing <code>__annotations__</code> directly or calling the <code>typing.get_type_hints</code> function.</p>

<h3>Checking for default file encoding issues</h3>

<p>You can also now ask Python to emit warnings when you fail to specify an explicit file encoding (this is <em>very</em> relevant when writing cross operating system compatible code).</p>

<p>Just run Python with <code>-X warn_default_encoding</code> and you&rsquo;ll see a loud error message if you&rsquo;re not specifying encodings everyone you open files up:</p>

<pre><code class="bash">$ python3.10 -X warn_default_encoding count_lines.py declaration-of-independence.txt
/home/trey/count_lines.py:3: EncodingWarning: 'encoding' argument not specified
  with open(sys.argv[1]) as f:
67
</code></pre>

<h2>Plus lots more</h2>

<p>The changes above are the main ones I&rsquo;ve found useful when updating Python Morsels exercises over the last week.
There are many more changes in Python 3.10 though.</p>

<p>Here are a few more things I looked into, and plan to play with later:</p>

<ul>
<li><a href="https://docs.python.org/3.10/whatsnew/3.10.html#keyword-only-fields">keyword-only</a> dataclass fields</li>
<li>The <code>fileinput.input</code> (handy for handling standard input <em>or</em> a file) function <a href="https://docs.python.org/3.10/whatsnew/3.10.html#fileinput">now accepts</a> an <code>encoding</code> argument</li>
<li><code>importlib</code> <a href="https://docs.python.org/3.10/whatsnew/3.10.html#deprecated">deprecations</a>: some of my dynamic module importing code was using features that are now deprecated in Python 3.10 (you&rsquo;ll notice obvious deprecation warnings if your code needs updating too)</li>
<li><a href="https://docs.python.org/3.10/library/stdtypes.html#dict-views">Dictionary views</a> have a <code>mapping</code> attribute now: if you&rsquo;re making your own dictionary-like objects, you should probably add a <code>mapping</code> attribute to your <code>keys</code>/<code>values</code>/<code>items</code> views as well (this will definitely crop up in Python Morsels exercises in the future)</li>
<li>When using multiple context managers in a single <code>with</code> block, parentheses can now be used to wrap them onto the next line (this was actually added in Python 3.9 <a href="https://bugs.python.org/issue12782">but unofficially</a>)</li>
<li>The names of <a href="https://docs.python.org/3.10/library/sys.html#sys.stdlib_module_names">standard library modules</a> and built-in modules are now included in <code>sys.stdlib_module_names</code> and <code>sys.builtin_module_names</code>: I&rsquo;ve occasionally needed to distinguish between third party and standard library modules dynamically and this makes that a lot easier</li>
<li><code>sys.orig_argv</code> includes the <a href="https://docs.python.org/3.10/library/sys.html#sys.orig_argv">full list of command-line arguments</a> (including the Python interpreter and all arguments passed to it) which could be useful when inspecting how your Python process was launched or when re-launching your Python process with the same arguments</li>
</ul>


<h2>Summary</h2>

<p>Structural pattern matching is great and the various other syntax, standard library, and builtins improvements are lovely too.
But the biggest improvement by far are the new error messages.</p>

<p>And you know what&rsquo;s even better news than the new errors in Python 3.10?
<a href="https://docs.python.org/3.11/whatsnew/3.11.html#enhanced-error-locations-in-tracebacks">Python 3.11 will include even better error messages</a>!</p>

<h2>Get practice with Python 3.10</h2>

<p>Want to try out Python 3.10?
Try out the <a href="https://www.pythonmorsels.com/exercises/paths/#path-14">Python 3.10 exercise path</a> on Python Morsels.
It&rsquo;s free for <a href="https://www.pythonmorsels.com/">Python Morsels</a> subscribers and $17 for non-subscribers.</p>

<p>Python Morsels currently includes <strong>170 Python exercises</strong> and <strong>80 Python screencasts</strong> with a new short screencast/article hybrid added each week.
This service is all about hands-on skill building (we learn and grow through doing, not just reading/watching).</p>

<p>I&rsquo;d love for you to <a href="https://www.pythonmorsels.com/exercises/paths/#path-14">come learn Python (3.10) with me</a>! </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Cyber Monday Sales 2020]]></title>
    <link href="https://treyhunner.com/2020/11/python-cyber-monday-sales/"/>
    <updated>2020-11-27T13:20:00-08:00</updated>
    <id>https://treyhunner.com/2020/11/python-cyber-monday-sales</id>
    <content type="html"><![CDATA[<p>This post is a compilation of different Cyber Monday deals I&rsquo;ve found related to Python and Python learning.</p>

<h3>Python Morsels weekly screencasts</h3>

<p>Let&rsquo;s get the self-promotion out of the way first.</p>

<p>I <a href="https://treyhunner.com/2020/11/short-python-screencasts-for-$50-slash-year/">announced a couple days ago</a> that you can now get <strong>one year of Python screencasts</strong> as well as mini-blog posts for <strong>$50/year</strong> (with at least one new screencast each week).
This also includes one Python exercise each month.
I haven&rsquo;t set a concrete end date to this &ldquo;sale&rdquo; (it&rsquo;s actually more of a newly announced service that will be increasing in price in early 2021).</p>

<p>You can <a href="https://treyhunner.com/2020/11/short-python-screencasts-for-$50-slash-year/">find my article on the Python Morsels screencasts sale here</a>.</p>

<h3>Talk Python course bundle</h3>

<p>You can get every Talk Python course that&rsquo;s been made so far <a href="https://training.talkpython.fm/black-friday-2020">for just $250</a>.
There&rsquo;s 28 courses currently and the bundle also includes courses published through October 2021.</p>

<h3>PyBites sales</h3>

<p>PyBites is offering PyBites Premium+ Access for 2 months for $24 and Introductory Bites Course for $15 (both effectively 70% off) during their <a href="https://pybit.es/blackfriday">Black Friday and Cyber Monday sale</a>.</p>

<h3>Reuven Lerner&rsquo;s Python courses and exercises</h3>

<p>Reuven Lerner is offering <a href="https://store.lerner.co.il/?coupon=BF2020">40% off all his products</a> (Python courses, Weekly Python Exercises, and product bundles) through Monday.</p>

<h3>Matt Harrison&rsquo;s Modern Python workshop</h3>

<p>Matt Harrison&rsquo;s <a href="https://mattharrison.podia.com/modern-python-a-hands-on-approach-to-idiomatic-python-projects">Modern Python workshop</a> is $500 (50%) off through Monday with coupon code EARLYBIRD and and <a href="https://mattharrison.podia.com/courses">his other courses</a> (including Python data science and pandas courses) are 40% off through Monday with code BLACKFRIDAY.</p>

<h3>Speed Up Your Django book</h3>

<p>Adam Johnson&rsquo;s <a href="https://adamj.eu/tech/2020/11/28/speed-up-your-django-tests-cyber-monday-deal/">Speed Up Your Django book</a> is 50% off through Monday.
Python Morsels is a Django-powered site and I could use this book, so I&rsquo;ll be buying a copy for myself as well.</p>

<h3>Mike Driscoll&rsquo;s Python books</h3>

<p>Mike Driscoll is <a href="https://www.blog.pythonlibrary.org/2020/11/25/black-friday-cyber-monday-comes-early-in-2020/">offering a sale on all his Python books</a> (each is $15 or less during the sale).</p>

<h3>Brian Okken&rsquo;s Pytest book (Pragmatic Bookshelf)</h3>

<p>Pragmatic Bookshelf is offering 40% off all books with the code turkeysale2020, including <a href="https://pragprog.com/titles/bopytest/python-testing-with-pytest/">Brian Okken&rsquo;s Pytest book</a> which is just under $15 with the coupon.</p>

<h3>No Starch Press Python books</h3>

<p>No Starch Press is also running <a href="https://nostarch.com/catalog/python">a 33% off sale</a> on their Python books (with books by Al Sweigart, Eric Matthes, and many others), though the sale ends before Monday.</p>

<h3>Real Python subscription</h3>

<p>Real Python is offering an annual subscription for <a href="https://realpython.com/account/join/?c=blackfriday2020">$200/year</a> and 20% of that goes to the Python Software Foundation.</p>

<h3>Pluralsight subscription</h3>

<p>We&rsquo;re now moving into &ldquo;I&rsquo;m really not actually sure what you&rsquo;re getting&rdquo; sales.
Pluralsight is running a Black Friday sale this year: <a href="https://www.pluralsight.com/offer/2020/bf-cm-40-off">$180/year for a subscription</a>.
I&rsquo;m not sure whether this is one year for $180 but the subscription renews at the regular price of $300/year or whether it&rsquo;s $180/year indefinitely (the fact that they don&rsquo;t specify is a bit concerning).</p>

<h3>100 Days of Code Python and other Udemy courses</h3>

<p>There&rsquo;s a <a href="https://www.udemy.com/course/100-days-of-code/?couponCode=DCF8D1FDCAA3CE660C34">100 Days of Code Python course</a> course on sale for just $13 on Udemy through mid next week.
I haven&rsquo;t heard anything about it but it looks like it includes <em>a lot</em>.</p>

<p>There are also various other Udemy Python courses on sale, like <a href="https://www.udemy.com/course/automate/">Automate The Boring Stuff</a>, though many of these sales end within the next 24 hours (through Black Friday only).</p>

<h3>Lots of courses, books, screencasts, exercises, live workshops on sale</h3>

<p>Don&rsquo;t go too wild on sales.</p>

<p>I know that I wouldn&rsquo;t want anyone subscribing to Python Morsels unless they think they&rsquo;ll actually commit at least an hour over the next year to watch screencasts.
I imagine many other Python educators feel similar about purchases that go to waste.</p>

<p>Look through the sales above and think about what you could use.
What works well with the way you learn and what would you actually make a habit to use after you&rsquo;ve purchased it?</p>

<p>If you have a question about the <a href="https://treyhunner.com/2020/11/short-python-screencasts-for-$50-slash-year/">Python Morsels screencasts/exercises</a>, email me.
If you have questions about other sales, email the folks running those sales (make sure to do it now in case they take a day or two to get back to you).</p>

<p>Also if you&rsquo;ve found other Python sales I&rsquo;ve missed above, please comment or <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a> to let me know about them.</p>
]]></content>
  </entry>
  
</feed>
