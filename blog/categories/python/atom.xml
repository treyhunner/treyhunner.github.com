<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="https://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://treyhunner.com/"/>
  <updated>2019-07-03T14:33:48-07:00</updated>
  <id>https://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Loop Better: a deeper look at iteration in Python]]></title>
    <link href="https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python/"/>
    <updated>2019-06-18T09:15:00-07:00</updated>
    <id>https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python</id>
    <content type="html"><![CDATA[<p>Python&rsquo;s <code>for</code> loops don&rsquo;t work the way <code>for</code> loops do in other languages.  In this article we&rsquo;re going to dive into Python&rsquo;s <code>for</code> loops to take a look at how they work under the hood and why they work the way they do.</p>

<ol data-toc=".entry-content" data-toc-headings="h2"></ol>


<p><strong>Note</strong>: This article is based on my <a href="https://youtu.be/JYuE8ZiDPl4">Loop Better talk</a>.
It was originally published <a href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python">on opensource.com</a>.</p>

<h2>Looping Gotchas</h2>

<p>We&rsquo;re going to start off our journey by taking a look at some &ldquo;gotchas&rdquo;.  After we&rsquo;ve learned how looping works in Python, we&rsquo;ll take another look at these gotchas and explain what&rsquo;s going on.</p>

<h3>Gotcha 1: Looping Twice</h3>

<p>Let&rsquo;s say we have a list of numbers and a generator that will give us the squares of those numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>We can pass our generator object to the <code>tuple</code> constructor to make a tuple out of it:</p>

<pre><code class="pycon">&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre>

<p>If we then take the same generator object and pass it to the <code>sum</code> function we might expect that we&rsquo;d get the sum of these numbers, which would be 88.</p>

<pre><code class="pycon">&gt;&gt;&gt; sum(squares)
0
</code></pre>

<p>Instead we get <code>0</code>.</p>

<h3>Gotcha 2: Containment Checking</h3>

<p>Let&rsquo;s take the same list of numbers and the same generator object:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we ask whether <code>9</code> is in our <code>squares</code> generator, Python will tell us that 9 <em>is</em> in <code>squares</code>.  But if we ask the <em>same question again</em>, Python will tell us that 9 <em>is not</em> in <code>squares</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; 9 in squares
False
</code></pre>

<p>We asked the same question twice and Python gave us two different answers.</p>

<h3>Gotcha 3: Unpacking</h3>

<p>This dictionary has two key-value pairs:</p>

<pre><code class="pycon">&gt;&gt;&gt; counts = {'apples': 2, 'oranges': 1}
</code></pre>

<p>Let&rsquo;s unpack this dictionary using multiple assignment:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = counts
</code></pre>

<p>You might expect that when unpacking this dictionary, we&rsquo;ll get key-value pairs or maybe that we&rsquo;ll get an error.</p>

<p>But unpacking dictionaries doesn&rsquo;t raise errors and it doesn&rsquo;t return key-value pairs.  When you unpack dictionaries you get keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; x
'apples'
</code></pre>

<p>We&rsquo;ll come back to these gotchas after we&rsquo;ve learned a bit about the logic that powers these Python snippets.</p>

<h2>Review: Python&rsquo;s for loop</h2>

<p>Python doesn&rsquo;t have traditional <code>for</code> loops.  To explain what I mean, let&rsquo;s take a look at a <code>for</code> loop in another programming language.</p>

<p>This is a traditional C-style <code>for</code> loop written in JavaScript:</p>

<pre><code class="javascript">let numbers = [1, 2, 3, 5, 7];
for (let i = 0; i &lt; numbers.length; i += 1) {
    print(numbers[i])
}
</code></pre>

<p>JavaScript, C, C++, Java, PHP, and a whole bunch of other programming languages all have this kind of <code>for</code> loop.  <strong>But Python doesn&rsquo;t</strong>.</p>

<p>Python <strong>does not</strong> have traditional C-style <code>for</code> loops.  We do have something that we <em>call</em> a <code>for</code> loop in Python, but it works like a <a href="https://en.wikipedia.org/wiki/Foreach">foreach loop</a>.</p>

<p>This is Python&rsquo;s flavor of <code>for</code> loop:</p>

<pre><code class="python">numbers = [1, 2, 3, 5, 7]
for n in numbers:
    print(n)
</code></pre>

<p>Unlike traditional C-style <code>for</code> loops, Python&rsquo;s <code>for</code> loops don&rsquo;t have index variables.  There&rsquo;s no index initializing, bounds checking, or index incrementing.  Python&rsquo;s <code>for</code> loops do <em>all the work</em> of looping over our <code>numbers</code> list for us.</p>

<p>So while we do have <code>for</code> loops in Python, we do not have have traditional C-style <code>for</code> loops.  The thing that <em>we</em> call a <code>for</code> loop works very differently.</p>

<h2>Definitions: Iterables and Sequences</h2>

<p>Now that we&rsquo;ve addressed the index-free <code>for</code> loop in our Python room, let&rsquo;s get some definitions out of the way now.</p>

<p>An <strong>iterable</strong> is anything you can loop over with a <code>for</code> loop in Python.
Iterables can be looped over and anything that can be looped over is an iterable.</p>

<pre><code class="python">for item in some_iterable:
    print(item)
</code></pre>

<p>Sequences are a very common type of iterable.
Lists, tuples, and strings are all sequences.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = "hello there"
</code></pre>

<p>Sequences are iterables which have a specific set of features.
They can be indexed starting from <code>0</code> and ending at one less than the length of the sequence, they have a length, and they can be sliced.
Lists, tuples, strings and <em>all other</em> sequences work this way.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers[0]
1
&gt;&gt;&gt; coordinates[2]
7
&gt;&gt;&gt; words[4]
'o'
</code></pre>

<p>Lots of things in Python are iterables, but not all iterables are sequences.  Sets, dictionaries, files, and generators are all iterables but none of these things are sequences.</p>

<pre><code class="pycon">&gt;&gt;&gt; my_set = {1, 2, 3}
&gt;&gt;&gt; my_dict = {'k1': 'v1', 'k2': 'v2'}
&gt;&gt;&gt; my_file = open('some_file.txt')
&gt;&gt;&gt; squares = (n**2 for n in my_set)
</code></pre>

<p>So anything that can be looped over with a <code>for</code> loop is an iterable and sequences are one type of iterable but Python has many other kinds of iterables as well.</p>

<h2>Python&rsquo;s for loops don&rsquo;t use indexes</h2>

<p>You might think that under the hood, Python&rsquo;s <code>for</code> loops use indexes to loop.
Here we&rsquo;re manually looping over an iterable using a <code>while</code> loop and indexes:</p>

<pre><code class="python">numbers = [1, 2, 3, 5, 7]
i = 0
while i &lt; len(numbers):
    print(numbers[i])
    i += 1
</code></pre>

<p>This works for lists, but it won&rsquo;t work for everything.  This way of looping <strong>only works for sequences</strong>.</p>

<p>If we try to manually loop over a set using indexes, we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon', 'apple', 'orange', 'watermelon'}
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; len(fruits):
...     print(fruits[i])
...     i += 1
...
Traceback (most recent call last):
File "&lt;stdin&gt;", line 2, in &lt;module&gt;
TypeError: 'set' object does not support indexing
</code></pre>

<p>Sets are not sequences so they don&rsquo;t support indexing.</p>

<p>We <em>cannot</em> manually loop over every iterable in Python by using indexes.
This simply won&rsquo;t work for iterables that aren&rsquo;t sequences.</p>

<h2>Iterators power for loops</h2>

<p>So we&rsquo;ve seen that Python&rsquo;s <code>for</code> loops must not be using indexes under the hood.
Instead, Python&rsquo;s <code>for</code> loops use <strong>iterators</strong>.</p>

<p>Iterators are the things that power iterables.
You can get an iterator from <em>any</em> iterable.
And you can use an iterator to manually loop over the iterable it came from.</p>

<p>Let&rsquo;s take a look at how that works.</p>

<p>Here are three iterables: a set, a tuple, and a string.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = {1, 2, 3, 5, 7}
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = "hello there"
</code></pre>

<p>We can ask each of these iterables for an <em>iterator</em> using Python&rsquo;s built-in <code>iter</code> function.
Passing an iterable to the <code>iter</code> function will always give us back an iterator, no matter what type of iterable we&rsquo;re working with.</p>

<pre><code class="pycon">&gt;&gt;&gt; iter(numbers)
&lt;set_iterator object at 0x7f2b9271c860&gt;
&gt;&gt;&gt; iter(coordinates)
&lt;tuple_iterator object at 0x7f2b9271ce80&gt;
&gt;&gt;&gt; iter(words)
&lt;str_iterator object at 0x7f2b9271c860&gt;
</code></pre>

<p>Once we have an iterator, the one thing we can do with it is get its next item by passing it to the built-in <code>next</code> function.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; my_iterator = iter(numbers)
&gt;&gt;&gt; next(my_iterator)
1
&gt;&gt;&gt; next(my_iterator)
2
</code></pre>

<p>Iterators are stateful, meaning once you&rsquo;ve consumed an item from them it&rsquo;s gone.</p>

<p>If you ask for the <code>next</code> item from an iterator and there are no more items, you&rsquo;ll get a <code>StopIteration</code> exception:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
3
&gt;&gt;&gt; next(iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>So you can get an iterator from every iterable.
And the only thing that you can do with iterators is ask them for their next item using the <code>next</code> function.
And if you pass them to <code>next</code> but they don&rsquo;t have a next item, a <code>StopIteration</code> exception will be raised.</p>

<p><img src="/images/hello-kitty-pez.jpg" width="512" height="384" title="&ldquo;Hello Kitty PEZ dispenser&rdquo;" ></p>

<p><a href="https://www.flickr.com/photos/30223382@N06/4151828376">Hello Kitty PEZ dispenser photo</a> by Deborah Austin / <a href="https://creativecommons.org/licenses/by/2.0/">CC BY</a></p>

<p>You can think of iterators as like Hello Kitty PEZ dispensers that cannot be reloaded.
You can take PEZ out, but once a PEZ is removed it can&rsquo;t be put back and once the dispenser is empty, it&rsquo;s useless.</p>

<h2>Looping without a for loop</h2>

<p>Now that we&rsquo;ve learned about iterators and the <code>iter</code> and <code>next</code> functions, we&rsquo;re going to try manually looping over an iterable without using a <code>for</code> loop.</p>

<p>We&rsquo;ll do so by attempting to turn this <code>for</code> loop into a <code>while</code> loop:</p>

<pre><code class="python">def funky_for_loop(iterable, action_to_do):
    for item in iterable:
        action_to_do(item)
</code></pre>

<p>To do this we&rsquo;ll:</p>

<ol>
<li>Get an iterator from the given iterable</li>
<li>Repeatedly get the next item from the iterator</li>
<li>Execute the body of the <code>for</code> loop if we successfully got the next item</li>
<li>Stop our loop if we got a <code>StopIteration</code> exception while getting the next item</li>
</ol>


<pre><code class="python">def funky_for_loop(iterable, action_to_do):
    iterator = iter(iterable)
    done_looping = False
    while not done_looping:
        try:
            item = next(iterator)
        except StopIteration:
            done_looping = True
        else:
            action_to_do(item)
</code></pre>

<p>We&rsquo;ve just re-invented a <code>for</code> loop by using a <code>while</code> loop and iterators.</p>

<p>The above code pretty much defines the way looping works under the hood in Python.  If you understand the way the built-in <code>iter</code> and <code>next</code> functions work for looping over things, you understand how Python&rsquo;s <code>for</code> loops work.</p>

<p>In fact you&rsquo;ll understand a little bit more than just how <code>for</code> loops work in Python.  All forms of looping over iterables work this way.</p>

<p><strong>The iterator protocol</strong> is a fancy way of saying &ldquo;how looping over iterables works in Python&rdquo;.
It&rsquo;s essentially the definition of the way the <code>iter</code> and <code>next</code> functions work in Python.
All forms of iteration in Python are powered by the iterator protocol.</p>

<p>The iterator protocol is used by <code>for</code> loops (as we&rsquo;ve already seen):</p>

<pre><code class="python">for n in numbers:
    print(n)
</code></pre>

<p>Multiple assignment also uses the iterator protocol:</p>

<pre><code class="python">x, y, z = coordinates
</code></pre>

<p>Star expressions use the iterator protocol:</p>

<pre><code class="python">a, b, *rest = numbers
print(*numbers)
</code></pre>

<p>And many built-in functions rely on the iterator protocol:</p>

<pre><code class="python">unique_numbers = set(numbers)
</code></pre>

<p>Anything in Python that works with an <em>iterable</em> probably uses the iterator protocol in some way.
Any time you&rsquo;re looping over an iterable in Python, you&rsquo;re relying on the iterator protocol.</p>

<h2>Generators are iterators</h2>

<p>So you might be thinking: iterators seem cool, but they also just seem like an implementation detail and we might not need to <em>care</em> about them as users of Python.</p>

<p>I have news for you: it&rsquo;s very common to work directly with iterators in Python.</p>

<p>The <code>squares</code> object here is a generator:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>And generators are iterators, meaning you can call <code>next</code> on a generator to get its next item:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(squares)
1
&gt;&gt;&gt; next(squares)
4
</code></pre>

<p>But if you&rsquo;ve ever used a generator before, you probably know that you can also loop over generators:</p>

<pre><code class="pycon">&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; for n in squares:
...     print(n)
...
1
4
9
</code></pre>

<p>If you can loop over something in Python, it&rsquo;s an <strong>iterable</strong>.</p>

<p>So <strong>generators are iterators</strong>, but generators are also iterables.  What&rsquo;s going on here?</p>

<h2>I lied to you</h2>

<p>So when I explained how iterators worked earlier, I skipped over an important detail about them.</p>

<p><strong>Iterators are iterables</strong>.</p>

<p>I&rsquo;ll say that again: every iterator in Python is also an iterable, which means you can loop over iterators.</p>

<p>Because iterators are also iterables, you can get an iterator from an iterator using the built-in <code>iter</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; iterator1 = iter(numbers)
&gt;&gt;&gt; iterator2 = iter(iterator1)
</code></pre>

<p>Remember that iterables give us iterators when we call <code>iter</code> on them.</p>

<p>When we call <code>iter</code> on an iterator it will always give us itself back:</p>

<pre><code class="pycon">&gt;&gt;&gt; iterator1 is iterator2
True
</code></pre>

<p>Iterators are iterables and all iterators are their own iterators.</p>

<pre><code class="python">def is_iterator(iterable):
    return iter(iterable) is iterable
</code></pre>

<p>Confused yet?</p>

<p>Let&rsquo;s recap these terms.</p>

<p>An iter<strong>able</strong> is something you&rsquo;re able to iterate over.
An iter<strong>ator</strong> is the agent that actually does the iterating over an iterable.</p>

<p>Additionally, in Python iterators are also iterables and they act as <em>their own</em> iterators.</p>

<p>So iterators are iterables, but they don&rsquo;t have the variety of features that some iterables have.</p>

<p>Iterators have no length and they can&rsquo;t be indexed:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; iterator = iter(numbers)
&gt;&gt;&gt; len(iterator)
TypeError: object of type 'list_iterator' has no len()
&gt;&gt;&gt; iterator[0]
TypeError: 'list_iterator' object is not subscriptable
</code></pre>

<p>From our perspective as Python programmers, the only useful things you can do with an iterator are pass it to the built-in <code>next</code> function or loop over it:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
1
&gt;&gt;&gt; list(iterator)
[2, 3, 5, 7]
</code></pre>

<p>And if we loop over an iterator a second time, we&rsquo;ll get nothing back:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(iterator)
[]
</code></pre>

<p>You can think of iterators are <strong>lazy iterables</strong> that are <strong>single-use</strong>, meaning they can be looped over one time only.</p>

<table>
<thead>
<tr>
<th> Object    </th>
<th> Iterable?        </th>
<th> Iterator?        </th>
</tr>
</thead>
<tbody>
<tr>
<td> Iterable  </td>
<td> &#x2714;&#xfe0f; </td>
<td>         &#x2753; </td>
</tr>
<tr>
<td> Iterator  </td>
<td> &#x2714;&#xfe0f; </td>
<td> &#x2714;&#xfe0f; </td>
</tr>
<tr>
<td> Generator </td>
<td> &#x2714;&#xfe0f; </td>
<td> &#x2714;&#xfe0f; </td>
</tr>
<tr>
<td> List      </td>
<td> &#x2714;&#xfe0f; </td>
<td>         &#x274c; </td>
</tr>
</tbody>
</table>


<p>As you can see in the truth table above, iterables are not always iterators but iterators are always iterables:</p>

<h2>The iterator protocol, in full</h2>

<p>Let&rsquo;s define how iterators work from Python&rsquo;s perspective.</p>

<p>Iterables can be passed to the <code>iter</code> function to get an iterator for them.</p>

<p>Iterators:</p>

<ol>
<li>Can be passed to the <code>next</code> function which will give their next item or raise a <code>StopIteration</code> exception if there are no more items</li>
<li>Can be passed to the <code>iter</code> function and will return themselves back</li>
</ol>


<p>The inverse of these statements also hold true:</p>

<ol>
<li>Anything that can be passed to <code>iter</code> without a <code>TypeError</code> is an iterable</li>
<li>Anything that can be passed to <code>next</code> without a <code>TypeError</code> is an iterator</li>
<li>Anything that returns itself when passed to <code>iter</code> is an iterator</li>
</ol>


<p>That&rsquo;s the iterator protocol in Python.</p>

<h2>Iterators enable laziness</h2>

<p>Iterators allow us to both work with and create <strong>lazy iterables</strong> that don&rsquo;t do any work until we ask them for their next item.
Because we can create lazy iterables, we can make infinitely long iterables.
And we can create iterables that are conservative with system resources, that can save us memory and can save us CPU time.</p>

<h2>Iterators are everywhere</h2>

<p>You&rsquo;ve already seen lots of iterators in Python.
I&rsquo;ve already mentioned that generators are iterators.
Many of Python&rsquo;s built-in classes are iterators also.
For example Python&rsquo;s <code>enumerate</code> and <code>reversed</code> objects are iterators.</p>

<pre><code class="pycon">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; e = enumerate(letters)
&gt;&gt;&gt; e
&lt;enumerate object at 0x7f112b0e6510&gt;
&gt;&gt;&gt; next(e)
(0, 'a')
</code></pre>

<p>In Python 3, <code>zip</code>, <code>map</code>, and <code>filter</code> objects are iterators too.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; z = zip(numbers, letters)
&gt;&gt;&gt; z
&lt;zip object at 0x7f112cc6ce48&gt;
&gt;&gt;&gt; next(z)
(1, 'a')
</code></pre>

<p>And file objects in Python are iterators also.</p>

<pre><code class="pycon">&gt;&gt;&gt; next(open('hello.txt'))
'hello world\n'
</code></pre>

<p>There are lots of iterators bult-in to Python, in the standard library, and in third-party Python libraries.
These iterators all act like lazy iterables by delaying work until the moment you ask them for their next item.</p>

<h2>Creating your own iterator</h2>

<p>It&rsquo;s useful to know that you&rsquo;re already using iterators, but I&rsquo;d like you to also know that you can create your own iterators and your own lazy iterables.</p>

<p>This class makes an iterator that accepts an iterable of numbers and provides squares of each of the numbers as it&rsquo;s looped over.</p>

<pre><code class="python">class square_all:
    def __init__(self, numbers):
        self.numbers = iter(numbers)
    def __next__(self):
        return next(self.numbers) ** 2
    def __iter__(self):
        return self
</code></pre>

<p>But no work will be done until we start looping over an instance of this class.</p>

<p>Here we have an infinitely long iterable <code>count</code> and you can see that <code>square_all</code> accepts <code>count</code> without fully looping over this infinitely long iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; numbers = count(5)
&gt;&gt;&gt; squares = square_all(numbers)
&gt;&gt;&gt; next(squares)
25
&gt;&gt;&gt; next(squares)
36
</code></pre>

<p>This iterator class works, but we don&rsquo;t usually make iterators this way.
Usually when we want to make a custom iterator, we make a generator function:</p>

<pre><code class="python">def square_all(numbers):
    for n in numbers:
        yield n**2
</code></pre>

<p>This generator function is equivalent to the class we made above and it works essentially the same way.</p>

<p>That <code>yield</code> statement probablys seem magical, but it is very powerful: <code>yield</code> allows us to put our generator function on pause between calls from the <code>next</code> function.
The <code>yield</code> statement is the thing that separates generator functions from regular functions.</p>

<p>Another way we could implement this same iterator is with a generator expression.</p>

<pre><code class="python">def square_all(numbers):
    return (n**2 for n in numbers)
</code></pre>

<p>This does the same thing as our generator function but it uses a syntax that looks <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">like a list comprehension</a>.
If you need to make a lazy iterable in your code, think of iterators and consider making a generator function or a generator expression.</p>

<h2>How iterators can improve your code</h2>

<p>Once you&rsquo;ve embraced the idea of using lazy iterables in your code, you&rsquo;ll find that there are lots of possibilities for discovering or creating helper functions that assist you in looping over iterables and processing data.</p>

<h3>Laziness and summing</h3>

<p>This is a <code>for</code> loop that sums up all billable hours in a Django queryset:</p>

<pre><code class="python">hours_worked = 0
for event in events:
    if event.is_billable():
        hours_worked += event.duration
</code></pre>

<p>Here is code that does the same thing using a generator expression for lazy evaluation:</p>

<pre><code class="python">billable_times = (
    event.duration
    for event in events
    if event.is_billable()
)

hours_worked = sum(billable_times)
</code></pre>

<p>Notice that the shape of our code has changed dramatically.</p>

<p>Turning our billable times into a lazy iterable has allowed us to name something (<code>billable_times</code>) that was previously unnamed.
This has also allowed us to use the <code>sum</code> function.  We couldn&rsquo;t have used <code>sum</code> before because we didn&rsquo;t even have an iterable to pass to it.
Iterators allow you to fundamentally change the way you structure your code.</p>

<h3>Laziness and breaking out of loops</h3>

<p>This code prints out the first ten lines of a log file:</p>

<pre><code class="python">for i, line in enumerate(log_file):
    if i &gt;= 10:
        break
    print(line)
</code></pre>

<p>This code does the same thing, but we&rsquo;re using the <code>itertools.islice</code> function to lazily grab the first 10 lines of our file as we loop:</p>

<pre><code class="python">from itertools import islice

first_ten_lines = islice(log_file, 10)
for line in first_ten_lines:
    print(line)
</code></pre>

<p>The <code>first_ten_lines</code> variable we&rsquo;ve made is an iterator.
Again using an iterator allowed us to give a name to something (first ten lines) that was previously unnamed.
Naming things can make our code more descriptive and more readable.</p>

<p>As a bonus we also removed the need for a <code>break</code> statement in our loop because the <code>islice</code> utility handles the breaking for us.</p>

<p>You can find many more iteration helper functions in <a href="https://docs.python.org/3/library/itertools.html">itertools</a> in the standard library as well as in third-party libraries such as <a href="https://boltons.readthedocs.io">boltons</a> and <a href="https://more-itertools.readthedocs.io">more-itertools</a>.</p>

<h3>Creating your own iteration helpers</h3>

<p>You can find helper functions for looping in the standard library and in third-party libraries, but you can also make your own!</p>

<p>This code makes a list of the differences between consecutive values in a sequence.</p>

<pre><code class="python">current = readings[0]
for next_item in readings[1:]:
    differences.append(next_item - current)
    current = next_item
</code></pre>

<p>Notice that this code has an extra variable that we need to assign each time we loop.
Also note that this code only works with things we can slice, like sequences.  If <code>readings</code> were a generator, a zip object, or any other type of iterator this code would fail.</p>

<p>Let&rsquo;s write a helper function to fix our code.</p>

<p>This is a generator function that gives us the current item and the item following it for every item in a given iterable:</p>

<pre><code class="python">def with_next(iterable):
    """Yield (current, next_item) tuples for each item in iterable."""
    iterator = iter(iterable)
    current = next(iterator)
    for next_item in iterator:
        yield current, next_item
        current = next_item
</code></pre>

<p>We&rsquo;re manually getting an iterator from our iterable, calling <code>next</code> on it to grab the first item, and then looping over our iterator to get all subsequent items, keeping track of our last item along the way.
This function works not just with sequences, but with any type of iterable</p>

<p>This is the same code but we&rsquo;re using our helper function instead of manually keeping track of <code>next_item</code>:</p>

<pre><code class="python">differences = []
for current, next_item in with_next(readings):
    differences.append(next_item - current)
</code></pre>

<p>Notice that this code doesn&rsquo;t have awkward assignments to <code>next_item</code> hanging around our loop.
The <code>with_previous</code> generator function handles the work of keeping track of <code>next_item</code> for us.</p>

<p>Also note that this code has been compacted enough that we could even <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-paste our way into a list comprehension</a> if we wanted to.</p>

<pre><code class="python">differences = [
    (next_item - current)
    for current, next_item in with_next(readings)
]
</code></pre>

<h2>Looping Gotchas: Revisited</h2>

<p>At this point we&rsquo;re ready to jump back to those odd examples we saw earlier and try to figure out what was going on.</p>

<h3>Gotcha 1: Exhausting an Iterator</h3>

<p>Here we have a generator object, <code>squares</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we pass this generator to the <code>tuple</code> constructor, we&rsquo;ll get a tuple of its items back:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre>

<p>If we then try to compute the <code>sum</code> of the numbers in this generator, we&rsquo;ll get <code>0</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; sum(squares)
0
</code></pre>

<p>This generator is now empty: we&rsquo;ve exhausted it.
If we try to make a tuple out of it again, we&rsquo;ll get an empty tuple:</p>

<pre><code class="pycon">&gt;&gt;&gt; tuple(squares)
()
</code></pre>

<p>Generators are iterators.
And iterators are single-use iterables.
They&rsquo;re like Hello Kitty PEZ dispensers that cannot be reloaded.</p>

<h3>Gotcha 2: Partially-Consuming an Iterator</h3>

<p>Again we have a generator object, <code>squares</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we ask whether <code>9</code> is in this <code>squares</code> generator, we&rsquo;ll get <code>True</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
True
</code></pre>

<p>But if we ask the same question again, we&rsquo;ll get <code>False</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
False
</code></pre>

<p>When we ask whether <code>9</code> is in this generator, Python has to loop over this generator to find <code>9</code>.
If we kept looping over it after checking for <code>9</code>, we&rsquo;ll only get the last two numbers because we&rsquo;ve already consumed the numbers before this point:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; list(squares)
[25, 49]
</code></pre>

<p>Asking whether something is <em>contained</em> in an iterator will partially consume the iterator.
There is no way to know whether something is in an iterator without starting to loop over it.</p>

<h3>Gotcha 3: Unpacking is iteration</h3>

<p>When you <em>loop</em> over dictionaries you get keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; counts = {'apples': 2, 'oranges': 1}
&gt;&gt;&gt; for key in counts:
...     print(key)
...
apples
oranges
</code></pre>

<p>You also get keys when you unpack a dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = counts
&gt;&gt;&gt; x, y
('apples', 'oranges')
</code></pre>

<p>Looping relies on the iterator protocol.
Iterable unpacking also relies on the iterator protocol.
Unpacking a dictionary is really the same as looping over the dictionary.
Both use the iterator protocol, so you get the same result in both cases.</p>

<h2>Recap and related resources</h2>

<p>Sequences are iterables, but not all iterables are sequences.
When someone says the word &ldquo;iterable&rdquo; you can only assume they mean &ldquo;something that you can iterate over&rdquo;.  Don&rsquo;t assume iterables can be looped over twice, asked for their length, or indexed.</p>

<p>Iterators are the most rudimentary form of iterables in Python.
If you&rsquo;d like to make a lazy iterable in your code think of iterators and consider making a generator function or a generator expression.</p>

<p>And finally, remember that every type of iteration in Python relies on the iterator protocol so understanding the iterator protocol is the key to understanding quite a bit about looping in Python in general.</p>

<p>Here are some related articles and videos I recommend:</p>

<ul>
<li><a href="https://nedbatchelder.com/text/iter.html">Loop Like a Native</a>, Ned Batchelder&rsquo;s PyCon 2013 talk</li>
<li><a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">Loop Better</a>, the talk this article is based on</li>
<li><a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">The Iterator Protocol: How For Loops Work</a>, a short article I wrote on the iterator protocol</li>
<li><a href="https://www.youtube.com/watch?v=5_cJIcgM7rw">Comprehensible Comprehensions</a>, my talk on comprehensions and generator expressions</li>
<li><a href="http://treyhunner.com/2018/02/python-range-is-not-an-iterator/">Python: range is not an iterator</a>, my article on range and iterators</li>
<li><a href="https://www.youtube.com/watch?v=u8g9scXeAcI">Looping Like a Pro in Python</a>, DB&rsquo;s PyCon 2017 talk</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python built-ins worth learning]]></title>
    <link href="https://treyhunner.com/2019/05/python-builtins-worth-learning/"/>
    <updated>2019-05-21T08:40:00-07:00</updated>
    <id>https://treyhunner.com/2019/05/python-builtins-worth-learning</id>
    <content type="html"><![CDATA[<p>In every Intro to Python class I teach, there&rsquo;s always at least one &ldquo;how can we be expected to know all this&rdquo; question.</p>

<p>It&rsquo;s usually along the lines of either:</p>

<ol>
<li>Python has so many functions in it, what&rsquo;s the best way to remember all these?</li>
<li>What&rsquo;s the best way to learn the functions we&rsquo;ll need day-to-day like <code>enumerate</code> and <code>range</code>?</li>
<li>How do you know about all the ways to solve problems in Python?  Do you memorize them?</li>
</ol>


<p>There are dozens of built-in functions and classes, hundreds of tools bundled in Python&rsquo;s <a href="https://docs.python.org/3/library/index.html">standard library</a>, and thousands of third-party libraries on PyPI.
There&rsquo;s no way anyone could ever memorize all of these things.</p>

<p>I recommend triaging your knowledge:</p>

<ol>
<li>Things I should memorize such that I know them well</li>
<li>Things I should know <em>about</em> so I can look them up more effectively later</li>
<li>Things I shouldn&rsquo;t bother with at all until/unless I need them one day</li>
</ol>


<p>We&rsquo;re going to look through the <a href="https://docs.python.org/3/library/functions.html">Built-in Functions page</a> in the Python documentation with this approach in mind.</p>

<p>This will be a very long article, so I&rsquo;ve linked to 5 sub-sections and 20 specific built-in functions in the next section so you can jump ahead if you&rsquo;re pressed for time or looking for one built-in in particular.</p>

<div style="display: none;"><ol data-toc=".entry-content" data-toc-headings="h2,h3,h4"></ol></div>


<h2>Which built-ins should you know about?</h2>

<p>I estimate <strong>most Python developers will only ever need about 30 built-in functions</strong>, but which 30 depends on what you&rsquo;re actually doing with Python.</p>

<p>We&rsquo;re going to take a look at all 69 of Python&rsquo;s built-in functions, in a birds eye view sort of way.</p>

<p>I&rsquo;ll attempt to categorize these built-ins into five categories:</p>

<ol>
<li><strong><a href="#10_Commonly_known_built-in_functions">Commonly known</a></strong>: most newer Pythonistas get exposure to these built-ins pretty quickly out of necessity</li>
<li><strong><a href="#Built-ins_overlooked_by_new_Pythonistas">Overlooked by beginners</a></strong>: these functions are useful to know about, but they&rsquo;re easy to overlook when you&rsquo;re newer to Python</li>
<li><strong><a href="#Learn_it_later">Learn it later</a></strong>: these built-ins are generally useful to know about, but you&rsquo;ll find them when/if you need them</li>
<li><strong><a href="#Maybe_learn_it_eventually">Maybe learn it eventually</a></strong>: these can come in handy, but only in specific circumstances</li>
<li><strong><a href="#You_likely_don%E2%80%99t_need_these">You likely don&rsquo;t need these</a></strong>: you&rsquo;re unlikely to need these unless you&rsquo;re doing something fairly specialized</li>
</ol>


<p>The built-in functions in categories 1 and 2 are the <strong>essential built-ins</strong> that nearly all Python programmers should eventually learn about.
The built-ins in categories 3 and 4 are the <strong>specialized built-ins</strong>, which are often very useful but your need for them will vary based on your use for Python.
And category 5 are <strong>arcane built-ins</strong>, which might be very handy when you need them but which many Python programmers are likely to never need.</p>

<p><strong>Note for pedantic Pythonistas</strong>: I will be referring to all of these built-ins as <strong>functions</strong>, even though 27 of them <strong>aren&rsquo;t actually functions</strong> (as discussed in my <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#The_distinction_between_functions_and_classes_often_doesn%E2%80%99t_matter">functions and callables article</a>).</p>

<p>The commonly known built-in functions (which you likely already know about):</p>

<ol>
<li><a href="#print">print</a></li>
<li><a href="#len">len</a></li>
<li><a href="#str">str</a></li>
<li><a href="#int">int</a></li>
<li><a href="#float">float</a></li>
<li><a href="#list">list</a></li>
<li><a href="#tuple">tuple</a></li>
<li><a href="#dict">dict</a></li>
<li><a href="#set">set</a></li>
<li><a href="#range">range</a></li>
</ol>


<p>The built-in functions which are often overlooked by newer Python programmers:</p>

<ol>
<li><a href="#sum">sum</a></li>
<li><a href="#enumerate">enumerate</a></li>
<li><a href="#zip">zip</a></li>
<li><a href="#bool">bool</a></li>
<li><a href="#reversed">reversed</a></li>
<li><a href="#sorted">sorted</a></li>
<li><a href="#min_and_max">min</a></li>
<li><a href="#min_and_max">max</a></li>
<li><a href="#any_and_all">any</a></li>
<li><a href="#any_and_all">all</a></li>
</ol>


<p>There are also <a href="#The_5_debugging_functions">5 commonly overlooked built-ins</a> which I recommend knowing about solely because they make debugging easier: <code>dir</code>, <code>vars</code>, <code>breakpoint</code>, <code>type</code>, <code>help</code>.</p>

<p>In addition to the 25 built-in functions above, we&rsquo;ll also briefly see the other 44 built-ins in the <a href="#Learn_it_later">learn it later</a> <a href="#Maybe_learn_it_eventually">maybe learn it eventually</a> and <a href="#You_likely_don%E2%80%99t_need_these">you likely don&rsquo;t need these</a> sections.</p>

<h2>10 Commonly known built-in functions</h2>

<p>If you&rsquo;ve been writing Python code, these built-ins are likely familiar already.</p>

<h3>print</h3>

<p>You already know the <code>print</code> function.
Implementing <a href="https://en.wikipedia.org/wiki/Hello_world_program">hello world</a> requires <code>print</code>.</p>

<p>You may not know about the various <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">keyword arguments</a> accepted by <code>print</code> though:</p>

<pre><code class="pycon">&gt;&gt;&gt; words = ["Welcome", "to", "Python"]
&gt;&gt;&gt; print(words)
['Welcome', 'to', 'Python']
&gt;&gt;&gt; print(*words, end="!\n")
Welcome to Python!
&gt;&gt;&gt; print(*words, sep="\n")
Welcome
to
Python
</code></pre>

<p>You can look up <code>print</code> on your own.</p>

<h3>len</h3>

<p>In Python, we don&rsquo;t write things like <code>my_list.length()</code> or <code>my_string.length</code>;
instead we strangely (for new Pythonistas at least) say <code>len(my_list)</code> and <code>len(my_string)</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; words = ["Welcome", "to", "Python"]
&gt;&gt;&gt; len(words)
3
</code></pre>

<p>Regardless of whether you like this operator-like <code>len</code> function, you&rsquo;re stuck with it so you&rsquo;ll need to get used to it.</p>

<h3>str</h3>

<p>Unlike many other programming languages, you cannot concatenate strings and numbers in Python.</p>

<pre><code class="pycon">&gt;&gt;&gt; version = 3
&gt;&gt;&gt; "Python " + version
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can only concatenate str (not "int") to str
</code></pre>

<p>Python refuses to coerce that <code>3</code> integer to a string, so we need to manually do it ourselves, using the built-in <code>str</code> function (class technically, but as I said, I&rsquo;ll be calling these all functions):</p>

<pre><code class="pycon">&gt;&gt;&gt; version = 3
&gt;&gt;&gt; "Python " + str(version)
'Python 3'
</code></pre>

<h3>int</h3>

<p>Do you have user input and need to convert it to a number?
You need the <code>int</code> function!</p>

<p>The <code>int</code> function can convert strings to integers:</p>

<pre><code class="pycon">&gt;&gt;&gt; program_name = "Python 3"
&gt;&gt;&gt; version_number = program_name.split()[-1]
&gt;&gt;&gt; int(version_number)
3
</code></pre>

<p>You can also use <code>int</code> to truncate a floating point number to an integer:</p>

<pre><code class="pycon">&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; sqrt(28)
5.291502622129181
&gt;&gt;&gt; int(sqrt(28))
5
</code></pre>

<p>Note that if you need to truncate while dividing, the <code>//</code> operator is likely more appropriate (though this works differently with negative numbers): <code>int(3 / 2) == 3 // 2</code>.</p>

<h3>float</h3>

<p>Is the string you&rsquo;re converting to a number not actually an integer?
Then you&rsquo;ll want to use <code>float</code> instead of <code>int</code> for this conversion.</p>

<pre><code class="pycon">&gt;&gt;&gt; program_name = "Python 3"
&gt;&gt;&gt; version_number = program_name.split()[-1]
&gt;&gt;&gt; float(version_number)
3.0
&gt;&gt;&gt; pi_digits = '3.141592653589793238462643383279502884197169399375'
&gt;&gt;&gt; len(pi_digits)
50
&gt;&gt;&gt; float(pi_digits)
3.141592653589793
</code></pre>

<p>You can also use <code>float</code> to convert integers to floating point numbers.</p>

<p>In Python 2, we used to use <code>float</code> to convert integers to floating point numbers to force float division instead of integer division.
&ldquo;Integer division&rdquo; isn&rsquo;t a thing anymore in Python 3 (unless you&rsquo;re specifically using the <code>//</code> operator), so we don&rsquo;t need <code>float</code> for that purpose anymore.
So if you ever see <code>float(x) / y</code> in your Python 3 code, you can change that to just <code>x / y</code>.</p>

<h3>list</h3>

<p>Want to make a list out of some other iterable?</p>

<p>The <code>list</code> function does that:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 5, 8]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; squares
&lt;generator object &lt;genexpr&gt; at 0x7fd52dbd5930&gt;
&gt;&gt;&gt; list_of_squares = list(squares)
&gt;&gt;&gt; list_of_squares
[4, 1, 9, 25, 64]
</code></pre>

<p>If you know you&rsquo;re working with a list, you could use the <code>copy</code> method to make a new copy of a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; copy_of_squares = list_of_squares.copy()
</code></pre>

<p>But if you don&rsquo;t know what the iterable you&rsquo;re working with is, the <code>list</code> function is the more general way to loop over an iterable and copy it:</p>

<pre><code class="pycon">&gt;&gt;&gt; copy_of_squares = list(list_of_squares)
</code></pre>

<p>You could also use a list comprehension for this, <a href="https://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python/#Using_comprehensions_when_a_more_specific_tool_exists">but I wouldn&rsquo;t recommend it</a>.</p>

<p>Note that when you want to make an empty list, using the <em>list literal syntax</em> (those <code>[]</code> brackets) is recommended:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_list = list()  # Don't do this
&gt;&gt;&gt; my_list = []  # Do this instead
</code></pre>

<p>Using <code>[]</code> is considered more idiomatic since those square brackets (<code>[]</code>) actually <em>look</em> like a Python list.</p>

<h3>tuple</h3>

<p>The <code>tuple</code> function is pretty much just like the <code>list</code> function, except it makes tuples instead:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; tuple(numbers)
(2, 1, 3, 4, 7)
</code></pre>

<p>If you need a tuple instead of a list, because you&rsquo;re trying to make a <a href="https://lerner.co.il/2015/04/03/is-it-hashable-fun-and-games-with-hashing-in-python/">hashable</a> collection for use in a dictionary key for example, you&rsquo;ll want to reach for <code>tuple</code> over <code>list</code>.</p>

<h3>dict</h3>

<p>The <code>dict</code> function makes a new dictionary.</p>

<p>Similar to like <code>list</code> and <code>tuple</code>, the <code>dict</code> function is equivalent to looping over an iterable of key-value pairs and making a dictionary from them.</p>

<p>Given a list of two-item tuples:</p>

<pre><code class="python">&gt;&gt;&gt; color_counts = [('red', 2), ('green', 1), ('blue', 3), ('purple', 5)]
</code></pre>

<p>This:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors = {}
&gt;&gt;&gt; for color, n in color_counts:
...     colors[color] = n
...
&gt;&gt;&gt; colors
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
</code></pre>

<p>Can instead be done with the <code>dict</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors = dict(color_counts)
&gt;&gt;&gt; colors
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
</code></pre>

<p>The <code>dict</code> function accepts two types of arguments:</p>

<ol>
<li><strong>another dictionary</strong> (<a href="https://docs.python.org/3/glossary.html#term-mapping">mapping</a> is the generic term), in which case that dictionary will be copied</li>
<li><strong>a list of key-value tuples</strong> (more correctly, an iterable of two-item iterables), in which case a new dictionary will be constructed from these</li>
</ol>


<p>So this works as well:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
&gt;&gt;&gt; new_dictionary = dict(colors)
&gt;&gt;&gt; new_dictionary
{'red': 2, 'green': 1, 'blue' 3, 'purple': 5}
</code></pre>

<p>The <code>dict</code> function can also accept keyword arguments to make a dictionary with string-based keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; person = dict(name='Trey Hunner', profession='Python Trainer')
&gt;&gt;&gt; person
{'name': 'Trey Hunner', 'profession': 'Python Trainer'}
</code></pre>

<p>But I very much prefer to use a dictionary literal instead:</p>

<pre><code class="pycon">&gt;&gt;&gt; person = {'name': 'Trey Hunner', 'profession': 'Python Trainer'}
&gt;&gt;&gt; person
{'name': 'Trey Hunner', 'profession': 'Python Trainer'}
</code></pre>

<p>The dictionary literal syntax is more flexible and <a href="https://doughellmann.com/blog/2012/11/12/the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2/">a bit faster</a> but most importantly I find that it more clearly conveys the fact that we are creating a dictionary.</p>

<p>Like with <code>list</code> and <code>tuple</code>, an empty dictionary should be made using the literal syntax as well:</p>

<pre><code class="pycon">&gt;&gt;&gt; my_list = dict()  # Don't do this
&gt;&gt;&gt; my_list = {}  # Do this instead
</code></pre>

<p>Using <code>{}</code> is slightly more CPU efficient, but more importantly it&rsquo;s more idiomatic: it&rsquo;s common to see curly braces (<code>{}</code>) used for making dictionaries but <code>dict</code> is seen much less frequently.</p>

<h3>set</h3>

<p>The <code>set</code> function makes a new set.
It takes an iterable of <a href="https://lerner.co.il/2015/04/03/is-it-hashable-fun-and-games-with-hashing-in-python/">hashable</a> values (strings, numbers, or other immutable types) and returns a <code>set</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 1, 2, 3, 5, 8]
&gt;&gt;&gt; set(numbers)
{1, 2, 3, 5, 8}
</code></pre>

<p>There&rsquo;s no way to make an empty set with the <code>{}</code> set literal syntax (plain <code>{}</code> makes a dictionary), so the <code>set</code> function is the only way to make an empty set:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = set()
&gt;&gt;&gt; numbers
set()
</code></pre>

<p>Actually that&rsquo;s a lie because we have this:</p>

<pre><code class="pycon">&gt;&gt;&gt; {*()}  # This makes an empty set
set()
</code></pre>

<p>But that syntax is confusing (it relies on <a href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/#Asterisks_in_list_literals">a lesser-used feature of the <code>*</code> operator</a>), so I don&rsquo;t recommend it.</p>

<h3>range</h3>

<p>The <code>range</code> function gives us a <code>range</code> object, which represents a range of numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(10_000)
range(0, 10000)
&gt;&gt;&gt; range(-1_000_000_000, 1_000_000_000)
range(-1000000000, 1000000000)
</code></pre>

<p>The resulting range of numbers includes the start number but excludes the stop number (<code>range(0, 10)</code> does not include <code>10</code>).</p>

<p>The <code>range</code> function is useful when you&rsquo;d like to loop over numbers.</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in range(0, 50, 10):
...     print(n)
...
0
10
20
30
40
</code></pre>

<p>A common use case is to do an operation <code>n</code> times (that&rsquo;s a <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">list comprehension</a> by the way):</p>

<pre><code class="python">first_five = [get_things() for _ in range(5)]
</code></pre>

<p>Python 2&rsquo;s <code>range</code> function returned a list, which means the expressions above would make very very large lists.
Python 3&rsquo;s <code>range</code> works like Python 2&rsquo;s <code>xrange</code> (though they&rsquo;re <a href="https://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/">a bit different</a>) in that numbers are <strong>computed lazily</strong> as we loop over these <code>range</code> objects.</p>

<h2>Built-ins overlooked by new Pythonistas</h2>

<p>If you&rsquo;ve been programming Python for a bit or if you just taken an introduction to Python class, you probably already knew about the built-in functions above.</p>

<p>I&rsquo;d now like to show off 15 built-in functions that are very handy to know about, but are more frequently overlooked by new Pythonistas.</p>

<p>The first 10 of these functions you&rsquo;ll find floating around in Python code, but the last 5 you&rsquo;ll most often use while debugging.</p>

<h3>bool</h3>

<p>The <code>bool</code> function checks the <strong>truthiness</strong> of a Python object.</p>

<p>For numbers, truthiness is a question of non-zeroness:</p>

<pre><code class="pycon">&gt;&gt;&gt; bool(5)
True
&gt;&gt;&gt; bool(-1)
True
&gt;&gt;&gt; bool(0)
False
</code></pre>

<p>For collections, truthiness is usually a question of non-emptiness (whether the collection has a length greater than <code>0</code>):</p>

<pre><code class="pycon">&gt;&gt;&gt; bool('hello')
True
&gt;&gt;&gt; bool('')
False
&gt;&gt;&gt; bool(['a'])
True
&gt;&gt;&gt; bool([])
False
&gt;&gt;&gt; bool({})
False
&gt;&gt;&gt; bool({1: 1, 2: 4, 3: 9})
True
&gt;&gt;&gt; bool(range(5))
True
&gt;&gt;&gt; bool(range(0))
False
&gt;&gt;&gt; bool(None)
False
</code></pre>

<p>Truthiness (called <a href="https://docs.python.org/3/library/stdtypes.html#truth">truth value testing</a> in the docs) is kind of a big deal in Python.</p>

<p>Instead of asking questions about the length of a container, many Pythonistas ask questions about truthiness instead:</p>

<pre><code class="python"># Instead of doing this
if len(numbers) == 0:
    print("The numbers list is empty")

# Many of us do this
if not numbers:
    print("The numbers list is empty")
</code></pre>

<p>You likely won&rsquo;t see <code>bool</code> used often, but on the occasion that you need to coerce a value to a boolean to ask about its truthiness, you&rsquo;ll want to know about <code>bool</code>.</p>

<h3>enumerate</h3>

<p>Whenever you need to count upward, one number at a time, while looping over an iterable at the same time, the <code>enumerate</code> function will come in handy.</p>

<p>That might seem like a very niche task, but it comes up quite often.</p>

<p>For example we might want to keep track of the line number in a file:</p>

<pre><code class="python">&gt;&gt;&gt; with open('hello.txt', mode='rt') as my_file:
...     for n, line in enumerate(my_file, start=1):
...         print(f"{n:03}", line)
...
001 This is the first line of the file
002 This is the second line
003 This is the last line of the file
</code></pre>

<p>The <code>enumerate</code> function is also very commonly used to keep track of the <em>index</em> of items in a sequence.</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    for i, item in enumerate(sequence):
        if item != sequence[-(i+1)]:
            return False
    return True
</code></pre>

<p>Note that you may see newer Pythonistas use <code>range(len(sequence))</code> in Python.
If you ever see code with <code>range(len(...))</code>, you&rsquo;ll almost always want to use <code>enumerate</code> instead.</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    for i in range(len(sequence)):
        if sequence[i] != sequence[-(i+1)]:
            return False
    return True
</code></pre>

<p>If <code>enumerate</code> is news to you (or if you often use <code>range(len(...))</code>), see my article on <a href="https://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">looping with indexes in Python</a>.</p>

<h3>zip</h3>

<p>The <code>zip</code> function is even more specialized than <code>enumerate</code>.</p>

<p>The <code>zip</code> function is used for looping over multiple iterables at the same time.</p>

<pre><code class="python">&gt;&gt;&gt; one_iterable = [2, 1, 3, 4, 7, 11]
&gt;&gt;&gt; another_iterable = ['P', 'y', 't', 'h', 'o', 'n']
&gt;&gt;&gt; for n, letter in zip(one_iterable, another_iterable):
...     print(letter, n)
...
P 2
y 1
t 3
h 4
o 7
n 11
</code></pre>

<p>If you ever have to loop over two lists (or any other iterables) at the same time, <code>zip</code> is preferred over <code>enumerate</code>.
The <code>enumerate</code> function is handy when you need indexes while looping, but <code>zip</code> is great when we care specifically about looping over two iterables at once.</p>

<p>If you&rsquo;re new to <code>zip</code>, I also talk about it in my <a href="https://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/#What_if_we_need_to_loop_over_multiple_things?">looping with indexes</a> article.</p>

<p>Both <code>enumerate</code> and <code>zip</code> return iterators to us.
Iterators are the lazy iterables that <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">power <code>for</code> loops</a>.
I have <a href="https://youtu.be/JYuE8ZiDPl4">a whole talk on iterators</a> as well as a somewhat advanced article on <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">how to make your own iterators</a>.</p>

<p>By the way, if you need to use <code>zip</code> on iterables of different lengths, you may want to look up <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest">itertools.zip_longest</a> in the Python standard library.</p>

<h3>reversed</h3>

<p>The <code>reversed</code> function, like <code>enumerate</code> and <code>zip</code>, returns an <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">iterator</a>.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; reversed(numbers)
&lt;list_reverseiterator object at 0x7f3d4452f8d0&gt;
</code></pre>

<p>The only thing we can do with this iterator is loop over it (but only once):</p>

<pre><code class="pycon">&gt;&gt;&gt; reversed_numbers = reversed(numbers)
&gt;&gt;&gt; list(reversed_numbers)
[7, 4, 3, 1, 2]
&gt;&gt;&gt; list(reversed_numbers)
[]
</code></pre>

<p>Like <code>enumerate</code> and <code>zip</code>, <code>reversed</code> is a sort of <strong>looping helper function</strong>.
You&rsquo;ll pretty much see <code>reversed</code> used exclusively in the <code>for</code> part of a <code>for</code> loop:</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in reversed(numbers):
...     print(n)
...
7
4
3
1
2
</code></pre>

<p>There are some other ways to reverse Python lists besides the <code>reversed</code> function:</p>

<pre><code class="python"># Slicing syntax
for n in numbers[::-1]:
    print(n)

# In-place reverse method
numbers.reverse()
for n in numbers:
    print(n)
</code></pre>

<p>But the <code>reversed</code> function is <strong>usually the best way to reverse any iterable</strong> in Python.</p>

<p>Unlike the list <code>reverse</code> method (e.g. <code>numbers.reverse()</code>), <code>reversed</code> doesn&rsquo;t mutate the list (it returns an iterator of the reversed items instead).</p>

<p>Unlike the <code>numbers[::-1]</code> slice syntax, <code>reversed(numbers)</code> doesn&rsquo;t build up a whole new list: the lazy iterator it returns retrieves the next item in reverse as we loop.
Also <code>reversed(numbers)</code> is a lot more readable than <code>numbers[::-1]</code> (which just looks weird if you&rsquo;ve never seen that particular use of slicing before).</p>

<p>If we combine the non-copying nature of the <code>reversed</code> and <code>zip</code> functions, we can rewrite the <code>palindromic</code> function (from <a href="#enumerate">enumerate</a> above) without taking any extra memory (no copying of lists is done here):</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    for n, m in zip(sequence, reversed(sequence)):
        if n != m:
            return False
    return True
</code></pre>

<h3>sum</h3>

<p>The <code>sum</code> function takes an iterable of numbers and returns the sum of those numbers.</p>

<pre><code class="pycon">&gt;&gt;&gt; sum([2, 1, 3, 4, 7])
17
</code></pre>

<p>There&rsquo;s not much more to it than that.</p>

<p>Python has lots of helper functions that <strong>do the looping for you</strong>, partly because they pair nicely with generator expressions:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; sum(n**2 for n in numbers)
524
</code></pre>

<p>If you&rsquo;re curious about generator expressions, I discuss them in my <a href="https://youtu.be/5_cJIcgM7rw">Comprehensible Comprehensions</a> talk (and my <a href="https://pycon2018.trey.io">3 hour tutorial on comprehensions and generator expressions</a>).</p>

<h3>min and max</h3>

<p>The <code>min</code> and <code>max</code> functions do what you&rsquo;d expect: they give you the minimum and maximum items in an iterable.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; min(numbers)
1
&gt;&gt;&gt; max(numbers)
18
</code></pre>

<p>The <code>min</code> and <code>max</code> functions compare the items given to them by using the <code>&lt;</code> operator.
So all values need to be orderable and comparable to each other (fortunately <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/">many objects are orderable in Python</a>).</p>

<p>The <code>min</code> and <code>max</code> functions also accept <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/#Sorting_by_multiple_attributes_at_once">a <code>key</code> function</a> to allow customizing what &ldquo;minimum&rdquo; and &ldquo;maximum&rdquo; really mean for specific objects.</p>

<h3>sorted</h3>

<p>The <code>sorted</code> function takes any iterable and returns a new list of all the values in that iterable in sorted order.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 8, 2, 13, 5, 3, 1]
&gt;&gt;&gt; words = ["python", "is", "lovely"]
&gt;&gt;&gt; sorted(words)
['is', 'lovely', 'python']
&gt;&gt;&gt; sorted(numbers, reverse=True)
[13, 8, 5, 3, 2, 1, 1]
</code></pre>

<p>The <code>sorted</code> function, like <code>min</code> and <code>max</code>, compares the items given to it by using the <code>&lt;</code> operator, so all values given to it need so to be orderable.</p>

<p>The <code>sorted</code> function also allows customization of its sorting via <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/#Sorting_by_multiple_attributes_at_once">a <code>key</code> function</a> (just like <code>min</code> and <code>max</code>).</p>

<p>By the way, if you&rsquo;re curious about <code>sorted</code> versus the <code>list.sort</code> method, Florian Dahlitz wrote <a href="https://blog.usejournal.com/list-sort-vs-sorted-list-aab92c00e17">an article comparing the two</a>.</p>

<h3>any and all</h3>

<p>The <code>any</code> and <code>all</code> functions can be paired with a generator expression to determine whether <em>any</em> or <em>all</em> items in an iterable <strong>match a given condition</strong>.</p>

<p>Our <code>palindromic</code> function from earlier checked whether <em>all</em> items were equal to their corresponding item in the reversed sequence (is the first value equal to the last, second to the second from last, etc.).</p>

<p>We could rewrite <code>palindromic</code> using <code>all</code> like this:</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    return all(
        n == m
        for n, m in zip(sequence, reversed(sequence))
    )
</code></pre>

<p>Negating the condition and the return value from <code>all</code> would allow us to use <code>any</code> equivalently (though this is more confusing in this example):</p>

<pre><code class="python">def palindromic(sequence):
    """Return True if the sequence is the same thing in reverse."""
    return not any(
        n != m
        for n, m in zip(sequence, reversed(sequence))
    )
</code></pre>

<p>If the <code>any</code> and <code>all</code> functions are new to you, you may want to read my article on them: <a href="https://treyhunner.com/2016/11/check-whether-all-items-match-a-condition-in-python/">Checking Whether All Items Match a Condition in Python</a>.</p>

<h3>The 5 debugging functions</h3>

<p>The following 5 functions will be useful for debugging and troubleshooting code.</p>

<h4>breakpoint</h4>

<p>Need to pause the execution of your code and drop into a Python command prompt?
You need <code>breakpoint</code>!</p>

<p>Calling the <code>breakpoint</code> function will drop you into <a href="https://pymotw.com/3/pdb/">pdb</a>, the Python debugger.
There are many tutorials and talks out there on PDB: here&rsquo;s <a href="https://pyvideo.org/pybay-2017/introduction-to-pdb.html">a short one</a> and here&rsquo;s <a href="https://www.youtube.com/watch?v=P0pIW5tJrRM&amp;feature=player_embedded">a long one</a>.</p>

<p>This built-in function was <strong>added in Python 3.7</strong>, but if you&rsquo;re on older versions of Python you can get the same behavior with <code>import pdb ; pdb.set_trace()</code>.</p>

<h4>dir</h4>

<p>The <code>dir</code> function can be used for two things:</p>

<ol>
<li>Seeing a list of all your local variables</li>
<li>Seeing a list of all attributes on a particular object</li>
</ol>


<p>Here we can see that our local variables, right after starting a new Python shell and then after creating a new variable <code>x</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; dir()
['__annotations__', '__doc__', '__name__', '__package__']
&gt;&gt;&gt; x = [1, 2, 3, 4]
&gt;&gt;&gt; dir()
['__annotations__', '__doc__', '__name__', '__package__', 'x']
</code></pre>

<p>If we pass that <code>x</code> list into <code>dir</code> we can see all the attributes it has:</p>

<pre><code class="pycon">&gt;&gt;&gt; dir(x)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
</code></pre>

<p>We can see the typical list methods, <code>append</code>, <code>pop</code>, <code>remove</code>, and more as well as many dunder methods for operator overloading.</p>

<h4>vars</h4>

<p>The <a href="https://docs.python.org/3/library/functions.html#vars">vars</a> function is sort of a mashup of two related things: checking <code>locals()</code> and testing the <code>__dict__</code> attribute of objects.</p>

<p>When <code>vars</code> is called with no arguments, it&rsquo;s equivalent to calling the <code>locals()</code> built-in function (which shows a dictionary of all local variables and their values).</p>

<pre><code class="python">&gt;&gt;&gt; vars()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;}
</code></pre>

<p>When it&rsquo;s called with an argument, it accesses the <code>__dict__</code> attribute on that object (which on many objects represents a dictionary of all instance attributes).</p>

<pre><code class="python">&gt;&gt;&gt; from itertools import chain
&gt;&gt;&gt; vars(chain)
mappingproxy({'__getattribute__': &lt;slot wrapper '__getattribute__' of 'itertools.chain' objects&gt;, '__iter__': &lt;slot wrapper '__iter__' of 'itertools.chain' objects&gt;, '__next__': &lt;slot wrapper '__next__' of 'itertools.chain' objects&gt;, '__new__': &lt;built-in method __new__ of type object at 0x5611ee76fac0&gt;, 'from_iterable': &lt;method 'from_iterable' of 'itertools.chain' objects&gt;, '__reduce__': &lt;method '__reduce__' of 'itertools.chain' objects&gt;, '__setstate__': &lt;method '__setstate__' of 'itertools.chain' objects&gt;, '__doc__': 'chain(*iterables) --&gt; chain object\n\nReturn a chain object whose .__next__() method returns elements from the\nfirst iterable until it is exhausted, then elements from the next\niterable, until all of the iterables are exhausted.'})
</code></pre>

<p>If you ever try to use <code>my_object.__dict__</code>, you can use <code>vars</code> instead.</p>

<p>I usually reach for <code>dir</code> just before using <code>vars</code>.</p>

<h4>type</h4>

<p>The <code>type</code> function will tell you the type of the object you pass to it.</p>

<p>The type of a class instance is the class itself:</p>

<pre><code class="pycon">&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; type(x)
&lt;class 'list'&gt;
</code></pre>

<p>The type of a class is its metaclass, which is usually <code>type</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; type(list)
&lt;class 'type'&gt;
&gt;&gt;&gt; type(type(x))
&lt;class 'type'&gt;
</code></pre>

<p>If you ever see someone reach for <code>__class__</code>, know that they could reach for the higher-level <code>type</code> function instead:</p>

<pre><code class="pycon">&gt;&gt;&gt; x.__class__
&lt;class 'list'&gt;
&gt;&gt;&gt; type(x)
&lt;class 'list'&gt;
</code></pre>

<p>The <code>type</code> function is sometimes helpful in actual code (especially object-oriented code with inheritance and custom string representations), but it&rsquo;s also useful when debugging.</p>

<p>Note that when <em>type checking</em>, the <code>isinstance</code> function is usually used instead of <code>type</code> (also note that we tend not to type check in Python because we prefer to practice <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>).</p>

<h4>help</h4>

<p>If you&rsquo;re in an interactive Python shell (the Python <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> as I usually call it), maybe debugging code using <code>breakpoint</code>, and you&rsquo;d like to know how a certain object, method, or attribute works, the <code>help</code> function will come in handy.</p>

<p>Realistically, you&rsquo;ll likely resort to getting help from your favorite search engine more often than using <code>help</code>.
But if you&rsquo;re already in a Python REPL, it&rsquo;s quicker to call <code>help(list.insert)</code> than it would be to look up the <code>list.insert</code> method documentation in Google.</p>

<h2>Learn it later</h2>

<p>There are quite a few built-in functions you&rsquo;ll likely want <em>eventually</em>, but you may not need <em>right now</em>.</p>

<p>I&rsquo;m going to mention 14 more built-in functions which are handy to know about, but not worth learning until you actually need to use them.</p>

<h3>open</h3>

<p>Need to open a file in Python?
You need the <code>open</code> function!</p>

<p>Don&rsquo;t work with files directly?
Then you likely don&rsquo;t need the <code>open</code> function!</p>

<p>You might think it&rsquo;s odd that I&rsquo;ve put <code>open</code> in this section because working with files is so common.
While most programmers will read or write to files using <code>open</code> at some point, some Python programmers, such as Django developers, may not use the <code>open</code> function very much (if at all).</p>

<p>Once you need to work with files, you&rsquo;ll learn about <code>open</code>.
Until then, don&rsquo;t worry about it.</p>

<p>By the way, you might want to <a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/">look into pathlib</a> (which is in the Python standard library) as an alternative to using <code>open</code>.
I love the <code>pathlib</code> module so much I&rsquo;ve considered teaching files in Python by mentioning <code>pathlib</code> first and the built-in <code>open</code> function later.</p>

<h3>input</h3>

<p>The <code>input</code> function prompts the user for input, waits for them to hit the Enter key, and then returns the text they typed.</p>

<p>Reading from <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)">standard input</a> (which is what the <code>input</code> function does) is one way to get inputs into your Python program, but there are so many other ways too!
You could accept command-line arguments, read from a configuration file, read from a database, and much more.</p>

<p>You&rsquo;ll learn this once you need to prompt the user of a command-line program for input.
Until then, you won&rsquo;t need it.
And if you&rsquo;ve been writing Python for a while and don&rsquo;t know about this function, you may simply never need it.</p>

<h3>repr</h3>

<p>Need the programmer-readable representation of an object?
You need the <code>repr</code> function!</p>

<p>For many objects, the <code>str</code> and <code>repr</code> representations are the same:</p>

<pre><code class="pycon">&gt;&gt;&gt; str(4), repr(4)
('4', '4')
&gt;&gt;&gt; str([]), repr([])
('[]', '[]')
</code></pre>

<p>But for some objects, they&rsquo;re different:</p>

<pre><code class="pycon">&gt;&gt;&gt; str('hello'), repr("hello")
('hello', "'hello'")
&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; str(date(2020, 1, 1)), repr(date(2020, 1, 1))
('2020-01-01', 'datetime.date(2020, 1, 1)')
</code></pre>

<p>The string representation we see at the Python REPL uses <code>repr</code>, while the <code>print</code> function relies on <code>str</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; date(2020, 1, 1)
datetime.date(2020, 1, 1)
&gt;&gt;&gt; "hello!"
'hello!'
&gt;&gt;&gt; print(date(2020, 1, 1))
2020-01-01
&gt;&gt;&gt; print("hello!")
hello!
</code></pre>

<p>You&rsquo;ll see <code>repr</code> used when logging, handling exceptions, and implementing dunder methods.</p>

<h3>super</h3>

<p>If you create classes in Python, you&rsquo;ll likely need to use <code>super</code>.
The <code>super</code> function is pretty much essential whenever you&rsquo;re inheriting from another Python class.</p>

<p>Many Python users rarely create classes.
Creating classes isn&rsquo;t an <em>essential</em> part of Python, though many types of programming require it.
For example, you can&rsquo;t really use the <a href="https://djangoproject.com/">Django</a> web framework without creating classes.</p>

<p>If you don&rsquo;t already know about <code>super</code>, you&rsquo;ll end up learning this if and when you need it.</p>

<h3>property</h3>

<p>The <code>property</code> function is a <a href="https://docs.python.org/3/glossary.html#term-decorator">decorator</a> and a <a href="https://docs.python.org/3/glossary.html#term-descriptor">descriptor</a> (only click those weird terms if you&rsquo;re extra curious) and it&rsquo;ll likely seem somewhat magical when you first learn about it.</p>

<p>This decorator allows us to create an attribute which will always seem to contain the return value of a particular function call.
It&rsquo;s easiest to understand with an example.</p>

<p>Here&rsquo;s a class that uses <code>property</code>:</p>

<pre><code class="python">class Circle:

    def __init__(self, radius=1):
        self.radius = radius

    @property
    def diameter(self):
        return self.radius * 2
</code></pre>

<p>Here&rsquo;s an access of that <code>diameter</code> attribute on a <code>Circle</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; circle = Circle()
&gt;&gt;&gt; circle.diameter
2
&gt;&gt;&gt; circle.radius = 5
&gt;&gt;&gt; circle.diameter
10
</code></pre>

<p>If you&rsquo;re doing object-oriented Python programming (you&rsquo;re making classes a whole bunch), you&rsquo;ll likely want to learn about <code>property</code> at some point.
Unlike other object-oriented programming languages, <strong>we use properties instead of getter methods and setter methods</strong>.</p>

<h3>issubclass and isinstance</h3>

<p>The <code>issubclass</code> function checks whether a class is a subclass of one or more other classes.</p>

<pre><code class="pycon">&gt;&gt;&gt; issubclass(int, bool)
False
&gt;&gt;&gt; issubclass(bool, int)
True
&gt;&gt;&gt; issubclass(bool, object)
True
</code></pre>

<p>The <code>isinstance</code> function checks whether an object is an instance of one or more classes.</p>

<pre><code class="pycon">&gt;&gt;&gt; isinstance(True, str)
False
&gt;&gt;&gt; isinstance(True, bool)
True
&gt;&gt;&gt; isinstance(True, int)
True
&gt;&gt;&gt; isinstance(True, object)
True
</code></pre>

<p>You can think of <code>isinstance</code> as delegating to <code>issubclass</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; issubclass(type(True), str)
False
&gt;&gt;&gt; issubclass(type(True), bool)
True
&gt;&gt;&gt; issubclass(type(True), int)
True
&gt;&gt;&gt; issubclass(type(True), object)
True
</code></pre>

<p>If you&rsquo;re <a href="https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations">overloading operators</a> (e.g. customizing what the <code>+</code> operator does on your class) you might need to use <code>isinstance</code>, but in general we try to avoid strong type checking in Python so we don&rsquo;t see these much.</p>

<p>In Python we usually prefer duck typing over type checking.
These functions actually do a bit more than the strong type checking I noted above (<a href="https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks">the behavior of both can be customized</a>) so it&rsquo;s actually possible to practice a sort of <code>isinstance</code>-powered duck typing with abstract base classes like <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable">collections.abc.Iterable</a>.
But this isn&rsquo;t seen much either (partly because we tend to practice exception-handling and <a href="https://docs.python.org/3/glossary.html#term-eafp">EAFP</a> a bit more than condition-checking and <a href="https://docs.python.org/3/glossary.html#term-lbyl">LBYL</a> in Python).</p>

<p>The last two paragraphs were filled with confusing jargon that I may explain more thoroughly in a future serious of articles if there&rsquo;s enough interest.</p>

<h3>hasattr, getattr, setattr, and delattr</h3>

<p>Need to work with an attribute on an object but the attribute name is dynamic?
You need <code>hasattr</code>, <code>getattr</code>, <code>setattr</code>, and <code>delattr</code>.</p>

<p>Say we have some <code>thing</code> object we want to check for a particular value on:</p>

<pre><code class="pycon">&gt;&gt;&gt; class Thing: pass
...
&gt;&gt;&gt; thing = Thing()
</code></pre>

<p>The <code>hasattr</code> function allows us to check whether the object <em>has</em> a certain attribute (note that <code>hasattr</code> <a href="https://hynek.me/articles/hasattr/">has some quirks</a>, though most have been ironed out in Python 3):</p>

<pre><code class="pycon">&gt;&gt;&gt; hasattr(thing, 'x')
False
&gt;&gt;&gt; thing.x = 4
&gt;&gt;&gt; hasattr(thing, 'x')
True
</code></pre>

<p>The <code>getattr</code> function allows us to retrieve the value of that attribute (with an optional default if the attribute doesn&rsquo;t exist):</p>

<pre><code class="pycon">&gt;&gt;&gt; getattr(thing, 'x')
4
&gt;&gt;&gt; getattr(thing, 'x', 0)
4
&gt;&gt;&gt; getattr(thing, 'y', 0)
0
</code></pre>

<p>The <code>setattr</code> function allows for setting the value:</p>

<pre><code class="pycon">&gt;&gt;&gt; setattr(thing, 'x', 5)
&gt;&gt;&gt; thing.x
5
</code></pre>

<p>And <code>delattr</code> deletes the attribute:</p>

<pre><code class="pycon">&gt;&gt;&gt; delattr(thing, 'x')
&gt;&gt;&gt; thing.x
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Thing' object has no attribute 'x'
</code></pre>

<p>These functions allow for a specific flavor of <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> and you likely won&rsquo;t see them often.</p>

<h3>classmethod and staticmethod</h3>

<p>The <code>classmethod</code> and <code>staticmethod</code> decorators are somewhat magical in the same way the <code>property</code> decorator is somewhat magical.</p>

<p>If you have a method that should be callable on either an instance or a class, you want the <code>classmethod</code> decorator.
Factory methods (alternative constructors) are a common use case for this:</p>

<pre><code class="python">class RomanNumeral:

    """A Roman numeral, represented as a string and numerically."""

    def __init__(self, number):
        self.value = number

    @classmethod
    def from_string(cls, string):
        return cls(roman_to_int(string))  # function doesn't exist yet
</code></pre>

<p>It&rsquo;s a bit harder to come up with a good use for <code>staticmethod</code>, since you can pretty much always use a module-level function instead of a static method.</p>

<pre><code class="python">class RomanNumeral:

    """A Roman numeral, represented as a string and numerically."""

    SYMBOLS = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}

    def __init__(self, number):
        self.value = number

    @classmethod
    def from_string(cls, string):
        return cls(cls.roman_to_int(string))

    @staticmethod
    def roman_to_int(numeral):
        total = 0
        for symbol, next_symbol in zip_longest(numeral, numeral[1:]):
            value = RomanNumeral.SYMBOLS[symbol]
            next_value = RomanNumeral.SYMBOLS.get(next_symbol, 0)
            if value &lt; next_value:
                value = -value
            total += value
        return total
</code></pre>

<p>The above <code>roman_to_int</code> function doesn&rsquo;t require access to the instance <em>or</em> the class, so it doesn&rsquo;t even need to be a <code>@classmethod</code>.
There&rsquo;s no actual need to make this function a <code>staticmethod</code> (instead of a <code>classmethod</code>): <code>staticmethod</code> is just more restrictive to signal the fact that we&rsquo;re not reliant on the class our function lives on.</p>

<p>I find that learning these causes folks to <em>think</em> they need them when they often don&rsquo;t.
You can go looking for these if you really need them eventually.</p>

<h3>next</h3>

<p>The <code>next</code> function returns the <em>next</em> item in an iterator.</p>

<p>I&rsquo;ve written about iterators before (<a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">how for loops work</a> and <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">how to make an iterator</a>) but a very quick summary of iterators you&rsquo;ll likely run into includes:</p>

<ul>
<li><code>enumerate</code> objects</li>
<li><code>zip</code> objects</li>
<li>the return value of the <code>reversed</code> function</li>
<li>files (the thing you get back from the <code>open</code> function)</li>
<li><code>csv.reader</code> objects</li>
<li>generator expressions</li>
<li>generator functions</li>
</ul>


<p>You can think of <code>next</code> as a way to manually loop over an iterator to get a single item and then break.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; next(squares)
4
&gt;&gt;&gt; for n in squares:
...     break
...
&gt;&gt;&gt; n
1
&gt;&gt;&gt; next(squares)
9
</code></pre>

<h2>Maybe learn it eventually</h2>

<p>We&rsquo;ve already covered nearly half of the built-in functions.</p>

<p>The rest of Python&rsquo;s built-in functions definitely aren&rsquo;t useless, but they&rsquo;re a bit more special-purposed.</p>

<p>The 15 built-ins I&rsquo;m mentioning in this section are things you may eventually need to learn, but it&rsquo;s also very possible you&rsquo;ll never reach for these in your own code.</p>

<ul>
<li><strong><a href="https://docs.python.org/3/library/functions.html#iter">iter</a></strong>: get an iterator from an iterable: this function <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">powers <code>for</code> loops</a> and it can be very useful when you&rsquo;re making helper functions for looping lazily</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#callable">callable</a></strong>: return <code>True</code> if the argument is a callable (I talked about this a bit in my article <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#Callable_objects">functions and callables</a>)</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#filter">filter</a></strong> and <strong><a href="https://docs.python.org/3/library/functions.html#map">map</a></strong>: as I discuss in my article on <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/">overusing lambda functions</a>, I recommend using generator expressions over the built-in <code>map</code> and <code>filter</code> functions</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#id">id</a></strong>, <strong><a href="https://docs.python.org/3/library/functions.html#locals">locals</a></strong>, and <strong><a href="https://docs.python.org/3/library/functions.html#globals">globals</a></strong>: these are great tools for teaching Python and you may have already seen them, but you won&rsquo;t see these much in real Python code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#round">round</a></strong>: you&rsquo;ll look this up if you need to round a number</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#divmod">divmod</a></strong>: this function does a floor division (<code>//</code>) and a modulo operation (<code>%</code>) at the same time</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#bin">bin</a></strong>, <strong><a href="https://docs.python.org/3/library/functions.html#oct">oct</a></strong>, and <strong><a href="https://docs.python.org/3/library/functions.html#hex">hex</a></strong>: if you need to display a number as a string in binary, octal, or hexadecimal form, you&rsquo;ll want these functions</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#abs">abs</a></strong>: when you need the absolute value of a number, you&rsquo;ll look this up</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#hash">hash</a></strong>: dictionaries and sets rely on the <code>hash</code> function to test for <a href="https://lerner.co.il/2015/04/03/is-it-hashable-fun-and-games-with-hashing-in-python/">hashability</a>, but you likely won&rsquo;t need it unless you&rsquo;re implementing a clever de-duplication algorithm</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#object">object</a></strong>: this function (yes it&rsquo;s a class) is useful for making <a href="https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/">unique default values and sentinel values</a>, if you ever need those</li>
</ul>


<p>You&rsquo;re unlikely to need all the above built-ins, but if you write Python code for long enough you&rsquo;re likely to see nearly all of them.</p>

<h2>You likely don&rsquo;t need these</h2>

<p>You&rsquo;re unlikely to need these built-ins.
There are sometimes really appropriate uses for a few of these, but you&rsquo;ll likely be able to get away with never learning about these.</p>

<ul>
<li><strong><a href="https://docs.python.org/3/library/functions.html#ord">ord</a></strong> and <strong><a href="https://docs.python.org/3/library/functions.html#chr">chr</a></strong>: these are fun for teaching ASCII tables and unicode code points, but I&rsquo;ve never really found a use for them in my own code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#exec">exec</a></strong> and <strong><a href="https://docs.python.org/3/library/functions.html#eval">eval</a></strong>: for evaluating a string as if it was code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#compile">compile</a></strong>: this is related to <code>exec</code> and <code>eval</code></li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#slice">slice</a></strong>: if you&rsquo;re implementing <code>__getitem__</code> to make a custom sequence, you may need this (some <a href="https://www.pythonmorsels.com/">Python Morsels</a> exercises require this actually), but unless you make your own custom sequence you&rsquo;ll likely never see <code>slice</code></li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#bytes">bytes</a></strong>, <strong><a href="https://docs.python.org/3/library/functions.html#bytearray">bytearray</a></strong>, and <strong><a href="https://docs.python.org/3/library/functions.html#memoryview">memoryview</a></strong>: if you&rsquo;re working with bytes often, you&rsquo;ll reach for some of these (just ignore them until then)</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#ascii">ascii</a></strong>: like <code>repr</code> but returns an ASCII-only representation of an object; I haven&rsquo;t needed this in my code yet</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#frozenset">frozenset</a></strong>: like <code>set</code>, but it&rsquo;s immutable (and hashable!); very neat but not something I&rsquo;ve needed in my own code</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#__import__">__import__</a></strong>: this function isn&rsquo;t really meant to be used by you, use <a href="https://docs.python.org/3/library/importlib.html#importlib.import_module">importlib</a> instead</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#format">format</a></strong>: this calls the <code>__format__</code> method, which is used for string formatting (<a href="https://docs.python.org/3/reference/lexical_analysis.html#f-strings">f-strings</a> and <a href="https://docs.python.org/3/library/stdtypes.html#str.format">str.format</a>); you usually don&rsquo;t need to call this function directly</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#pow">pow</a></strong>: the exponentiation operator (<code>**</code>) usually supplants this&hellip; unless you&rsquo;re doing modulo-math (maybe you&rsquo;re implementing <a href="http://code.activestate.com/recipes/578838-rsa-a-simple-and-easy-to-read-implementation/">RSA encryption</a> from scratch&hellip;?)</li>
<li><strong><a href="https://docs.python.org/3/library/functions.html#complex">complex</a></strong>: if you didn&rsquo;t know that <code>4j+3</code> is valid Python code, you likely don&rsquo;t need the <code>complex</code> function</li>
</ul>


<h2>There&rsquo;s always more to learn</h2>

<p>There are 69 built-in functions in Python (technically <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#The_distinction_between_functions_and_classes_often_doesn%E2%80%99t_matter">only 42 of them are actually functions</a>).</p>

<p>When you&rsquo;re newer in your Python journey, I recommend focusing on only 20 of these built-in functions in your own code (the <a href="#10_Commonly_known_built-in_functions">10 commonly known built-ins</a> and the <a href="#Built-ins_overlooked_by_new_Pythonistas">10 built-ins that are often overlooked</a>), in addition to the <a href="#The_5_debugging_functions">5 debugging functions</a>.</p>

<p>After that there are <a href="#Learn_it_later">14 more built-ins which you&rsquo;ll probably learn later</a> (depending on the style of programming you do).</p>

<p>Then come <a href="#Maybe_learn_it_eventually">the 15 built-ins which you may or may not ever end up needing in your own code</a>.
Some people love these built-ins and some people never use them: as you get more specific in your coding needs, you&rsquo;ll likely find yourself reaching for considerably more niche tools.</p>

<p>After that I mentioned <a href="#You_likely_don%E2%80%99t_need_these">the last 15 built-ins which you&rsquo;ll likely never need</a> (again, very much depending on how you use Python).</p>

<p>You don&rsquo;t need to learn all the Python built-in functions today.
Take it slow: focus on those first 20 important built-ins and then work your way into learning about others if and when you eventually need them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is it a class or a function? It's a callable!]]></title>
    <link href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/"/>
    <updated>2019-04-16T10:20:00-07:00</updated>
    <id>https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable</id>
    <content type="html"><![CDATA[<p>If you search course curriculum I&rsquo;ve written, you&rsquo;ll often find phrases like &ldquo;<code>zip</code> function&rdquo;, &ldquo;<code>enumerate</code> function&rdquo;, and &ldquo;<code>list</code> function&rdquo;.
Those terms are all technically misnomers.</p>

<p>When I use terms like &ldquo;the <code>bool</code> function&rdquo; and &ldquo;the <code>str</code> function&rdquo; I&rsquo;m incorrectly implying that <code>bool</code> and <code>str</code> are functions.
But these <strong>aren&rsquo;t functions: they&rsquo;re classes</strong>!</p>

<p>I&rsquo;m going to explain why this confusion between classes and functions happens in Python and then explain <strong>why this distinction often doesn&rsquo;t matter</strong>.</p>

<ul data-toc=".entry-content"></ul>


<h2>Class or function?</h2>

<p>When I&rsquo;m training a new group of Python developers, there&rsquo;s group activity we often do: the class or function game.</p>

<p>In <strong>the class or function game</strong>, we take something that we &ldquo;call&rdquo; (using parenthesis: <code>()</code>) and we guess whether it&rsquo;s a class or a function.</p>

<p>For example:</p>

<ul>
<li>We can call <code>zip</code> with a couple iterables and we get another iterable back, so is <code>zip</code> a class or a function?</li>
<li>When we call <code>len</code>, are we calling a class or a function?</li>
<li>What about <code>int</code>: when we write <code>int('4')</code> are we calling a class or a function?</li>
</ul>


<p>Python&rsquo;s <code>zip</code>, <code>len</code>, and <code>int</code> are all often guessed to be functions, but <strong>only one of these is really a function</strong>:</p>

<pre><code class="pycon">&gt;&gt;&gt; zip
&lt;class 'zip'&gt;
&gt;&gt;&gt; len
&lt;built-in function len&gt;
&gt;&gt;&gt; int
&lt;class 'int'&gt;
</code></pre>

<p>While <code>len</code> is a function, <code>zip</code> and <code>int</code> are classes.</p>

<p>The <code>reversed</code>, <code>enumerate</code>, <code>range</code>, and <code>filter</code> &ldquo;functions&rdquo; also aren&rsquo;t really functions:</p>

<pre><code class="pycon">&gt;&gt;&gt; reversed
&lt;class 'reversed'&gt;
&gt;&gt;&gt; enumerate
&lt;class 'enumerate'&gt;
&gt;&gt;&gt; range
&lt;class 'range'&gt;
&gt;&gt;&gt; filter
&lt;class 'filter'&gt;
</code></pre>

<p>After playing the class or function game, we always discuss <strong>callables</strong>, and then we discuss the fact that <strong>we often don&rsquo;t care whether something is a class or a function</strong>.</p>

<h2>What&rsquo;s a callable?</h2>

<p>A <strong>callable</strong> is anything you can <em>call</em>, using parenthesis, and possibly passing arguments.</p>

<p>All three of these lines involve callables:</p>

<pre><code class="pycon">&gt;&gt;&gt; something()
&gt;&gt;&gt; x = AnotherThing()
&gt;&gt;&gt; something_else(4, 8, *x)
</code></pre>

<p>We don&rsquo;t know what <code>something</code>, <code>AnotherThing</code>, and <code>something_else</code> do: but we <em>know</em> they&rsquo;re callables.</p>

<p>We have a number of callables in Python:</p>

<ul>
<li>Functions are callables</li>
<li>Classes are callables</li>
<li>Methods (which are functions that hang off of classes) are callables</li>
<li>Instances of classes can even be turned into callables</li>
</ul>


<p>Callables are a pretty important concept in Python.</p>

<h2>Classes are callables</h2>

<p>Functions are the most obvious callable in Python.
Functions can be &ldquo;called&rdquo; in every programming language.
A <em>class</em> being callable is a bit more unique though.</p>

<p>In JavaScript we can make an &ldquo;instance&rdquo; of the <code>Date</code> class like this:</p>

<pre><code class="javascript">&gt; new Date(2020, 1, 1, 0, 0)
2020-02-01T08:00:00.000Z
</code></pre>

<p>In JavaScript the class instantiation syntax (the way we create an &ldquo;instance&rdquo; of a class) involves the <code>new</code> keyword.
In Python we don&rsquo;t have a <code>new</code> keyword.</p>

<p>In Python we can make an &ldquo;instance&rdquo; of the <code>datetime</code> class (from <code>datetime</code>) like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; datetime(2020, 1, 1, 0, 0)
datetime.datetime(2020, 1, 1, 0, 0)
</code></pre>

<p>In Python, the syntax for <strong>instantiating a new class instance</strong> is the same as the syntax for <strong>calling a function</strong>.
There&rsquo;s no <code>new</code> needed: we just call the class.</p>

<p>When we <strong>call a function</strong>, we get its return value.
When we <strong>call a class</strong>, we get an &ldquo;instance&rdquo; of that class.</p>

<p><strong>We use the same syntax for constructing objects from classes and for calling functions</strong>: this fact is the main reason the word &ldquo;callable&rdquo; is such an important part of our Python vocabulary.</p>

<h2>Disguising classes as functions</h2>

<p>There are many classes-which-look-like-functions among the Python built-ins and in the Python standard library.</p>

<p>I sometimes explain <strong>decorators</strong> (an intermediate-level Python concept) as &ldquo;functions which accept functions and return functions&rdquo;.</p>

<p>But that&rsquo;s not an entirely accurate explanation.
There are also <strong>class decorators</strong>: functions which accept classes and return classes.
And there are also <strong>decorators which are implemented using classes</strong>: classes which accept functions and return objects.</p>

<p>A better explanation of the term decorators might be &ldquo;callables which accept callables and return callables&rdquo; (still not entirely accurate, but good enough for our purposes).</p>

<p>Python&rsquo;s <a href="https://docs.python.org/3/library/functions.html#property">property</a> decorator seems like a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; class Circle:
...     def __init__(self, radius):
...         self.radius = radius
...     @property
...     def diameter(self):
...         return self.radius * 2
...
&gt;&gt;&gt; c = Circle(5)
&gt;&gt;&gt; c.diameter
10
</code></pre>

<p>But it&rsquo;s a class:</p>

<pre><code class="pycon">&gt;&gt;&gt; property
&lt;class 'property'&gt;
</code></pre>

<p>The <code>classmethod</code> and <code>staticmethod</code> decorators are <em>also</em> classes:</p>

<pre><code class="pycon">&gt;&gt;&gt; classmethod
&lt;class 'classmethod'&gt;
&gt;&gt;&gt; staticmethod
&lt;class 'staticmethod'&gt;
</code></pre>

<p>What about context managers, like <a href="https://docs.python.org/3.5/library/contextlib.html#contextlib.suppress">suppress</a> and <a href="https://docs.python.org/3/library/contextlib.html#contextlib.redirect_stdout">redirect_stdout</a> from the <code>contextlib</code> module?
These both use the <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> naming convention, so they seem like functions:</p>

<pre><code class="pycon">&gt;&gt;&gt; from contextlib import suppress
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; with suppress(ValueError):
...     int('hello')
...
&gt;&gt;&gt; with redirect_stdout(StringIO()) as fake_stdout:
...     print('hello!')
...
&gt;&gt;&gt; fake_stdout.getvalue()
'hello!\n'
</code></pre>

<p>But they&rsquo;re actually <strong>implemented using classes</strong>, despite the <code>snake_case</code> naming convention:</p>

<pre><code class="pycon">&gt;&gt;&gt; suppress
&lt;class 'contextlib.suppress'&gt;
&gt;&gt;&gt; redirect_stdout
&lt;class 'contextlib.redirect_stdout'&gt;
</code></pre>

<p>Decorators and context managers are just two places in Python where you&rsquo;ll often see callables which look like functions but aren&rsquo;t.
Whether a <strong>callable</strong> is a class or a function is often <strong>just an implementation detail</strong>.</p>

<p>It&rsquo;s not really a mistake to refer to <code>property</code> or <code>redirect_stdout</code> as functions because <strong>they may as well be functions</strong>.
We can <strong>call</strong> them, and that&rsquo;s what we care about.</p>

<h2>Callable objects</h2>

<p>Python&rsquo;s &ldquo;call&rdquo; syntax, those <code>(...)</code> parenthesis, can <strong>create a class instance</strong> or <strong>call a function</strong>.
But this &ldquo;call&rdquo; syntax can <strong>also be used to call an object</strong>.</p>

<p>Technically, everything in Python &ldquo;is an object&rdquo;:</p>

<pre><code class="pycon">&gt;&gt;&gt; isinstance(len, object)
True
&gt;&gt;&gt; isinstance(range, object)
True
&gt;&gt;&gt; isinstance(range(5), object)
True
</code></pre>

<p>But we often use the term &ldquo;object&rdquo; to imply that we&rsquo;re working with an instance of a class (by <em>instance of a class</em> I mean &ldquo;the thing you get back when you call a class&rdquo;).</p>

<p>There&rsquo;s a <a href="https://docs.python.org/3.5/library/functools.html#functools.partial">partial</a> function which lives in the <code>functools</code> module, which can &ldquo;partially evaluate&rdquo; a function by storing arguments to be used when calling the function later.
This is often used to make Python look a bit more like a functional programming language:</p>

<pre><code class="pycon">&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; just_numbers = partial(filter, str.isdigit)
&gt;&gt;&gt; list(just_numbers(['4', 'hello', '50']))
['4', '50']
</code></pre>

<p>I said above that Python has &ldquo;a <code>partial</code> function&rdquo;, which is both true and false.</p>

<p>While the phrase &ldquo;a <code>partial</code> function&rdquo; makes sense, the <code>partial</code> callable <strong>isn&rsquo;t implemented using a function</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; partial
&lt;class '__main__.partial'&gt;
</code></pre>

<p>The Python core developers <em>could</em> have implemented <code>partial</code> as a function, like this:</p>

<pre><code class="python">def partial(func, *args, **kwargs):
    """Return "partially evaluated" version of given function/arguments."""
    def wrapper(*more_args, **more_kwargs):
        all_kwargs = {**kwargs, **more_kwargs}
        return func(*args, *more_args, **all_kwargs)
    return wrapper
</code></pre>

<p>But instead they chose to use a class, doing something more like this:</p>

<pre><code class="python">class partial:
    """Return "partially evaluated" version of given function/arguments."""
    def __init__(self, func, *args, **kwargs):
        self.func, self.args, self.kwargs = func, args, kwargs
    def __call__(self, *more_args, **more_kwargs):
        all_kwargs = {**self.kwargs, **more_kwargs}
        return self.func(*self.args, *more_args, **all_kwargs)
</code></pre>

<p>That <code>__call__</code> method allows us to <em>call</em> <code>partial</code> objects.
So the <code>partial</code> class makes a <strong>callable object</strong>.</p>

<p>Adding a <code>__call__</code> method to any class will <strong>make instances of that class callable</strong>.
In fact, checking for a <code>__call__</code> method is one way to ask the question &ldquo;is this object callable?&rdquo;</p>

<p>All functions, classes, and callable objects have a <code>__call__</code> method:</p>

<pre><code class="pycon">&gt;&gt;&gt; hasattr(open, '__call__')
True
&gt;&gt;&gt; hasattr(dict, '__call__')
True
&gt;&gt;&gt; hasattr({}, '__call__')
False
</code></pre>

<p>Though a better way to check for callability than looking for a <code>__call__</code> is to use the built-in <code>callable</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; callable(len)
True
&gt;&gt;&gt; callable(list)
True
&gt;&gt;&gt; callable([])
False
</code></pre>

<p>In Python, classes, functions, and instances of classes can all be used as &ldquo;callables&rdquo;.</p>

<h2>The distinction between functions and classes often doesn&rsquo;t matter</h2>

<p>The Python documentation has a page called <a href="https://docs.python.org/3/library/functions.html#built-in-funcs">Built-in Functions</a>.
But this Built-in Functions page <strong>isn&rsquo;t actually for built-in functions</strong>: it&rsquo;s for built-in callables.</p>

<p>Of the 69 &ldquo;built-in functions&rdquo; listed in the Python Built-In Functions page, <strong>only 42 are actually implemented as functions</strong>: 26 are classes and 1 (<code>help</code>) is an instance of a callable class.</p>

<p>Of the 26 classes among those built-in &ldquo;functions&rdquo;, four <em>were</em> actually functions in Python 2 (the now-lazy <code>map</code>, <code>filter</code>, <code>range</code>, and <code>zip</code>) but have since become classes.</p>

<p>The Python built-ins and the standard library are both full of maybe-functions-maybe-classes.</p>

<h3>operator.itemgetter</h3>

<p>The <code>operator</code> module has lots of callables:</p>

<pre><code class="pycon">&gt;&gt;&gt; from operator import getitem, itemgetter
&gt;&gt;&gt; get_a_and_b = itemgetter('a', 'b')
&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; get_a_and_b(d)
(1, 2)
&gt;&gt;&gt; getitem(d, 'a'), getitem(d, 'b')
(1, 2)
</code></pre>

<p>Some of these callables (like <a href="https://docs.python.org/3.5/library/operator.html#operator.itemgetter">itemgetter</a> are <em>callable classes</em>) while others (like <code>getitem</code>) are functions:</p>

<pre><code class="pycon">&gt;&gt;&gt; itemgetter
&lt;class 'operator.itemgetter'&gt;
&gt;&gt;&gt; get_a_and_b
operator.itemgetter('a', 'b')
&gt;&gt;&gt; getitem
&lt;built-in function getitem&gt;
</code></pre>

<p>The <code>itemgetter</code> class <em>could</em> have been implemented as &ldquo;a function that returns a function&rdquo;.
Instead it&rsquo;s a class which implements a <code>__call__</code> method, so its class instances are callable.</p>

<h3>Iterators</h3>

<p>Generator functions are functions which return iterators when called (<a href="https://youtu.be/V2PkkMS2Ack?t=858">generators are iterators</a>):</p>

<pre><code class="python">def count(n=0):
    """Generator that counts upward forever."""
    while True:
        yield n
        n += 1
</code></pre>

<p>And <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">iterator classes</a> are classes which return iterators when called:</p>

<pre><code class="python">class count:
    """Iterator that counts upward forever."""
    def __init__(self, n=0):
        self.n = n
    def __iter__(self):
        return self
    def __next__(self):
        n = self.n
        self.n += 1
        return n
</code></pre>

<p>Iterators can be defined using functions or using classes: whichever you choose is an implementation detail.</p>

<h3>The sorted &ldquo;key function&rdquo;</h3>

<p>The built-in <a href="https://docs.python.org/3.5/library/functions.html#sorted">sorted</a> function has an optional <code>key</code> argument, which is called to get &ldquo;comparison keys&rdquo; for sorting (<code>min</code> and <code>max</code> have a similar <code>key</code> argument).</p>

<p>This <code>key</code> argument can be a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; def digit_count(s): return len(s.replace('_', ''))
...
&gt;&gt;&gt; numbers = ['400', '2_020', '800_000']
&gt;&gt;&gt; sorted(numbers, key=digit_count)
['400', '2_020', '800_000']
</code></pre>

<p>But it can also be a class:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = ['400', '2_020', '800_000']
&gt;&gt;&gt; sorted(numbers, key=int)
['400', '2_020', '800_000']
</code></pre>

<p>The Python documentation says &ldquo;key specifies a function of one argument&hellip;&rdquo;.
That&rsquo;s not <em>technically</em> correct because key can be any callable, not just a function.
But <strong>we often use the words &ldquo;function&rdquo; and &ldquo;callable&rdquo; interchangeably</strong> in Python, and that&rsquo;s okay.</p>

<h3>The defaultdict &ldquo;factory function&rdquo;</h3>

<p>The <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">defaultdict</a> class in the <code>collections</code> module accepts a &ldquo;factory&rdquo; callable, which is used to generate default values for missing dictionary items.</p>

<p>Usually we use a class as a <code>defaultdict</code> factory:</p>

<pre><code class="pycon">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; counts = defaultdict(int)
&gt;&gt;&gt; counts['snakes']
0
&gt;&gt;&gt; things = defaultdict(list)
&gt;&gt;&gt; things['newer'].append('Python 3')
&gt;&gt;&gt; things['newer']
['Python 3']
</code></pre>

<p>But <code>defaultdict</code> can also accept a function (or any other callable):</p>

<pre><code class="pycon">&gt;&gt;&gt; import random
&gt;&gt;&gt; colors = ['blue', 'yellow', 'purple', 'green']
&gt;&gt;&gt; favorite_colors = defaultdict(lambda: random.choice(colors))
&gt;&gt;&gt; favorite_colors['Kevin']
'yellow'
&gt;&gt;&gt; favorite_colors['Stacy']
'green'
&gt;&gt;&gt; probabilities = defaultdict(random.random)
&gt;&gt;&gt; probabilities['having fun']
0.6714530824158086
&gt;&gt;&gt; probabilities['seeing a snake']
0.07703364911089605
</code></pre>

<p>Pretty much anywhere a &ldquo;callable&rdquo; is accepted in Python, a function, a class, or some other callable object will work just fine.</p>

<h2>Think in terms of &ldquo;callables&rdquo; not &ldquo;classes&rdquo; or &ldquo;functions&rdquo;</h2>

<p>In the <a href="https://www.pythonmorsels.com/">Python Morsels</a> exercises I send out every week, I often ask learners to make a &ldquo;callable&rdquo;.
Often I&rsquo;ll say something like &ldquo;this week I&rsquo;d like you to make a callable which returns an iterator&hellip;&rdquo;.</p>

<p>I say &ldquo;callable&rdquo; because I want <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">an iterator</a> back, but I really don&rsquo;t care whether the callable created is a <strong>generator function</strong>, an <strong>iterator class</strong>, or a <strong>function that returns a generator expression</strong>.
All of these things are <em>callables</em> which return the right type that I&rsquo;m testing for (an iterator).
It&rsquo;s up to you, the implementor of this callable, to determine how you&rsquo;d like to define it.</p>

<p>We practice <strong>duck typing</strong> in Python: <strong>if it looks like a duck and quacks like a duck, it&rsquo;s a duck</strong>.
Because of duck typing we tend to use general terms to describe specific things: lists are sequences, iterators are generators, dictionaries are mappings, and functions are callables.</p>

<p>If something looks like a callable and quacks (or rather, calls) like a callable, it&rsquo;s a callable.
Likewise, if something looks like a function and quacks (calls) like a function, we can call it a function&hellip; <strong>even if it&rsquo;s actually implemented using a class or a callable object</strong>!</p>

<p>Callables accept arguments and return something useful to the caller.
When we <em>call</em> classes we get instances of that class back.
When we <em>call</em> functions we get the return value of that function back.
The distinction between a class and a function is <strong>rarely important from the perspective of the caller</strong>.</p>

<p>When talking about passing functions or class objects around, try to think in terms of <em>callables</em>.
<strong>What happens when you call something</strong> is often more important than <strong>what that thing actually is</strong>.</p>

<p>More importantly though, if someone mislabels a function as a class or a class as a function, <strong>don&rsquo;t correct them unless the distinction is actually relevant</strong>.
A function is a callable and a class is a callable: the distinction between these two can often be disregarded.</p>

<h2>Want some practice with callables?</h2>

<p>You don&rsquo;t learn by putting more information into your head.
You learn through recall, that is trying to retrieve information for your head.</p>

<p>If you&rsquo;d like to get some practice with the <code>__call__</code> method, if you&rsquo;d like to make your own iterable/iterator-returning callables, or if you just want to practice working with &ldquo;callables&rdquo;, I have a Python Morsels exercise for you.</p>

<p>Python Morsels is a weekly Python skill-building service.
I send one exercise every week and the first 5 are free.</p>

<p>If you sign up for Python Morsels using the below form, I&rsquo;ll send you one callable-related exercise of your choosing (choose using the selection below).</p>

<h4>Which Python exercise would you like right now?</h4>

<p><form method="post" action="https://www.pythonmorsels.com/accounts/signup/">
    <label><input type="radio" name="exercise_track" value="callables1"> Novice exercise with a bonus involving callables</label>
    <br>
    <label><input type="radio" name="exercise_track" value="callables2"> Making a callable which returns an iterable</label>
    <br>
    <label><input type="radio" name="exercise_track" value="callables3"> Making an iterator-returning callable</label>
    <br>
    <label><input type="radio" name="exercise_track" value="callables4">Advanced exercise with bonuses showing the downside of <code>__call__</code></label>
    <br>
    <br>
    <input type="hidden" name="form_id" value="callables">
    <input type="email" name="email" placeholder="Your email address" class="subscribe-email form-big" required>
    <button type="submit" class="subscribe-btn form-big">Get my Python Morsels exercise</button>
    <br>
    <small>
    You can <a href="https://www.pythonmorsels.com/privacy/">find the Privacy Policy for Python Morsels here</a>.
    </small>
</form></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The problem with inheriting from dict and list in Python]]></title>
    <link href="https://treyhunner.com/2019/04/why-you-shouldnt-inherit-from-list-and-dict-in-python/"/>
    <updated>2019-04-09T07:00:00-07:00</updated>
    <id>https://treyhunner.com/2019/04/why-you-shouldnt-inherit-from-list-and-dict-in-python</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve created dozens of [Python Morsels][] since I started it last year.
At this point at least 10 of these exercises involve making a custom collection: often a dict-like, list-like or set-like class.</p>

<p>Since each Python Morsels solutions email involves a walk-through of many ways to solve the same problem, I&rsquo;ve solved each of these in many ways.</p>

<p>I&rsquo;ve solved these:</p>

<ul>
<li>manually with <code>__dunder__</code> methods</li>
<li>with the abstract base classes in [collections.abc][]</li>
<li>with [collections.UserDict][UserDict] and [collections.UserList][UserList]</li>
<li>by inheriting from <code>list</code>, <code>dict</code>, and <code>set</code> directly</li>
</ul>


<p>While creating and solving many exercises involving custom collections, I&rsquo;ve realized that inheriting from <code>list</code>, <code>dict</code>, and <code>set</code> is often subtly painful.
I&rsquo;m writing this article to explain why I often don&rsquo;t recommend inheriting from these built-in classes in Python.</p>

<p>My examples will focus on <code>dict</code> and <code>list</code> since those are likely more commonly sub-classed.</p>

<ul data-toc=".entry-content"></ul>


<h2>Making a custom dictionary</h2>

<p>We&rsquo;d like to make a dictionary that&rsquo;s bi-directional.
When a key-value pair is added, the key maps to the value but the value also maps to the key.</p>

<p>There will always be an even number of elements in this dictionary.
And if <code>d[k] == v</code> is <code>True</code> then <code>d[v] == k</code> will always be <code>True</code> also.</p>

<p>We could try to implement this by customizing deletion and setting of key-value pairs.</p>

<pre><code class="python">class TwoWayDict(dict):
    def __delitem__(self, key):
        value = super().pop(key)
        super().pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        super().__setitem__(key, value)
        super().__setitem__(value, key)
    def __repr__(self):
        return f"{type(self).__name__}({super().__repr__()})"
</code></pre>

<p>Here we&rsquo;re ensuring that:</p>

<ul>
<li>deleting keys will delete their corresponding values as well</li>
<li>whenever we set a new value for <code>k</code>, that any existing value will be removed properly</li>
<li>whenever we set a key-value pair, that the corresponding value-key pair will be set too</li>
</ul>


<p>Setting and deleting items from this bi-directional dictionary seems to work as we&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict()
&gt;&gt;&gt; d[3] = 8
&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 3})
&gt;&gt;&gt; d[7] = 6
&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 3, 7: 6, 6: 7})
</code></pre>

<p>But calling the <code>update</code> method on this dictionary leads to odd behavior:</p>

<pre><code class="python">&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 3, 7: 6, 6: 7})
&gt;&gt;&gt; d.update({9: 7, 8: 2})
&gt;&gt;&gt; d
TwoWayDict({3: 8, 8: 2, 7: 6, 6: 7, 9: 7})
</code></pre>

<p>Adding <code>9: 7</code> should have removed <code>7: 6</code> and <code>6: 7</code> and adding <code>8: 2</code> should have removed <code>3: 8</code> and <code>8: 3</code>.</p>

<p>We could fix this with a custom <code>update</code> method:</p>

<pre><code class="python">    def update(self, items):
        if isinstance(items, dict):
            items = items.items()
        for key, value in items:
            self[key] = value
</code></pre>

<p>But calling the initializer doesn&rsquo;t work either:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict({9: 7, 8: 2})
&gt;&gt;&gt; d
TwoWayDict({9: 7, 8: 2})
</code></pre>

<p>So we&rsquo;ll make a custom initializer that calls <code>update</code>:</p>

<pre><code class="python">    def __init__(self, items=()):
        self.update(items)
</code></pre>

<p>But <code>pop</code> doesn&rsquo;t work:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict()
&gt;&gt;&gt; d[9] = 7
&gt;&gt;&gt; d
TwoWayDict({9: 7, 7: 9})
&gt;&gt;&gt; d.pop(9)
7
&gt;&gt;&gt; d
TwoWayDict({7: 9}
</code></pre>

<p>And neither does <code>setdefault</code>:</p>

<pre><code class="python">&gt;&gt;&gt; d = TwoWayDict()
&gt;&gt;&gt; d.setdefault(4, 2)
2
&gt;&gt;&gt; d
TwoWayDict({4: 2})
</code></pre>

<p>The problem is the <code>pop</code> method doesn&rsquo;t actually call <code>__delitem__</code> and the <code>setdefault</code> method doesn&rsquo;t actually call <code>__setitem__</code>.</p>

<p>If we wanted to fix this problem, we have to completely re-implement <code>pop</code> and <code>setdefault</code>:</p>

<pre><code class="python">DEFAULT = object()

class TwoWayDict(dict):
    # ...
    def pop(self, key, default=DEFAULT):
        if key in self or default is DEFAULT:
            value = self[key]
            del self[key]
            return value
        else:
            return default
    def setdefault(self, key, value):
        if key not in self:
            self[key] = value
</code></pre>

<p>This is all very tedious though.
When inheriting from <code>dict</code> to create a custom dictionary, we&rsquo;d expect <code>update</code> and <code>__init__</code> would call <code>__setitem__</code> and <code>pop</code> and <code>setdefault</code> would call <code>__delitem__</code>.
But they don&rsquo;t!</p>

<p>Likewise, <code>get</code> and <code>pop</code> don&rsquo;t call <code>__getitem__</code>, as you might expect they would.</p>

<h2>Lists and sets have the same problem</h2>

<p>The <code>list</code> and <code>set</code> classes have similar problems to the <code>dict</code> class.
Let&rsquo;s take a look at an example.</p>

<p>We&rsquo;ll make a custom list that inherits from the <code>list</code> constructor and overrides the behavior of <code>__delitem__</code>, <code>__iter__</code>, and <code>__eq__</code>.
This list will customize <code>__delitem__</code> to not actually <em>delete</em> an item but to instead leave a &ldquo;hole&rdquo; where that item used to be.
The <code>__iter__</code> and <code>__eq__</code> methods will skip over this hole when comparing two <code>HoleList</code> classes as &ldquo;equal&rdquo;.</p>

<p>This class is a bit nonsensical (no it&rsquo;s not a Python Morsels exercise fortunately), but we&rsquo;re focused less on the class itself and more on the issue with inheriting from <code>list</code>:</p>

<pre><code class="python">class HoleList(list):

    HOLE = object()

    def __delitem__(self, index):
        self[index] = self.HOLE

    def __iter__(self):
        return (
            item
            for item in super().__iter__()
            if item is not self.HOLE
        )

    def __eq__(self, other):
        if isinstance(other, HoleList):
            return all(
                x == y
                for x, y in zip(self, other)
            )
        return super().__eq__(other)

    def __repr__(self):
        return f"{type(self).__name__}({super().__repr__()})"
</code></pre>

<p>Unrelated Aside: if you&rsquo;re curious about that <code>object()</code> thing, I explain why it&rsquo;s useful in [my article about sentinel values in Python][sentinel values].</p>

<p>If we make two <code>HoleList</code> objects and delete items from them such that they have the same non-hole items:</p>

<pre><code class="python">&gt;&gt;&gt; x = HoleList([2, 1, 3, 4])
&gt;&gt;&gt; y = HoleList([1, 2, 3, 5])
&gt;&gt;&gt; del x[0]
&gt;&gt;&gt; del y[1]
&gt;&gt;&gt; del x[-1]
&gt;&gt;&gt; del y[-1]
</code></pre>

<p>We&rsquo;ll see that they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; list(x), list(y)
([1, 3], [1, 3])
&gt;&gt;&gt; x
HoleList([&lt;object object at 0x7f56bdf38120&gt;, 1, 3, &lt;object object at 0x7f56bdf38120&gt;])
&gt;&gt;&gt; y
HoleList([1, &lt;object object at 0x7f56bdf38120&gt;, 3, &lt;object object at 0x7f56bdf38120&gt;])
</code></pre>

<p>But if we then ask them whether they&rsquo;re <em>not equal</em> we&rsquo;ll see that they&rsquo;re both <em>equal</em> and <em>not equal</em>:</p>

<pre><code class="python">&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x != y
True
&gt;&gt;&gt; list(x), list(y)
([1, 3], [1, 3])
&gt;&gt;&gt; x
HoleList([&lt;object object at 0x7f56bdf38120&gt;, 1, 3, &lt;object object at 0x7f56bdf38120&gt;])
&gt;&gt;&gt; y
HoleList([1, &lt;object object at 0x7f56bdf38120&gt;, 3, &lt;object object at 0x7f56bdf38120&gt;])
</code></pre>

<p>Normally in Python 3, overriding <code>__eq__</code> would customize the behavior of both equality (<code>==</code>) and inequality (<code>!=</code>) checks.
But not for <code>list</code> or <code>dict</code>: they define both <code>__eq__</code> and <code>__ne__</code> methods which means we need to override both.</p>

<pre><code class="python">    def __ne__(self, other):
        return not (self == other)
</code></pre>

<p>Dictionaries suffer from this same problem: <code>__ne__</code> exists which means we need to be careful to override both <code>__eq__</code> and <code>__ne__</code> when inheriting from them.</p>

<p>Also like dictionaries, the <code>remove</code> and <code>pop</code> methods on lists don&rsquo;t call <code>__delitem__</code>:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>y
HoleList([1, <object object at 0x7f56bdf38120>, 3, <object object at 0x7f56bdf38120>])
y.remove(1)
y
HoleList([<object object at 0x7f56bdf38120>, 3, <object object at 0x7f56bdf38120>])
y.pop(0)</p></blockquote></blockquote></blockquote>

<p><object object at 0x7f56bdf38120></p>

<blockquote><blockquote><blockquote><p>y
HoleList([3, <object object at 0x7f56bdf38120>])
```</p></blockquote></blockquote></blockquote>

<p>We could again fix these issues by re-implementing the <code>remove</code> and <code>pop</code> methods:</p>

<pre><code class="python">    def remove(self, value):
        index = self.index(value)
        del self[index]
    def pop(self, index=-1):
        value = self[index]
        del self[index]
        return value
</code></pre>

<p>But this is a pain.
And who knows whether we&rsquo;re done?</p>

<p>Every time we customize a bit of core functionality on a <code>list</code> or <code>dict</code> subclass, we&rsquo;ll need to make sure we customize other methods that also include exactly the same functionality (but which don&rsquo;t delegate to the method we overrode).</p>

<h2>Why did the Python developers do this?</h2>

<p>From my understanding, the built-in <code>list</code>, <code>dict</code>, and <code>set</code> types have in-lined a lot of code for performance.
Essentially, they&rsquo;ve copy-pasted the same code between many different functions to avoid extra function calls and make things a tiny bit faster.</p>

<p>I haven&rsquo;t found a reference online that explains why this decision was made and what the consequences of the alternatives to this choice were.
But I mostly trust that this was done for my benefit as a Python developer.
If <code>dict</code> and <code>list</code> weren&rsquo;t faster this way, why would the core developers have chosen this odd implementation?</p>

<h2>What&rsquo;s the alternative to inheriting from list and dict?</h2>

<p>So inheriting from <code>list</code> to make a custom list was painful and inheriting from <code>dict</code> to create a custom dictionary was painful.
What&rsquo;s the alternative?</p>

<p>How can we create a custom dictionary-like object that <em>doesn&rsquo;t</em> inherit from the built-in <code>dict</code>?</p>

<p>There are a few ways to create custom dictionaries:</p>

<ol>
<li>Fully embrace duck typing: figure out everything you need for your data structure to be <code>dict</code>-like and create a completely custom class (that walks and quacks like a <code>dict</code>)</li>
<li>Inherit from a helper class that&rsquo;ll point us in the right direction and tell us which methods our object needs to be <code>dict</code>-like</li>
<li>Find a more extensible re-implementation of <code>dict</code> and inherit from it instead</li>
</ol>


<p>We&rsquo;re going to skip over the first approach: reimplementing everything from scratch will take a while and Python has some helpers that&rsquo;ll make things easier.
We&rsquo;re going to take a look at those helpers, first the ones that point us in the right direction (2 above) and then the ones that act as full <code>dict</code>-replacements (3 above).</p>

<h3>Abstract base classes: they&rsquo;ll help you quack like a duck</h3>

<p>Python&rsquo;s [collections.abc][] module includes <strong>abstract base classes</strong> that can help us implement some of the common protocols (<em>interfaces</em> as Java calls them) seen in Python.</p>

<p>We&rsquo;re trying to make a dictionary-like object.
Dictionaries are <strong>mutable mappings</strong>.
A dictionary-like object is a mapping.
That word &ldquo;mapping&rdquo; comes from &ldquo;hash map&rdquo;, which is what many other programming languages call this kind of data structure.</p>

<p>So we want to make a mutable mapping.
The <code>collections.abc</code> module provides an abstract base class for that: <code>MutableMapping</code>!</p>

<p>If we inherit from this abstract base class, we&rsquo;ll see that we&rsquo;re required to implement certain methods for it to work:</p>

<pre><code class="python">&gt;&gt;&gt; from collections.abc import MutableMapping
&gt;&gt;&gt; class TwoWayDict(MutableMapping):
...     pass
...
&gt;&gt;&gt; d = TwoWayDict()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: Can't instantiate abstract class TwoWayDict with abstract methods __delitem__, __getitem__, __iter__, __len__, __setitem__
</code></pre>

<p>The <code>MutableMapping</code> class requires us to say how getting, deleting, and setting items works, how iterating works, and how we get the length of our dictionary.
But once we do that, we&rsquo;ll get the <code>pop</code>, <code>clear</code>, <code>update</code>, and <code>setdefault</code> methods for free!</p>

<p>Here&rsquo;s a re-implementation of <code>TwoWayDict</code> using the <code>MutableMapping</code> abstract base class:</p>

<pre><code class="python">from collections.abc import MutableMapping


class TwoWayDict(MutableMapping):
    def __init__(self, data=()):
        self.mapping = {}
        self.update(data)
    def __getitem__(self, key):
        return self.mapping[key]
    def __delitem__(self, key):
        value = self[key]
        del self.mapping[key]
        self.pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        self.mapping[key] = value
        self.mapping[value] = key
    def __iter__(self):
        return iter(self.mapping)
    def __len__(self):
        return len(self.mapping)
    def __repr__(self):
        return f"{type(self).__name__}({self.mapping})"
</code></pre>

<p>Unlike <code>dict</code>, these <code>update</code> and <code>setdefault</code> methods will call our <code>__setitem__</code> method and the <code>pop</code> and <code>clear</code> methods will call our <code>__delitem__</code> method.</p>

<p>Abstract base classes might make you think we&rsquo;re leaving the wonderful land of Python duck typing behind for some sort of strongly-typed [OOP][] land.
But abstract base classes actually enhance duck typing.
<strong>Inheriting from abstract base classes helps us be better ducks</strong>.
We don&rsquo;t have to worry about whether we&rsquo;ve implemented all the behaviors that make a mutable mapping because the abstract base class will yell at us if we forgot to specify some essential behavior.</p>

<p>The <code>HoleList</code> class we made before would need to inherit from the <code>MutableSequence</code> abstract base class.
A custom set-like class would probably inherit from the <code>MutableSet</code> abstract base class.</p>

<h3>UserList/UserDict: lists and dictionaries that are actually extensible</h3>

<p>When using the collection ABCs, <code>Mapping</code>, <code>Sequence</code>, <code>Set</code> (and their mutable children) you&rsquo;ll often find yourself creating a wrapper around an existing data structure.
If you&rsquo;re implementing a dictionary-like object, using a dictionary under the hood makes things easier: the same applies for lists and sets.</p>

<p>Python actually includes two even higher level helpers for creating list-like and dictionary-like classes which <strong>wrap around <code>list</code> and <code>dict</code> objects</strong>.
These two classes live in the [collections][] module as [UserList][] and [UserDict][].</p>

<p>Here&rsquo;s a re-implementation of <code>TwoWayDict</code> that inherits from <code>UserDict</code>:</p>

<pre><code class="python">from collections import UserDict


class TwoWayDict(UserDict):
    def __delitem__(self, key):
        value = self[key]
        super().__delitem__(key)
        self.pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        super().__setitem__(key, value)
        super().__setitem__(value, key)
    def __repr__(self):
        return f"{type(self).__name__}({self.data})"
</code></pre>

<p>You may notice something interesting about the above code.</p>

<p>That code looks extremely similar to the code we originally wrote (the first version that had lots of bugs) when attempting to inherit from <code>dict</code>:</p>

<pre><code class="python">class TwoWayDict(dict):
    def __delitem__(self, key):
        value = super().pop(key)
        super().pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        super().__setitem__(key, value)
        super().__setitem__(value, key)
    def __repr__(self):
        return f"{type(self).__name__}({super().__repr__()})"
</code></pre>

<p>The <code>__setitem__</code> method is identical, but the <code>__delitem__</code> method has some small differences.</p>

<p>It might seem from these two code blocks that <code>UserDict</code> just a better <code>dict</code>.
That&rsquo;s not quite right though: <code>UserDict</code> isn&rsquo;t a <code>dict</code> replacement so much as a <code>dict</code> wrapper.</p>

<p>The <code>UserDict</code> class implements the <em>interface</em> that dictionaries are supposed to have, but it wraps around an actual <code>dict</code> object under-the-hood.</p>

<p>Here&rsquo;s another way we could have written the above <code>UserDict</code> code, without any <code>super</code> calls:</p>

<pre><code class="python">from collections import UserDict


class TwoWayDict(UserDict):
    def __delitem__(self, key):
        value = self.data.pop(key)
        self.data.pop(value, None)
    def __setitem__(self, key, value):
        if key in self:
            del self[self[key]]
        if value in self:
            del self[value]
        self.data[key] = value
        self.data[value] = key
</code></pre>

<p>Both of these methods reference <code>self.data</code>, which we didn&rsquo;t define.</p>

<p>The <code>UserDict</code> class initializer makes a dictionary which it stores in <code>self.data</code>.
All of the methods on this dictionary-like <code>UserDict</code> class wrap around this <code>self.data</code> dictionary.
<code>UserList</code> works the same way, except its <code>data</code> attribute wraps around a <code>list</code> object.
If we want to customize one of the <code>dict</code> or <code>list</code> methods of these classes, we can just override it and change what it does.</p>

<p>You can think of <code>UserDict</code> and <code>UserList</code> as <strong>wrapper classes</strong>.
When we inherit from these classes, we&rsquo;re wrapping around a <code>data</code> attribute which we proxy all our method lookups to.</p>

<p>In fancy OOP speak, we might consider <code>UserDict</code> and <code>UserList</code> to be [adapter classes][].</p>

<h3>So should I use abstract base classes or UserDict and UserList?</h3>

<p>The <code>UserList</code> and <code>UserDict</code> classes were originally created long before the abstract base classes in <code>collections.abc</code>.
<code>UserList</code> and <code>UserDict</code> have been around (in some form at least) since before Python 2.0 was even released, but the <code>collections.abc</code> abstract base classes have only been around since Python 2.6.</p>

<p>The <code>UserList</code> and <code>UserDict</code> classes are for when you want something that acts almost identically to a list or a dictionary but you want to customize just a little bit of functionality.</p>

<p>The abstract base classes in <code>collections.abc</code> are useful when you want something that&rsquo;s a <em>sequence</em> or a <em>mapping</em> but is different enough from a list or a dictionary that you really should be making your own custom class.</p>

<h2>Does inheriting from list and dict ever make sense?</h2>

<p>Inheriting from <code>list</code> and <code>dict</code> isn&rsquo;t always bad.</p>

<p>For example, here&rsquo;s a perfectly functional version of a <code>DefaultDict</code> (which acts a little differently from <code>collections.defaultdict</code>):</p>

<pre><code class="python">class DefaultDict(dict):
    def __init__(self, *args, default=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default = default
    def __missing__(self, key):
        return self.default
</code></pre>

<p>This <code>DefaultDict</code> uses the <code>__missing__</code> method to act as you&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; d = DefaultDict({'a': 8})
&gt;&gt;&gt; d['a']
8
&gt;&gt;&gt; d['b']
&gt;&gt;&gt; d
{'a': 8}
&gt;&gt;&gt; e = DefaultDict({'a': 8}, default=4)
&gt;&gt;&gt; e['a']
8
&gt;&gt;&gt; e['b']
4
&gt;&gt;&gt; e
{'a': 8}
</code></pre>

<p>There&rsquo;s no problem with inheriting from <code>dict</code> here because we&rsquo;re not overriding functionality that lives in many different places.</p>

<p>If you&rsquo;re changing functionality that&rsquo;s limited to a single method or adding your own custom method, it&rsquo;s probably worth inheriting from <code>list</code> or <code>dict</code> directly.
But if your change will require duplicating the same functionality in multiple places (as is often the case), consider reaching for one of the alternatives.</p>

<h2>When making a custom list or dictionary, remember you have options</h2>

<p>When creating your own set-like, list-like, or dictionary-like object, think carefully about how you need your object to work.</p>

<p>If you need to change some core functionality, inheriting from <code>list</code>, <code>dict</code>, or <code>set</code> will be painful and I&rsquo;d recommend against it.</p>

<p>If you&rsquo;re making a variation of <code>list</code> or <code>dict</code> and need to customize just a little bit of core functionality, consider inheriting from <code>collections.UserList</code> or <code>collections.UserDict</code>.</p>

<p>In general, if you&rsquo;re making something custom, you&rsquo;ll often want to reach for the abstract base classes in <code>collections.abc</code>.
For example if you&rsquo;re making a slightly more custom sequence or mapping (think <code>collections.deque</code>, <code>range</code>, and maybe <code>collections.Counter</code>) you&rsquo;ll want <code>MutableSequence</code> or <code>MutableMapping</code>.
And if you&rsquo;re making a custom set-like object, your only options are <code>collections.abc.Set</code> or <code>collections.abc.MutableSet</code> (there is no <code>UserSet</code>).</p>

<p>We don&rsquo;t need to create our own data structures very often in Python.
When you do need to create your own custom collections, wrapping around a data structure is a great idea.
Remember the <code>collections</code> and <code>collections.abc</code> modules when you need them!</p>

<h2>You don&rsquo;t learn by putting information into your head</h2>

<p>You don&rsquo;t learn by putting information into your head, you learn by trying to retrieve information <em>from</em> your head.
This knowledge about inheriting from <code>list</code> and <code>dict</code> and the <code>collections.abc</code> classes and <code>collections.UserList</code> and <code>collections.UserDict</code> isn&rsquo;t going to stick unless you try to apply it!</p>

<p>If you use the below form to sign up for Python Morsels, the first exercise you see when you sign up will involve creating your own custom mapping or sequence (it&rsquo;ll be a surprise which one).
After that first exercise, I&rsquo;ll send you one exercise every week for the next month.
By default they&rsquo;ll be <strong>intermediate-level</strong> exercises, though you can change your skill level after you sign up.</p>

<p><form method="post" action="https://www.pythonmorsels.com/accounts/signup/">
    <input type="email" name="email" placeholder="Your email" class="subscribe-email form-big" required>
    <input type="hidden" name="exercise_track" value="custom collection">
    <input type="hidden" name="form_id" value="inheriting from builtins">
    <button type="submit" class="subscribe-btn form-big">Get my Python Morsels exercise</button>
    <br>
    <small>
    You can <a href="https://www.pythonmorsels.com/privacy/">find the Privacy Policy for Python Morsels here</a>.
    </small>
</form></p>

<p>If you&rsquo;d rather get more beginner-friendly exercises, use the Python Morsels sign up form on the right side of this page instead.</p>

<p>[python morsels]: <a href="https://www.pythonmorsels.com/">https://www.pythonmorsels.com/</a>
[collections.abc]: <a href="https://docs.python.org/3/library/collections.abc.html">https://docs.python.org/3/library/collections.abc.html</a>
[UserDict]: <a href="https://docs.python.org/3/library/collections.html#collections.UserDict">https://docs.python.org/3/library/collections.html#collections.UserDict</a>
[UserList]: <a href="https://docs.python.org/3/library/collections.html#collections.UserList">https://docs.python.org/3/library/collections.html#collections.UserList</a>
[solid]: <a href="https://en.wikipedia.org/wiki/SOLID_">https://en.wikipedia.org/wiki/SOLID_</a>(object-oriented_design)
[oop]: <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">https://en.wikipedia.org/wiki/Object-oriented_programming</a>
[collections]: <a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>
[sentinel values]: <a href="https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/">https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/</a>
[adapter classes]: <a href="https://en.wikipedia.org/wiki/Adapter_pattern">https://en.wikipedia.org/wiki/Adapter_pattern</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Making the most of the PyCon sprints]]></title>
    <link href="https://treyhunner.com/2019/04/making-the-most-of-the-pycon-sprints/"/>
    <updated>2019-04-02T09:45:00-07:00</updated>
    <id>https://treyhunner.com/2019/04/making-the-most-of-the-pycon-sprints</id>
    <content type="html"><![CDATA[<p>I wrote a blog post last year, <a href="https://treyhunner.com/2018/04/how-to-make-the-most-of-your-first-pycon/">How to have a great first PyCon</a>, in which I gave quite a few tips for <strong>making the most of your time at PyCon</strong> (if you&rsquo;re a first time PyCon attendee, <a href="https://treyhunner.com/2018/04/how-to-make-the-most-of-your-first-pycon/">go read it</a>).
One thing I didn&rsquo;t mention <em>at all</em> in that article on PyCon was <a href="https://us.pycon.org/2019/community/sprints/">the sprints</a>.</p>

<p>I didn&rsquo;t mention the sprints not because I don&rsquo;t like them (I actually love the sprints and I usually attend at least the first two days of sprints every year), but because <strong>first-time PyCon attendees often don&rsquo;t stay for the sprints</strong>.
This is partly because the sprints can be very intimidating for first-time PyCon attendees.
The fear that <strong>the sprints aren&rsquo;t for me</strong> is a very real one.</p>

<p>This year PyCon has multiple options to help you have a successful sprint, including their annual &ldquo;Introduction to Sprinting Workshop&rdquo; on Sunday and, brand-new this year, the <a href="https://us.pycon.org/2019/hatchery/mentoredsprints/">mentored sprints</a> a hatchery track for underrepresented beginners.
The applications for the mentored sprints have closed for PyCon 2019, but that&rsquo;s something to keep an eye on for future PyCons.</p>

<p>In this post I&rsquo;m going to share some advice for <strong>how to get the most out of the PyCon sprints</strong> and I hope to <strong>address the fears that folks often feel</strong>. I&rsquo;m hoping this post might encourage you to add an extra day or two to your PyCon trip and give the sprints a try.</p>

<p>The sprints are a very different experience from the talk days at PyCon and <strong>they&rsquo;re hard to compare to the rest of PyCon</strong>.
Some people like the talks better, but I&rsquo;ve also talked to first time sprinters who said <strong>the sprints were their favorite part of the conference</strong>.</p>

<p>In this post I&rsquo;m going to share some advice for <strong>how to get the most out of the PyCon sprints</strong>.
I&rsquo;m hoping this post might encourage you to add an extra day or two to your PyCon trip and give the sprints a try.</p>

<ol data-toc=".entry-content"></ol>


<h2>Your fears going into the sprints</h2>

<p>We&rsquo;re going to start by addressing some common concerns.
I&rsquo;ve heard these concerns from folks I&rsquo;ve encouraged to stay for the sprints and from folks I&rsquo;ve interviewed about their advice for first-time sprinters.</p>

<h3>I&rsquo;m not experienced enough</h3>

<p>I&rsquo;ve <strong>never contributed to an open source project before</strong> and I don&rsquo;t really know what to do.
I&rsquo;m a <strong>junior programmer</strong> and I&rsquo;m afraid I&rsquo;m not experienced enough.
I <strong>don&rsquo;t write code for a living</strong> and I&rsquo;m afraid I won&rsquo;t be able to get anything done because I don&rsquo;t know how to <em>do</em> much yet.</p>

<p>The sprints are a great place for a first-time open source contributor.
Making a contribution to an open source project <strong>while sitting next to the maintainer</strong> is a unique experience.
If you contribute to open source at home or at work, you&rsquo;re unlikely to have a project maintainer nearby.</p>

<p>If you&rsquo;re a junior programmer or you don&rsquo;t code for a living <strong>you might be afraid of your inexperience</strong>: maybe you&rsquo;re pretty new to coding in general and you don&rsquo;t understand git, testing, version control, and GitHub.
But there&rsquo;s very likely a project for <em>you</em> to contribute to.
The sprints include sprint coordinators who can help <strong>point you to projects they&rsquo;ve heard are particularly beginner-friendly</strong> or who have quite a bit of <strong>low-hanging fruit in their issue tracker for newcomers to dig into</strong> (something as simple as updating the on-boarding documentation can be a great benefit to maintainers).</p>

<h3>It&rsquo;ll be too fast-paced for me</h3>

<p>You might think the sprints involve smart people coding for many hours on end, racing against the clock.
This is false.
From my experience, sprints usually aren&rsquo;t like that at all.</p>

<p>There are some very smart people at the sprints, but there are a lot of newcomers too.
Everyone at the sprints is new to <em>something</em> and most of us are <a href="https://youtu.be/hIJdFxYlEKE?t=333">mediocre programmers</a> (who are more skilled in some areas and less skilled in others).</p>

<p>The &ldquo;pace&rdquo; of the sprints is really up to you.
The name &ldquo;sprints&rdquo; is kind of a misnomer: <strong>I never find myself <em>sprinting</em> while at the sprints</strong>.</p>

<p>I&rsquo;ve attended at least one day of sprints at PyCon US for each of the last 5 years and my sprint experience has almost always consisted of:</p>

<ul>
<li>Some <strong>high level conversation</strong> about an intriguing feature, topic, or idea</li>
<li>Some <strong>low level conversation</strong> about how pieces of a project work (conversations about the inner-workings of a project are so much easier to have in-person)</li>
<li>Some <strong>writing time</strong>.  Sometimes this is writing code.  Sometimes this is writing text copy for documentation or marketing material.  Sometimes it&rsquo;s my own writing time for a talk or article I&rsquo;m working on.</li>
<li>Some <strong>rubber duck time</strong>.  I often wander around asking people what they&rsquo;re working on and sometimes act as their <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber duck</a>.  I also often wander around seeking my own rubber duck if I get stuck on a particular topic or idea (whether on my own personal project or an open source project I&rsquo;m contributing to).</li>
<li>Plenty of <strong>personal break time</strong>.  I very often take mental breaks during the sprints to wander the halls, often aimlessly.  Breaks feel great, but they also often help my subconscious work on a task for a bit while my conscious mind rests.</li>
</ul>


<p>Sprints are what you make them: some people prefer many hours of furious coding with their earbuds in most of the day but many people prefer something that looks a bit more like <strong>coworking with new friends in a coffee shop</strong>. Sprints are an intense experience for some people, but they don&rsquo;t have to be intense for you.</p>

<p>My sprints are often more relaxed than the conference and many of the best conversations I have during PyCon come out of the sprints.</p>

<h3>I won&rsquo;t be able to get enough done while I&rsquo;m there</h3>

<p>If you&rsquo;re only planning to be at the sprints for one day, <strong>can you really expect to get up to speed quickly enough to accomplish something meaningful</strong>?</p>

<p>This fear is very real for all sprint attendees.</p>

<p>If you&rsquo;re just getting started on contributing to a new (to you) code base, <strong>you may not be able to submit a viable change (often in the form of a pull request) by the end of the day</strong>.</p>

<p>This fear is about framing: <strong>what is your goal at the sprints</strong>?</p>

<p>If your goal is to get a pull request merged into an open source project by the end of the day, try to find something minor that needs fixing in the documentation, website styling, or something else that the project maintainer agrees needs fixing.
It&rsquo;s much easier to <strong>get a minor change merged</strong> if you get an early start and pick a small issue.</p>

<p>But if your goal is to make a more substantial improvement to a project, then you probably won&rsquo;t get much code merged (if any) by the end of the day.
For bigger changes, you&rsquo;ll likely <strong>start your work at the sprints and continue it at home</strong>, often with help from the project maintainers (via comments on pull request and/or emails).</p>

<h2>What to expect from the sprints</h2>

<p>What can you really expect while attending the sprints?
What is sprinting really like?</p>

<h3>Some projects are easier to sprint on than others</h3>

<p>Different projects sprint in different ways.
Many projects <strong>go out of their way to welcome contributions from newcomers</strong>, some projects may struggle a little in welcoming newcomers, and a few projects might hold a sprint that&rsquo;s focused entirely on engaging existing contributors since they might not meet to work in-person often (but you&rsquo;re unlikely to stumble upon those).</p>

<p>If you&rsquo;re not sure what project you&rsquo;d like to sprint on during first day at the sprints, <strong>I recommend picking a project to sprint on that seems particularly newcomer friendly</strong>.
The <a href="https://us.pycon.org/2019/community/sprints/">Pycon Sprints page</a> has several projects that will be sprinting and after the conference ends on Sunday evening you&rsquo;ll get a chance to hear many of the sprinting projects come on stage and tell you who they are and how you can help.
Alternatively (or additionally), if you&rsquo;ve identified a project that particularly suits your interests, <strong>talk to the maintainers</strong> and see if they think (and you think) their project would be a good fit for you.</p>

<p>Keep in mind that <strong>newer projects and smaller projects often have more to be done</strong>.
It can be quite challenging to find issues that need fixing in big and stable projects like CPython and Django, but newer or smaller projects often need more help.</p>

<p>It&rsquo;s also usually more fun to be <strong>a big fish in a small pond</strong> rather than a small fish in a big pond.
It might take you the same amount of effort to make a small improvement to a big project as it takes to make a big change to a small project.</p>

<h3>The maintainers are there to help you</h3>

<p>During the sprints, project maintainers are there to help you.
Project maintainers can quietly write code at home, but it&rsquo;s hard for them to encourage <em>you</em> to quietly write code at home.
So <strong>many project maintainers consider it their primary responsibility to help you contribute to their project during the sprints</strong>.</p>

<p>The maintainers of projects are usually focused on <strong>enabling your contributions during the sprints</strong> because they want your help.
If you contribute to a project during the sprints, it&rsquo;s more likely you&rsquo;ll decide to contribute to the project again <em>after</em> the sprints.
That would be great for the maintainers (they&rsquo;re getting your help) and might be quite fun for you too.</p>

<p>You might be thinking &ldquo;surely, the maintainers can&rsquo;t be there entirely to help me&rdquo;.
And you&rsquo;re right: a number of maintainers do contribute code to their own projects during the sprints.
Generally the amount of code maintainers commit to their projects increases as the sprints stretch on.
There are far fewer people on the third and fourth days of sprints than on the first and second days.
If a maintainer stays for all four days of the sprints, they&rsquo;re much more likely to commit code to their own project as the number of sprinters working on their project dwindles and as those still working start to need a bit less help than they did on the first day.
<strong>During the first couple days of the sprints, most maintainers are there primarily to help you</strong>.</p>

<h3>The sprints can be more relaxing than the talks</h3>

<p>The talk days of PyCon can be pretty overwhelming.
<strong>The sprints are a bit more structured</strong> (in a sort of odd semi-structured way) because everyone at the sprints is working on something together (or at least they&rsquo;re working on something <em>and</em> they&rsquo;re together).</p>

<p>The sprints are <strong>sort of like an introvert party</strong>: everyone is sitting at tables next to each other, sometimes talking and sometimes working quietly, but always sitting next to other humans without the need to constantly talk and interact.
And even if you&rsquo;re <em>not</em> working on the same thing as someone else, <strong>you&rsquo;re still a PyCon person in a room with other PyCon people, doing whatever it is you&rsquo;re all doing</strong>.</p>

<p>For some people the sprints really are a sprint, but for most of us <strong>the sprints are more like an endurance run</strong>, one with <em>plenty</em> of breaks.</p>

<h3>Contributing at the sprints is often easier than online</h3>

<p><strong>Contributing to open source projects at the sprints is usually easier than contributing online</strong>.
The ease of in-person communication often makes the experience less intimidating.</p>

<p>It&rsquo;s easier to express oneself and empathize during face-to-face communication than over text-based communication.
Emoji are great, but they&rsquo;re not a substitute for body language and tone of voice.</p>

<p>It feels less awkward to chat with a project maintainer about your goals and your skill level in-person than via a GitHub pull request.</p>

<p>Little bits of seemingly meaningless conversation happen while folks sit next to each other for hours: conversation about weather, hobbies, what we thought of our lunch, pop culture, and whatever else comes up.
That kind of natural conversation brings people closer together and makes us feel more comfortable communicating later, whether in-person or online.</p>

<p>Continued communication online is also often easier <em>after</em> face-to-face communication.
After you&rsquo;ve met a project maintainer in-person, you&rsquo;ll likely find communicating online via their issue tracker less intimidating because <strong>you and the maintainer already know each other</strong>.</p>

<p>The in-person nature of the sprints makes them a uniquely favorable place for your first open source contribution.</p>

<h2>How to get the most out of the sprints</h2>

<p>The sprints are a unique experience that <em>might</em> give you a greater sense of community, purpose, and belonging than the (often not quite as communal) talk days of the conference.</p>

<p>What steps can you take to increase the likelihood that you&rsquo;ll have a wonderful time at the PyCon sprints?</p>

<h3>Don&rsquo;t underestimate your skills</h3>

<p>If you&rsquo;re trying to get a feel for what project might be a good fit for you, let the maintainers know what skills you do and don&rsquo;t have and <strong>see if you get a good vibe</strong> from both the maintainers and the project.
If you do, run with it!</p>

<p>If you&rsquo;re afraid you won&rsquo;t have something to contribute, remember that, like businesses, <strong>open source projects have a wide variety of needs</strong>.</p>

<p>If you know something about marketing, you can offer to sit with project maintainers and <strong>help them improve their marketing materials</strong>.
At PyCon 2016 I interviewed some project maintainers and then crafted slogans and wrote marketing copy that explained what problem their project solved and who needed it.
I feel those were some of the most valuable contributions I made in a pretty short amount of time.</p>

<p>If you&rsquo;re pretty good at design, you could offer to <strong>create visuals for projects</strong> (maybe logos, diagrams, or other visualizations).</p>

<p>If you know CSS or JavaScript, you could find <strong>a web-based project that needs help with their front-end</strong>.
Being the &ldquo;front-end dev among Pythonistas&rdquo; or the &ldquo;UX person among developers&rdquo; can really help you make uniquely helpful contributions to projects.</p>

<p>Also keep in mind that there are often small projects that you can make big contributions to at the sprints simply because they&rsquo;re in great need.
Sometimes people even start a project <em>at the sprints</em> because it&rsquo;s easier to get help from others when <strong>you&rsquo;re in a room full of folks who might know a few things about the technology you&rsquo;re using</strong>.
If you join a newer or smaller project at the sprints (or start your own), you&rsquo;ll often be able to find a whole bunch of low-hanging fruit that hasn&rsquo;t been taken care of only because no one has had the time to work on it yet.</p>

<h3>Attend the intro to the sprints the night before</h3>

<p>Some maintainers list their projects on the <a href="https://us.pycon.org/2019/community/sprints/">PyCon sprints page</a> to note that they&rsquo;ll be attending the sprints.
Some maintainers simply announce their project during <strong>the sprint pitches after</strong> the main conference closing, on the last day of talks (Sunday).
If you are looking for a project, stick around after the last talk of the day and dozens of maintainers will walk up on the big stage to give an elevator pitch for the project they&rsquo;re sprinting on, with each pitch taking about a minute.</p>

<p>During the sprint pitches, each maintainer will talk about what their project is, what kind of help they&rsquo;re most in need of (fitting as much as they can in the very few seconds they have) and generally close with some commentary on whether their project is a good fit for newcomers.
You don&rsquo;t have to attend the sprint pitches, but doing so will increase your chances of hearing about <strong>a project that you&rsquo;d actually really like to work on</strong>.</p>

<p>Another thing to pay attention to on the last day of talks is the hands-on <strong>Introduction to Sprinting tutorial</strong> on Sunday evening.
The Intro to Sprinting tutorial is open to walk-ins (first-come, first-served) and is purposely held after the main conference closing so you won&rsquo;t need to miss any talks.</p>

<p>Last year the Intro to Sprinting tutorial room filled up pretty quickly, so rest assured you won&rsquo;t be alone.
Definitely try to get the Intro to Sprinting workshop on your calendar (once the room and time are announced) and show up on-time if you can.</p>

<h3>Try to prepare yourself for the setup time</h3>

<p>Getting started on a new project can take a lot of time, so try to prepare yourself and your development environment as much as you can early on.</p>

<p>Make sure you have git, GitHub, a code editor, and a modern version (maybe multiple versions) of Python installed on your machine.</p>

<p><strong>Get an early start if possible</strong>.
The setup process can take a long time for some projects. Many projects will have a documentation page set up with instructions on what to install and how to install it. But be aware&hellip; sometimes the setup process is a little buggy and <strong>the first pull request you make to a project may be related to improving the setup instructions</strong>.</p>

<p>If you show up to sprints early, you might be able to pick a project and get that project setup on your machine before break time.
If you&rsquo;re feeling extra ambitious, <strong>you could even get a head start and prepare your machine the night before the sprints</strong>.
I&rsquo;ve never done this because I&rsquo;m rarely feeling ambitious, but I know some folks do this to make sure they can get in a little more quality sprinting time on the first day.</p>

<p>Another way to prepare yourself for setup time is to stay longer.
If you&rsquo;re staying for 2 or 3 days of sprints, you can take it easy and spend more time on setup and getting your footing during the first day.
That way you&rsquo;ll feel <strong>more confident and more independent on the second day</strong>.
If you stay more than one day, you might also get the opportunity to <strong>sprint on two different projects</strong> if you decide you&rsquo;d like to switch projects on day 2 (or even mid-day if you&rsquo;d like).</p>

<p>Oh and another way to prepare yourself: remember your laptop and your laptop charger (and if you&rsquo;re from outside the US, a power adapter if needed).</p>

<h3>Ask for help</h3>

<p>If the maintainer of the project your sprinting on is in the room they&rsquo;re likely there because <strong>they want to help you contribute to their project</strong>.
On day 1 of sprints, project maintainers tend to prioritize helping you, over writing their own code.
<strong>Please don&rsquo;t forget to ask for help when you need it</strong>.</p>

<p>Also if you&rsquo;re stuck on laptop setup issues, the PyCon sprint coordinators will be hosting <strong>a help desk during the first day of sprints</strong> (on Monday).
The help desk is a great place to get yourself unstuck when you have a general issue that could use another set of eyes.</p>

<p>If you&rsquo;re at the sprints to learn, you do want to struggle <em>some</em>.
Struggling is a great way to learn, but don&rsquo;t let yourself flounder for too long on issues that aren&rsquo;t your area of expertise.
If you get stuck, attempt to fix your problem by trial-and-error and Googling, talk to your neighbor or your <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber duck</a> and <strong>after you&rsquo;ve given yourself some time to troubleshoot, ask for help</strong>!</p>

<h3>Plan to follow-through when home (if you&rsquo;d like)</h3>

<p>Keep in mind that you may not complete your work at the sprints.
You&rsquo;re likely to find yourself <strong>still in the middle of a pull request back-and-forth at the end of your sprints</strong>.
Pull requests often require more work before merging.
Expect to get started at the sprints, but not necessarily to finish while you&rsquo;re there.</p>

<p>If you plan to complete your pull request at home, <strong>ask the project maintainer what form of remote communication would be best for questions you have regarding contributions</strong>.</p>

<h3>Empathize with others</h3>

<p>Your project maintainer may not show up early on day 1 and they might even leave early, depending on what their plans and schedule look like.
If they&rsquo;re at the Sunday night pitches or if you interact with them during PyCon, you might consider asking them when they plan to be present and how they plan to operate (will they be writing code or helping others write code or both).</p>

<p>When sprinting, try to empathize with your project maintainer.
Empathy is challenging during remote open source contributions, but it can be a struggle even for in-person contributions.</p>

<p>Consider what your project maintainer&rsquo;s motivations likely are and remember that they&rsquo;re often trying to balance <strong>getting many new contributors to their project</strong>, <strong>getting bugs fixed</strong>, and <strong>maintaining the quality and consistency of their code base</strong>.
Balancing multiple goals which sometimes compete with each other can be a challenge.</p>

<p>Text-based communication is hard, so <strong>seize your face-to-face communication while you&rsquo;re at the sprints</strong> and try to get a sense for how your project maintainer thinks.
If you do decide to contribute more after the sprints are over, <strong>that in-person empathy can help you continue to empathize remotely as well</strong>.</p>

<p>Some other places you may want to use empathy: empathizing with users of your code/documentation/design (someone is going to use your work) and the other sprinters in the room with you.
It&rsquo;s nice to congratulate your fellow sprinters when they get their code working or if they get a pull request accepted.</p>

<p>If you bring snacks, candy, donuts, or a small power strip to expand one power strip port into multiple, <strong>your kindness might give you happy neighbors at the sprints</strong>.</p>

<h3>Be kind to yourself</h3>

<p>Don&rsquo;t go into the sprints with a very specific thing that you absolutely must do: have a goal but <strong>allow yourself to change your goal</strong> as you learn new information about your environment.
<strong>Be flexible and be forgiving with yourself</strong>.</p>

<p>You&rsquo;re allowed to <strong>switch projects</strong> at any time, as often as you like, and for any reason you like (i.e. the project isn&rsquo;t as interesting as you hoped, the onboarding process isn&rsquo;t as smooth as you expected, or the project isn&rsquo;t a good fit for you).
If you need to switch projects, don&rsquo;t feel you need to offer elaborate explanations.</p>

<p>You&rsquo;re allowed to <strong>stop sprinting</strong> at any time and <strong>take a break</strong>.
You aren&rsquo;t obligated to follow through on a pull request you opened (it&rsquo;d be lovely if you did, but you don&rsquo;t <em>have</em> to).</p>

<p>Time-wise, there&rsquo;s lots of flexibility at the sprints.
The maintainer of the project you&rsquo;re sprinting on might get an early start or they might not show up until later on the first day of sprints.
You need to give yourself flexibility as well.</p>

<p>Don&rsquo;t feel obligated at the sprints: you don&rsquo;t have to make a code change, <strong>you don&rsquo;t have to be productive</strong>, you don&rsquo;t have to show up at a certain time or stay for a certain amount of time, and <strong>you don&rsquo;t even have to sprint on an open source project</strong> (I frequently don&rsquo;t).</p>

<p>If you&rsquo;d like to take half of a sprint day to explore the city you&rsquo;re in with a new friend (or on your own because you need personal time), go for it!</p>

<p>Embrace self-care at the sprints, whatever that means for you.</p>

<h3>Remember that sprints are lots of things to lots of people</h3>

<p>During my first PyCon sprint in 2014, I helped a project figure out how to migrate from Python 2 to Python 3.
The project maintainer wasn&rsquo;t looking forward to that migration so they were grateful to have another brain troubleshooting with them.</p>

<p>But during that sprint I also got an idea for a contribution to another project (Django), was encouraged to pursue the idea, and <a href="https://github.com/django/deps/pull/4">a few weeks after the sprints</a> I proposed the idea publicly.
After my suggestion sat without feedback, I sort of abandoned it.</p>

<p>But at the PyCon 2015 sprints the next year, I brought up my abandoned idea to a Django core developer and they offered to shepherd my change through, so I <a href="https://github.com/django/deps/pull/13">continued my efforts</a> during the sprints.
A couple weeks after the sprints ended I <a href="https://github.com/django/deps/pull/14">finished up the idea at home</a> and finally <a href="https://github.com/django/django/pull/4573">implemented the changes</a>, which were eventually merged (after <a href="https://github.com/django/deps/pull/15/files">some scope tweaks</a>).</p>

<p>My first two years of PyCon sprints involved some substantial code contributions that I hadn&rsquo;t expected to make.
Most of the changes I made were <strong>started at the sprints but finished at home</strong>.</p>

<p>The sprints were a source of idea generation and inspiration, not a place to get lots of work done.
Since 2015 I&rsquo;ve started sprinting on <em>ideas</em> more than code.</p>

<p>During my PyCon 2016 sprints I helped a few open source projects improve their marketing copy (so someone hitting their website would better understand what their project did and who it was for).
My pull requests during these sprints were text-based changes, not code changes.</p>

<p>My PyCon 2017 sprints involved a lot of community work: discussions with folks about the PSF and the new Code of Conduct working group.
I spent much more time in Google Docs tweaking documents than I did using git.</p>

<p>My sprints at PyCon 2018 involved writing talk proposals, meeting with new friends, and chatting with core developers about the soon-to-be-written <a href="https://www.python.org/dev/peps/pep-0582/">PEP 582</a>.
I don&rsquo;t think I made any contributions to open source projects (outside of possibly inspiring a bullet point or two in that PEP).
But I had a great time and sitting quietly in the sprint rooms helped me get a lot of work done on my talk proposals.</p>

<p><strong>The sprints aren&rsquo;t one thing</strong>.
If you&rsquo;re not feeling like a code contribution is the thing you&rsquo;d like to do during the sprints, get creative!
<strong>Your time at the sprints can be spent however you&rsquo;d like it to be</strong>.</p>

<h2>Running your own sprint</h2>

<p>This could be a whole article on its own, but I want to give a few quick tips for folks who might be attempting to run a sprint for their own project.</p>

<p>While I&rsquo;ve maintained open source projects remotely, I haven&rsquo;t run an in-person sprint on my own projects.
So my tips on running a sprint on your own project come from the perspective of a contributor and a floating helper for maintainers who needed an extra hand.</p>

<p>As a project maintainer on day 1 of sprints, <strong>I&rsquo;d consider your primary responsibility to be one of helping encourage other contributors</strong>.
You want to help folks get their environment setup, help folks identify good issues to work on, help folks with their code contributions, and even help other contributors as they help out their neighbors.</p>

<p><strong>Your job often isn&rsquo;t to write code</strong>, it&rsquo;s to be <em>interrupted</em> by people who are trying to make contributions but need your help.</p>

<p>For the in-person, in-the-moment part of running a sprint I have <a href="http://trey.io/pycascades2019">a whole talk and a bunch of related resources</a> for folks who are coaching others in-person.
But your job doesn&rsquo;t start <em>at the sprints</em>.
Ideally, you&rsquo;ll want to <strong>prepare your project for the sprints</strong> a while before the sprints even start.</p>

<p>Many projects use issue labels to indicate <strong>issues which are specifically good for first-time contributors</strong> (something like &ldquo;newcomer&rdquo;, &ldquo;good first issue&rdquo;, &ldquo;first-timers only&rdquo;, etc.).
I&rsquo;d recommend looking at <a href="https://github.com/MunGell/awesome-for-beginners#python">the many other contributor-friendly projects</a>, studying what they do, and figuring out <strong>how you can make your project more friendly to new sprinters</strong>.</p>

<p>The PyCon sprints page also recommends this <a href="https://opensourceevents.github.io/">in-person events handbook</a> made by the OpenHatch folks.
Take a look at it!
And if you can, <strong>ask questions of other project maintainers you admire who will also be sprinting</strong>: how do they ensure newcomers feel appreciated, how do they help folks feel accomplished, what do they do to get their project and their minds ready?</p>

<h2>Take note of the key events</h2>

<p>Put the events you&rsquo;ll be attending for the PyCon 2019 sprints in your calendar!</p>

<p>The sprint pitches are on the last talk day at PyCon, just after the closing of the main conference.
The Intro to Sprints tutorial usually starts just after that.
And during the first day of sprints the next day, the sprint help desk will be available to help you get some extra help on day 1.</p>

<p>Also remember the mentored sprints (if you&rsquo;ve gone through the application process already) which are designed for underrepresented groups and are on Saturday during the talks.</p>

<h2>Ask others what they think of the sprints</h2>

<p>Much of the above advice was borrowed or enhanced by wisdom from others.
I&rsquo;ve held interviews with folks during the last few PyCon sprints, I&rsquo;ve asked folks online what they think of the sprints, and I&rsquo;ve chatted with first-time sprinters about what their concerns were going into the sprints.
If you shared your sprint experiences with me in the past, thank you.</p>

<p>If you&rsquo;re still uncertain about whether you should attend a sprint, please talk to others about what they think of the PyCon sprints.
I&rsquo;ve found that most PyCon attendees are more than happy to talk about their perspective on the various parts of the conference they&rsquo;ve partaken in.</p>

<p>If you can&rsquo;t afford to stay for the sprints, I completely understand.
Most PyCon attendees will not be staying for the sprints.
But if you&rsquo;re lucky enough to have the time and resources to stay, I&rsquo;d suggest giving it a try.</p>

<p>If you can afford to schedule some extra time to attend a day or two of sprints and then decide that the sprints aren&rsquo;t for you, that time could always be spent exploring the city you&rsquo;re in, working, or doing something else that makes you feel whole.</p>

<p>And if you&rsquo;re from an underrepresented or marginalized group in tech and you&rsquo;re new to sprinting, consider applying for the <a href="https://us.pycon.org/2019/hatchery/mentoredsprints/">mentored sprints</a> for PyCon 2020.</p>

<p>Whatever you decide, have a lovely PyCon! 💖</p>

<p>Thanks to Asheesh Laroia for encouraging this post and Chalmer Lowe for quite a bit of helpful feedback while I was writing it.
Thanks also to the many folks who sent me ideas and shared their perspective and advice about the sprints.</p>
]]></content>
  </entry>
  
</feed>
