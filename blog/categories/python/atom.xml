<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="https://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="https://treyhunner.com/"/>
  <updated>2020-11-25T19:59:49-08:00</updated>
  <id>https://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Short weekly Python screencasts for $50/year]]></title>
    <link href="https://treyhunner.com/2020/11/short-python-screencasts-for-$50-slash-year/"/>
    <updated>2020-11-25T09:00:00-08:00</updated>
    <id>https://treyhunner.com/2020/11/short-python-screencasts-for-$50-slash-year</id>
    <content type="html"><![CDATA[<p>I&rsquo;m offering a service to help <strong>life-long Python learners</strong> manufacture ah-ha moments.</p>

<p>A few years ago at my local Python meetup I was discussing how function arguments work (they&rsquo;re <a href="https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/">call-by-assignment</a> a.k.a. <a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing">call by object</a>).
A friend spoke up to clarify: &ldquo;but it doesn&rsquo;t work that way for numbers and strings, right?&rdquo;
I said &ldquo;I&rsquo;m pretty sure it works like this for everything&rdquo;.</p>

<p>After some quiet Googling, my friend declared &ldquo;I&rsquo;ve been using Python for over a decade and I never knew it worked this way&rdquo;.
They&rsquo;d suddenly realized <em>their mental model of the Python world</em> differed from Python&rsquo;s model of itself.
They&rsquo;d experienced an &ldquo;ah-ha moment&rdquo;.</p>

<p>I&rsquo;m going to publish <strong>at least one short Python screencast every week</strong> to help <em>manufacture</em> <strong>Python ah-ha moments</strong>.
These will be single-topic screencasts that <strong>won&rsquo;t waste your time</strong>.</p>

<p>So, if you&rsquo;re a life-long learner who uses Python and doesn&rsquo;t have a wealth of time for learning, read on.</p>

<h3>What is this?</h3>

<p>With this subscription you&rsquo;ll receive access to a growing archive of Python screencasts (<strong>at least one new screencast each week</strong>).
If you enjoy my <a href="https://treyhunner.com/blog/categories/python/">articles</a> or my <a href="https://treyhunner.com/talks">talks and tutorials</a>, you&rsquo;ll probably enjoy the format I use in my screencasts.</p>

<p><strong>Don&rsquo;t like video?</strong> That&rsquo;s okay!
Each screencast is captioned and includes <strong>a mini-blog post</strong> which is nearly <strong>a text-based equivalent</strong> to the video.</p>

<h3>What are the screencasts like?</h3>

<p>Each screencast will be <strong>concise</strong> and short, under 6 minutes.
Examples include <a href="https://www.pythonmorsels.com/topics/variables-are-pointers/">variables are pointers</a> (2 mins) and <a href="https://www.pythonmorsels.com/topics/2-types-change/">the 2 types of &ldquo;change&rdquo;</a> (3 mins), plus <a href="https://www.pythonmorsels.com/screencasts/">others here</a>.</p>

<p><a href="https://www.pythonmorsels.com/screencasts/"><img src="/images/screencasts.png"></a></p>

<p><strong>What topics will the screencasts be on?</strong>
Functions, classes, scope, operator overloading, decorators, exception handling, and more.
Screencasts will focus on Python core, not third-party libraries (no Pandas, Numpy, or Django).
Topics will range from beginner to advanced.</p>

<p><strong>Will the screencasts be freely shareable?</strong>
Some screencasts will be limited to subscribers and some will be available to non-subscribers, with a yet-to-be-decided breakdown between the two.</p>

<h3>You&rsquo;ll also get get occasional Python exercises</h3>

<p>This weekly screencast subscription is part of <a href="https://www.pythonmorsels.com/">Python Morsels</a>, an exercise subscription service I run.
In addition to weekly screencasts, you&rsquo;ll also get <strong>one Python exercise each month</strong>.</p>

<p>If you&rsquo;ve taken <a href="https://treyhunner.com/talks/#tutorials">my PyCon tutorials</a> or attended <a href="https://truthful.technology/">my trainings</a>, you know exercises are the best part of my curriculum.
I spend a lot of time making new exercises because we learn by attempting to retrieve information from our heads (through practice), not by putting information <em>into</em> our heads.</p>

<p>Python Morsels exercises are both interesting and <strong>complex but not complicated</strong>.
You don&rsquo;t need to work through the monthly exercises, but I do recommend it.</p>

<h3>This subscription is $50/year for a limited time</h3>

<p>I&rsquo;m offering this service for a comparatively low price of $50/year because I don&rsquo;t have a large archive of screencasts yet.
I have plans to increase the price in 2021, but as an early user <strong>your price will always be $50/year</strong>.</p>

<p>If you&rsquo;re not sure whether this is for you, <a href="https://www.pythonmorsels.com/accounts/signup/?plan=9">sign up to try it out for free</a>.</p>

<h3>Why pay for this when there&rsquo;s a lot of great free Python videos out there?</h3>

<p>Why am I charging money for this?</p>

<p>There&rsquo;s really one reason: <strong>you&rsquo;re trading money for time</strong>.
This is a tradeoff I&rsquo;ve grown an appreciation for (one which would baffle a younger version of myself).</p>

<p>This time-money tradeoff comes in a few forms:</p>

<ol>
<li>You will never see any ads on Python Morsels: you&rsquo;re not the product, the screencasts are</li>
<li>No filler content or rambling (no ad revenue means no need for long videos)</li>
<li>I have unique expertise and perspective: teaching Python is my business and I&rsquo;m good at it</li>
</ol>


<p>Watch some of <a href="https://www.pythonmorsels.com/screencasts/">the current screencasts</a> before signing up.
If my teaching style isn&rsquo;t for you, that&rsquo;s okay!
But if my teaching style <em>is</em> for you, I think you&rsquo;ll find <strong>the next year&rsquo;s worth of screencasts</strong> will be worthwhile! üòÅ</p>

<h3>Student discounts? Team subscriptions? Other questions?</h3>

<p>My standard <a href="https://www.pythonmorsels.com/discounts/">discount policy</a> is income-tiered: if you make less than $60,000 USD annually, you&rsquo;re eligible.
I also offer situation-specific discounts, so please <strong>ask for a discount if you need one</strong>.</p>

<p>If you&rsquo;re paying through your employer, note that there are <strong>team subscriptions</strong> too.
Just <a href="https://form.jotform.com/201278113533043">fill out this form</a> to get started setting up a subscription for your team.</p>

<h3>Ready to try it out?</h3>

<p>Are you ready to subscribe to a growing collection of short and concise Python screencasts?
<a href="https://www.pythonmorsels.com/accounts/signup/?plan=9">Let&rsquo;s get learning</a>!</p>

<p><a href="https://www.pythonmorsels.com/accounts/signup/?plan=9" class="subscribe-btn form-big bright">Sign up for weekly Python screencasts now</a></p>

<p>Do you have another question that I haven&rsquo;t answered here?
Check out the <a href="https://pythonmorsels.helpscoutdocs.com/article/23-lite-plan">Lite plan FAQ</a> or <a href="m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m">email your question to he&#108;p&#64;pyt&#104;o&#110;morsel&#115;&#46;&#99;o&#109;</a>.</p>

<p>Happy learning!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Passing a function as an argument to another function in Python]]></title>
    <link href="https://treyhunner.com/2020/01/passing-functions-as-arguments/"/>
    <updated>2020-01-14T08:00:00-08:00</updated>
    <id>https://treyhunner.com/2020/01/passing-functions-as-arguments</id>
    <content type="html"><![CDATA[<p>One of the more hair-raising facts we learn in my introductory Python trainings is that <strong>you can pass functions into other functions</strong>.
You can pass functions around because in Python, <strong>functions are objects</strong>.</p>

<p>You likely don&rsquo;t need to know about this in your first week of using Python, but as you dive deeper into Python you&rsquo;ll find that it can be quite convenient to understand how to pass a function into another function.</p>

<p>This is part 1 of what I expect to be a series on the various properties of &ldquo;function objects&rdquo;.
This article focuses on what a new Python programmer should know and appreciate about <strong>the object-nature of Python&rsquo;s functions</strong>.</p>

<ul data-toc=".entry-content"></ul>


<h2>Functions can be referenced</h2>

<p>If you try to use a function without putting parentheses after it Python won&rsquo;t complain but it also won&rsquo;t do anything useful:</p>

<pre><code class="pycon">&gt;&gt;&gt; def greet():
...     print("Hello world!")
...
&gt;&gt;&gt; greet
&lt;function greet at 0x7ff246c6d9d0&gt;
</code></pre>

<p>This applies to methods as well (<a href="https://docs.python.org/3/glossary.html#term-method">methods</a> are functions which live on objects):</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; numbers.pop
&lt;built-in method pop of list object at 0x7ff246c76a80&gt;
</code></pre>

<p>Python is allowing us to <em>refer</em> to these <em>function objects</em>, the same way we might refer to a string, a number, or a <code>range</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; "hello"
'hello'
&gt;&gt;&gt; 2.5
2.5
&gt;&gt;&gt; range(10)
range(0, 10)
</code></pre>

<p>Since we can refer to functions like any other object, we can point a variable to a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; gimme = numbers.pop
</code></pre>

<p>That <code>gimme</code> variable now points to the <code>pop</code> method on our <code>numbers</code> list.
So if we call <code>gimme</code>, it&rsquo;ll do the same thing that calling <code>numbers.pop</code> would have done:</p>

<pre><code class="pycon">&gt;&gt;&gt; gimme()
29
&gt;&gt;&gt; numbers
[2, 1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; gimme(0)
2
&gt;&gt;&gt; numbers
[1, 3, 4, 7, 11, 18]
&gt;&gt;&gt; gimme()
18
</code></pre>

<p>Note that we <strong>didn&rsquo;t make a new function</strong>.
We&rsquo;ve just pointed the <code>gimme</code> variable name to the <code>numbers.pop</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; gimme
&lt;built-in method pop of list object at 0x7ff246c76bc0&gt;
&gt;&gt;&gt; numbers.pop
&lt;built-in method pop of list object at 0x7ff246c76bc0&gt;
</code></pre>

<p>You can even store functions inside data structures and then reference them later:</p>

<pre><code class="pycon">&gt;&gt;&gt; def square(n): return n**2
...
&gt;&gt;&gt; def cube(n): return n**3
...
&gt;&gt;&gt; operations = [square, cube]
&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; for i, n in enumerate(numbers):
...     action = operations[i % 2]
...     print(f"{action.__name__}({n}):", action(n))
...
square(2): 4
cube(1): 1
square(3): 9
cube(4): 64
square(7): 49
cube(11): 1331
square(18): 324
cube(29): 24389
</code></pre>

<p>It&rsquo;s not very common to take a function and give it another name or to store it inside a data structure, but Python allows us to do these things because <strong>functions can be passed around, just like any other object</strong>.</p>

<h2>Functions can be passed into other functions</h2>

<p>Functions, like any other object, can be passed as an argument to another function.</p>

<p>For example we could define a function:</p>

<pre><code class="pycon">&gt;&gt;&gt; def greet(name="world"):
...     """Greet a person (or the whole world by default)."""
...     print(f"Hello {name}!")
...
&gt;&gt;&gt; greet("Trey")
Hello Trey!
</code></pre>

<p>And then pass it into the built-in <code>help</code> function to see what it does:</p>

<pre><code class="pycon">&gt;&gt;&gt; help(greet)
Help on function greet in module __main__:

greet(name='world')
    Greet a person (or the whole world by default).
</code></pre>

<p>And we can pass the function into itself (yes this is weird), which converts it to a string here:</p>

<pre><code class="pycon">&gt;&gt;&gt; greet(greet)
Hello &lt;function greet at 0x7f93416be8b0&gt;!
</code></pre>

<p>There are actually quite a few functions built-in to Python that are specifically meant to accept other functions as arguments.</p>

<p>The built-in <code>filter</code> function accepts two things as an argument: a <code>function</code> and an <code>iterable</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; help(filter)

 |  filter(function or None, iterable) --&gt; filter object
 |
 |  Return an iterator yielding those items of iterable for which function(item)
 |  is true. If function is None, return the items that are true.
</code></pre>

<p>The given iterable (list, tuple, string, etc.) is looped over and the given function is called on each item in that iterable: whenever the function returns <code>True</code> (or another truthy value) the item is included in the <code>filter</code> output.</p>

<p>So if we pass <code>filter</code> an <code>is_odd</code> function (which returns <code>True</code> when given an odd number) and a list of numbers, we&rsquo;ll get back all of the numbers we gave it which are odd.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; def is_odd(n): return n % 2 == 1
...
&gt;&gt;&gt; filter(is_odd, numbers)
&lt;filter object at 0x7ff246c8dc40&gt;
&gt;&gt;&gt; list(filter(is_odd, numbers))
[1, 3, 7, 11, 29]
</code></pre>

<p>The object returned from <code>filter</code> is <a href="https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/">a lazy iterator</a> so we needed to convert it to a <code>list</code> to actually see its output.</p>

<p>Since functions can be passed into functions, that also means that functions can accept another function as an argument.
The <code>filter</code> function assumes its first argument is a function.
You can think of the <code>filter</code> function as pretty much the same as this function:</p>

<pre><code class="python">def filter(predicate, iterable):
    return (
        item
        for item in iterable
        if predicate(item)
    )
</code></pre>

<p>This function expects the <code>predicate</code> argument to be a function (technically it could be any <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/">callable</a>).
When we call that function (with <code>predicate(item)</code>), we pass a single argument to it and then check the truthiness of its return value.</p>

<h2>Lambda functions are an example of this</h2>

<p>A lambda expression is a special syntax in Python for creating an <a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous function</a>.
When you evaluate a <strong>lambda expression</strong> the object you get back is called a <strong>lambda function</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; is_odd = lambda n: n % 2 == 1
&gt;&gt;&gt; is_odd(3)
True
&gt;&gt;&gt; is_odd(4)
False
</code></pre>

<p>Lambda functions are pretty much just like regular Python functions, with a few caveats.</p>

<p>Unlike other functions, lambda functions don&rsquo;t have a name (their name shows up as <code>&lt;lambda&gt;</code>).
They also can&rsquo;t have docstrings and they can only contain a single Python expression.</p>

<pre><code class="pycon">&gt;&gt;&gt; add = lambda x, y: x + y
&gt;&gt;&gt; add(2, 3)
5
&gt;&gt;&gt; add
&lt;function &lt;lambda&gt; at 0x7ff244852f70&gt;
&gt;&gt;&gt; add.__doc__
</code></pre>

<p>You can think of a lambda expression as a shortcut for making a function which will evaluate a single Python expression and return the result of that expression.</p>

<p>So defining a lambda expression doesn&rsquo;t actually evaluate that expression: it returns a function that can evaluate that expression later.</p>

<pre><code class="pycon">&gt;&gt;&gt; greet = lambda name="world": print(f"Hello {name}")
&gt;&gt;&gt; greet("Trey")
Hello Trey
&gt;&gt;&gt; greet()
Hello world
</code></pre>

<p>I&rsquo;d like to note that all three of the above examples of <code>lambda</code> are poor examples.
If you want a variable name to point to a function object that you can use later, you should use <code>def</code> to define a function: that&rsquo;s the <em>usual</em> way to define a function.</p>

<pre><code class="pycon">&gt;&gt;&gt; def is_odd(n): return n % 2 == 1
...
&gt;&gt;&gt; def add(x, y): return x + y
...
&gt;&gt;&gt; def greet(name="world"): print(f"Hello {name}")
...
</code></pre>

<p>Lambda expressions are for when we&rsquo;d like to define a function and <strong>pass it into another function immediately</strong>.</p>

<p>For example here we&rsquo;re using <code>filter</code> to get even numbers, but we&rsquo;re using a lambda expression so we don&rsquo;t have to define an <code>is_even</code> function before we use it:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers
[2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; list(filter(lambda n: n % 2 == 0, numbers))
[2, 4, 18]
</code></pre>

<p>This is <em>the most appropriate</em> use of lambda expressions: passing a function into another function while defining that passed function all on one line of code.</p>

<p>As I&rsquo;ve written about in <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/">Overusing lambda expressions</a>, I&rsquo;m not a fan of Python&rsquo;s lambda expression syntax.
Whether or not you like this syntax, you should know that this syntax is just a shortcut for creating a function.</p>

<p>Whenever you see <code>lambda</code> expressions, keep in mind that:</p>

<ol>
<li>A lambda expression is a special syntax for creating a function and passing it to another function all on one line of code</li>
<li>Lambda functions are just like all other function objects: neither is more special than the other and both can be passed around</li>
</ol>


<p>All functions in Python can be passed as an argument to another function (that just happens to be the <em>sole</em> purpose of lambda functions).</p>

<h2>A common example: key functions</h2>

<p>Besides the built-in <code>filter</code> function, where will you ever see a function passed into another function?
Probably the most common place you&rsquo;ll see this in Python itself is with a <strong>key function</strong>.</p>

<p>It&rsquo;s a common convention for functions which accept an iterable-to-be-sorted/ordered to also accept a <a href="https://treyhunner.com/2018/04/keyword-arguments-in-python/">named argument</a> called <code>key</code>.
This <code>key</code> argument should be a function <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/">or another callable</a>.</p>

<p>The <a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/#sorted">sorted</a>, <a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/#min_and_max">min</a>, and <a href="https://treyhunner.com/2019/05/python-builtins-worth-learning/#min_and_max">max</a> functions all follow this convention of accepting a <code>key</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; def normalize_case(s): return s.casefold()
...
&gt;&gt;&gt; sorted(fruits, key=normalize_case)
['Cherimoya', 'jujube', 'kumquat', 'longan', 'Loquat']
&gt;&gt;&gt; min(fruits, key=normalize_case)
'Cherimoya'
&gt;&gt;&gt; max(fruits, key=normalize_case)
'Loquat'
</code></pre>

<p>That <a href="https://docs.python.org/3/glossary.html#term-key-function">key function</a> is called for each value in the given iterable and the return value is used to order/sort each of the iterable items.
You can think of this key function as computing <strong>a comparison key</strong> for each item in the iterable.</p>

<p>In the above example our comparison key returns a lowercased string, so each string is compared by its lowercased version (which results in a case-insensitive ordering).</p>

<p>We used a <code>normalize_case</code> function to do this, but the same thing could be done using <code>str.casefold</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; sorted(fruits, key=str.casefold)
['Cherimoya', 'jujube', 'kumquat', 'longan', 'Loquat']
</code></pre>

<p><strong>Note</strong>: That <code>str.casefold</code> trick is a bit odd if you aren&rsquo;t familiar with how classes work.
Classes store the <em>unbound methods</em> that will accept an instance of that class when called.
We normally type <code>my_string.casefold()</code> but <code>str.casefold(my_string)</code> is what Python translates that to.
That&rsquo;s a story for another time.</p>

<p>Here we&rsquo;re finding the string with the most letters in it:</p>

<pre><code class="pycon">&gt;&gt;&gt; max(fruits, key=len)
'Cherimoya'
</code></pre>

<p>If there are multiple maximums or minimums, the earliest one <em>wins</em> (that&rsquo;s how <code>min</code>/<code>max</code> work):</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; min(fruits, key=len)
'Loquat'
&gt;&gt;&gt; sorted(fruits, key=len)
['Loquat', 'longan', 'jujube', 'kumquat', 'Cherimoya']
</code></pre>

<p>Here&rsquo;s a function which will return a 2-item tuple containing the length of a given string and the case-normalized version of that string:</p>

<pre><code class="python">def length_and_alphabetical(string):
    """Return sort key: length first, then case-normalized string."""
    return (len(string), string.casefold())
</code></pre>

<p>We could pass this <code>length_and_alphabetical</code> function as the <code>key</code> argument to <code>sorted</code> to sort our strings by their length first and then by their case-normalized representation:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; fruits_by_length = sorted(fruits, key=length_and_alphabetical)
&gt;&gt;&gt; fruits_by_length
['jujube', 'longan', 'Loquat', 'kumquat', 'Cherimoya']
</code></pre>

<p>This relies on the fact that <a href="https://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/">Python&rsquo;s ordering operators do deep comparisons</a>.</p>

<h2>Other examples of passing a function as an argument</h2>

<p>The <code>key</code> argument accepted by <code>sorted</code>, <code>min</code>, and <code>max</code> is just one common example of passing functions into functions.</p>

<p>Two more function-accepting Python built-ins are <code>map</code> and <code>filter</code>.</p>

<p>We&rsquo;ve already seen that <code>filter</code> will <em>filter</em> our list based on a given function&rsquo;s return value.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers
[2, 1, 3, 4, 7, 11, 18, 29]
&gt;&gt;&gt; def is_odd(n): return n % 2 == 1
...
&gt;&gt;&gt; list(filter(is_odd, numbers))
[1, 3, 7, 11, 29]
</code></pre>

<p>The <code>map</code> function will call the given function on each item in the given iterable and use the result of that function call as the new item:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(map(is_odd, numbers))
[False, True, True, False, True, True, False, True]
</code></pre>

<p>For example here we&rsquo;re converting numbers to strings and squaring numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(map(str, numbers))
['2', '1', '3', '4', '7', '11', '18', '29']
&gt;&gt;&gt; list(map(lambda n: n**2, numbers))
[4, 1, 9, 16, 49, 121, 324, 841]
</code></pre>

<p><strong>Note</strong>: as I noted in my article on overusing lambda, I personally prefer to <a href="https://treyhunner.com/2018/09/stop-writing-lambda-expressions/#Overuse:_lambda_with_map_and_filter">use generator expressions instead of the <code>map</code> and <code>filter</code> functions</a>.</p>

<p>Similar to <code>map</code>, and <code>filter</code>, there&rsquo;s also <a href="https://docs.python.org/3/library/itertools.html#itertools.takewhile">takewhile</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile">dropwhile</a> from the <code>itertools</code> module.
The first one is like <code>filter</code> except it stops once it finds a value for which the <em>predicate function</em> is false.
The second one does the opposite: it only includes values after the predicate function has become false.</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import takewhile, dropwhile
&gt;&gt;&gt; colors = ['red', 'green', 'orange', 'purple', 'pink', 'blue']
&gt;&gt;&gt; def short_length(word): return len(word) &lt; 6
...
&gt;&gt;&gt; list(takewhile(short_length, colors))
['red', 'green']
&gt;&gt;&gt; list(dropwhile(short_length, colors))
['orange', 'purple', 'pink', 'blue']
</code></pre>

<p>And there&rsquo;s <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a> and <a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate">itertools.accumulate</a>, which both call a 2-argument function to accumulate values as they loop:</p>

<pre><code class="pycon">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; from itertools import accumulate
&gt;&gt;&gt; numbers = [2, 1, 3, 4, 7]
&gt;&gt;&gt; def product(x, y): return x * y
...
&gt;&gt;&gt; reduce(product, numbers)
168
&gt;&gt;&gt; list(accumulate(numbers, product))
[2, 2, 6, 24, 168]
</code></pre>

<p>The <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict">defaultdict</a> class in the <code>collections</code> module is another example.
The <code>defaultdict</code> class creates dictionary-like objects which will never raise a <code>KeyError</code> when a missing key is accessed, but will instead add a new value to the dictionary automatically.</p>

<pre><code class="pycon">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; counts = defaultdict(int)
&gt;&gt;&gt; counts['jujubes']
0
&gt;&gt;&gt; counts
defaultdict(&lt;class 'int'&gt;, {'jujubes': 0})
</code></pre>

<p>This <code>defaultdict</code> class accepts a <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/">callable</a> (function or class) that will be called to create a default value whenever a missing key is accessed.</p>

<p>The above code worked because <code>int</code> returns <code>0</code> when called with no arguments:</p>

<pre><code class="pycon">&gt;&gt;&gt; int()
0
</code></pre>

<p>Here the default value is <code>list</code>, which returns a new list when called with no arguments.</p>

<pre><code class="pycon">&gt;&gt;&gt; things_by_color = defaultdict(list)
&gt;&gt;&gt; things_by_color['purple'].append('socks')
&gt;&gt;&gt; things_by_color['purple'].append('shoes')
&gt;&gt;&gt; things_by_color
defaultdict(&lt;class 'list'&gt;, {'purple': ['socks', 'shoes']})
</code></pre>

<p>The <a href="https://docs.python.org/3/library/functools.html#functools.partial">partial</a> function in the <code>functools</code> module is another example.
<code>partial</code> accepts a function and any number of arguments and returns a new function (technically it returns a <a href="https://treyhunner.com/2019/04/is-it-a-class-or-a-function-its-a-callable/#Callable_objects">callable object</a>).</p>

<p>Here&rsquo;s an example of <code>partial</code> used to &ldquo;bind&rdquo; the <code>sep</code> keyword argument to the <code>print</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; print_each = partial(print, sep='\n')
</code></pre>

<p>The <code>print_each</code> function returned now does the same thing as if <code>print</code> was called with <code>sep='\n'</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; print(1, 2, 3)
1 2 3
&gt;&gt;&gt; print(1, 2, 3, sep='\n')
1
2
3
&gt;&gt;&gt; print_each(1, 2, 3)
1
2
3
</code></pre>

<p>You&rsquo;ll also find functions-that-accept-functions in third-party libraries, like <a href="https://docs.djangoproject.com/en/3.0/ref/models/fields/#default">in Django</a>, and <a href="https://numpy.org/doc/1.17/reference/generated/numpy.fromfunction.html">in numpy</a>.
Anytime you see a class or a function with documentation stating that one of its arguments should be a <strong>callable</strong> or a <strong>callable object</strong>, that means &ldquo;you could pass in a function here&rdquo;.</p>

<h2>A topic I&rsquo;m skipping over: nested functions</h2>

<p>Python also supports nested functions (functions defined inside of other functions).
Nested functions power Python&rsquo;s <a href="https://docs.python.org/3/glossary.html#term-decorator">decorator</a> syntax.</p>

<p>I&rsquo;m not going to discuss nested functions in this article because nested functions warrant exploration of <a href="https://en.wikipedia.org/wiki/Non-local_variable">non-local variables</a>, <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a>, and other weird corners of Python that you don&rsquo;t need to know when you&rsquo;re first getting started with treating functions as objects.</p>

<p>I plan to write a follow-up article on this topic and link to it here later.
In the meantime, if you&rsquo;re interested in nested functions in Python, a search for <a href="https://duckduckgo.com/?q=higher-order+functions+in+Python">higher order functions in Python</a> may be helpful.</p>

<h2>Treating functions as objects is normal</h2>

<p>Python has <a href="https://en.wikipedia.org/wiki/First-class_function">first-class functions</a>, which means:</p>

<ol>
<li>You can assign functions to variables</li>
<li>You can store functions in lists, dictionaries, or other data structures</li>
<li>You can pass functions into other functions</li>
<li>You can write functions that return functions</li>
</ol>


<p>It might seem odd to treat functions as objects, but it&rsquo;s not that unusual in Python.
By my count, about 15% of the Python built-ins are meant to accept functions as arguments (<code>min</code>, <code>max</code>, <code>sorted</code>, <code>map</code>, <code>filter</code>, <code>iter</code>, <code>property</code>, <code>classmethod</code>, <code>staticmethod</code>, <code>callable</code>).</p>

<p>The most important uses of Python&rsquo;s first-class functions are:</p>

<ol>
<li>Passing a <code>key</code> function to the built-in <code>sorted</code>, <code>min</code>, and <code>max</code> functions</li>
<li>Passing functions into looping helpers like <code>filter</code> and <code>itertools.dropwhile</code></li>
<li>Passing a &ldquo;default-value generating factory function&rdquo; to classes like <code>defaultdict</code></li>
<li>&ldquo;Partially-evaluating&rdquo; functions by passing them into <code>functools.partial</code></li>
</ol>


<p>This topics goes <em>much deeper</em> than what I&rsquo;ve discussed here, but until you find yourself writing decorator functions, you probably don&rsquo;t need to explore this topic any further.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cyber Monday Python Sales]]></title>
    <link href="https://treyhunner.com/2019/12/cyber-monday-python-sales/"/>
    <updated>2019-12-02T02:00:00-08:00</updated>
    <id>https://treyhunner.com/2019/12/cyber-monday-python-sales</id>
    <content type="html"><![CDATA[<p>I&rsquo;m running <a href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/">a sale</a> that ends in 24 hours, but I&rsquo;m not the only one.
This post is a compilation of the different Cyber Monday deals I&rsquo;ve found related to Python and Python learning.</p>

<h3>Python Morsels, weekly skill-building for professional Pythonistas</h3>

<p><a href="https://www.pythonmorsels.com/">Python Morsels</a> is my weekly Python skill-building service.</p>

<p>I&rsquo;m offering something sort of like a &ldquo;buy one get one free&rdquo; sale this year.</p>

<p>You can pay $200 to get 2 redemption codes, each worth 12 months of Python Morsels.</p>

<p>You can use one code for yourself and give one to a friend.
Or you could be extra generous and give them both away to two friends.
Either way, 2 people are each getting one year&rsquo;s worth of weekly Python training.</p>

<p>You can find <a href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/">more details on this sale here</a>.</p>

<h3>Data School&rsquo;s Machine Learning course</h3>

<p>Kevin Markham of Data School is selling his &ldquo;Machine Learning with Text in Python&rdquo; course for $195 (it&rsquo;s usually $295).
You can find more details on this sale <a href="https://www.dataschool.io/black-friday/">on the Data School Black Friday post</a>.</p>

<h3>Talk Python Course Bundle</h3>

<p>Michael Kennedy is selling a bundle that includes <a href="https://training.talkpython.fm/black-friday-2019">every Talk Python course for $250</a>.</p>

<p>There are 20 courses included in this bundle.
If you&rsquo;re into Python and you don&rsquo;t already own most of these courses, this bundle could be a really good deal for you.</p>

<h3>Reuven Lerner&rsquo;s Python courses</h3>

<p>Reuven Lerner is offering a <a href="https://lerner.co.il/2019/11/28/my-black-friday-sale-is-live-take-50-off-any-course-in-python-or-data-science/">50% off sale on his courses</a>.
Reuven has courses on Python, Git, and regular expressions.</p>

<p>This sale also includes Reuven&rsquo;s <a href="https://store.lerner.co.il/wpe?coupon=BF2019">Weekly Python Exercise</a>, which is similar to <a href="https://www.pythonmorsels.com/">Python Morsels</a>, but has its own flavor.
You could sign up for both if you want double the weekly learning.</p>

<h3>Real Python courses</h3>

<p>Real Python is also offering <a href="https://realpython.com/account/join/?c=blackfriday2019">$40 off their annual memberships</a>.
Real Python has many tutorials and courses as well.</p>

<h3>PyBites Code Challenges</h3>

<p>Bob and Julian of PyBites are offering their a <a href="https://gumroad.com/l/Xhxeo/teachingpython">40% discount off their Newbie Bites</a> on their PyBites Code Challenges platform.</p>

<p>If you&rsquo;re new to Python and programming, check out their newbie bites.</p>

<h3>Automate the Boring Stuff Course (for free!)</h3>

<p>Al Sweigart is offering <a href="https://www.udemy.com/course/automate/?couponCode=DEC2019FREE">free lifetime access to his Automate the Boring Stuff with Python course</a> on Udemy until Wednesday.
It&rsquo;s hard to beat free!</p>

<h3>Other Cyber Monday deals?</h3>

<p>If you have questions about the <a href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/">Python Morsels sale</a>, <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a>.</p>

<p>The Python Morsels sale and likely all the other sales above will end in the next 24 hours, probably sooner depending on when you&rsquo;re reading this.</p>

<p>So go check them out!</p>

<p>Did I miss a deal that you know about?
Link to it in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Black Friday Sale: Gift Python Morsels to a Friend]]></title>
    <link href="https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend/"/>
    <updated>2019-11-29T15:00:00-08:00</updated>
    <id>https://treyhunner.com/2019/11/black-friday-sale-gift-python-morsels-to-a-friend</id>
    <content type="html"><![CDATA[<p>From today until the end of Monday December 2nd, I&rsquo;m <a href="http://trey.io/sale2019">selling bundles</a> of two 52-week Python Morsels redemption codes.</p>

<p>You can buy 12 months of Python Morsels for yourself and <strong>gift 12 months of Python Morsels to a friend for free</strong>!</p>

<p>Or, if you&rsquo;re extra generous, you can buy two redemption codes (for the price of one) and gift them both to <em>two friends</em>.</p>

<h3>What is Python Morsels?üêçüç™</h3>

<p><a href="https://pythonmorsels.com">Python Morsels</a> is a weekly Python skill-building service for professional Python developers.
Subscribers receive one Python exercise every week in the Python skill level of their choosing (novice, intermediate, advanced).</p>

<p>Each exercise is designed to help you <strong>think the way Python thinks</strong>, so you can write your code less like a C/Java/Perl developer would and more like a fluent Pythonista would.
  Each programming language has its own unique ways of looking at the world: Python Morsels will help you embrace Python&rsquo;s.</p>

<p>One year&rsquo;s worth of Python Morsels will help even experienced Python developers <strong>deepen their Python skills</strong> and <strong>find new insights about Python</strong> to incorporate into their day-to-day work.</p>

<h3>How does this work? ü§î</h3>

<p>Normally a 12 month Python Morsels subscription costs $200.
For $200, I&rsquo;m instead selling two redemption codes, each of which can be used for 12 months (52 weeks) of Python Morsels exercises.</p>

<p>With this sale, you&rsquo;ll get two 12-month redemption codes for the price of one.
So you&rsquo;ll get 1 year of Python Morsels for 2 friends for just $200.</p>

<p>These codes can be used at any time and users of these codes will always maintain access to the 52 exercises received over the 12 month period. You can use one of these codes to extend your current subscription, but new users can also use this redemption code without signing up for an ongoing subscription.</p>

<p>Only one of these codes can be used per account (though you can purchase as many as you&rsquo;d like to gift to others).</p>

<h3>What will I (and my friends) get with Python Morsels? üéÅ</h3>

<p>With Python Morsels you&rsquo;ll get:</p>

<ul>
<li><strong>An email every Monday</strong> which includes a detailed problem to solve using Python</li>
<li>Multiple bonuses for almost every problem (most have 3 bonuses, almost all have 2) so you can <strong>re-adjust your difficulty level on a weekly basis</strong></li>
<li>Hints for each problem which you can use when you get stuck</li>
<li>An online progress tracking tool to keep track of which exercises you&rsquo;ve solved and how many bonuses you solved for each exercise</li>
<li><strong>Automated tests</strong> (to ensure correctness) which you can run locally and which also run automatically when you submit your solutions</li>
<li>An email every Wednesday with a <strong>detailed walkthrough of various solutions (usually 5-10)</strong> for each problem, including walkthroughs of each bonus and a discussion of why some solutions may be better than others</li>
<li>A skill level selection tool (novice, intermediate, advanced) which you can adjust based on your Python experience</li>
<li>A web interface you can come back to even after your 12 months are over</li>
</ul>


<h3>Okay, I&rsquo;m interested. Now what? ‚ú®</h3>

<p>First of all, don&rsquo;t wait. This buy-one-get-one-free sale ends Monday!</p>

<p>You can sign up and purchase 2 redemption codes by visiting <a href="http://trey.io/sale2019">http://trey.io/sale2019</a></p>

<p>Note that you need to create a Python Morsels account to purchase the redemption codes.
You don&rsquo;t need to have an on-going subscription, you just need an account.</p>

<p>If you have any questions about this sale, please don&rsquo;t hesitate to <a href='m&#97;&#105;l&#116;o&#58;he&#108;p&#64;&#112;%7&#57;th%6Fnmo&#114;s%6&#53;ls&#46;&#99;&#111;m'>email me</a>.</p>

<p><a href="http://trey.io/sale2019">Go get your Python Morsels redemption codes</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Loop Better: a deeper look at iteration in Python]]></title>
    <link href="https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python/"/>
    <updated>2019-06-18T09:15:00-07:00</updated>
    <id>https://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python</id>
    <content type="html"><![CDATA[<p>Python&rsquo;s <code>for</code> loops don&rsquo;t work the way <code>for</code> loops do in other languages.  In this article we&rsquo;re going to dive into Python&rsquo;s <code>for</code> loops to take a look at how they work under the hood and why they work the way they do.</p>

<ol data-toc=".entry-content" data-toc-headings="h2"></ol>


<p><strong>Note</strong>: This article is based on my <a href="https://youtu.be/JYuE8ZiDPl4">Loop Better talk</a>.
It was originally published <a href="https://opensource.com/article/18/3/loop-better-deeper-look-iteration-python">on opensource.com</a>.</p>

<h2>Looping Gotchas</h2>

<p>We&rsquo;re going to start off our journey by taking a look at some &ldquo;gotchas&rdquo;.  After we&rsquo;ve learned how looping works in Python, we&rsquo;ll take another look at these gotchas and explain what&rsquo;s going on.</p>

<h3>Gotcha 1: Looping Twice</h3>

<p>Let&rsquo;s say we have a list of numbers and a generator that will give us the squares of those numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>We can pass our generator object to the <code>tuple</code> constructor to make a tuple out of it:</p>

<pre><code class="pycon">&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre>

<p>If we then take the same generator object and pass it to the <code>sum</code> function we might expect that we&rsquo;d get the sum of these numbers, which would be 88.</p>

<pre><code class="pycon">&gt;&gt;&gt; sum(squares)
0
</code></pre>

<p>Instead we get <code>0</code>.</p>

<h3>Gotcha 2: Containment Checking</h3>

<p>Let&rsquo;s take the same list of numbers and the same generator object:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we ask whether <code>9</code> is in our <code>squares</code> generator, Python will tell us that 9 <em>is</em> in <code>squares</code>.  But if we ask the <em>same question again</em>, Python will tell us that 9 <em>is not</em> in <code>squares</code>.</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; 9 in squares
False
</code></pre>

<p>We asked the same question twice and Python gave us two different answers.</p>

<h3>Gotcha 3: Unpacking</h3>

<p>This dictionary has two key-value pairs:</p>

<pre><code class="pycon">&gt;&gt;&gt; counts = {'apples': 2, 'oranges': 1}
</code></pre>

<p>Let&rsquo;s unpack this dictionary using multiple assignment:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = counts
</code></pre>

<p>You might expect that when unpacking this dictionary, we&rsquo;ll get key-value pairs or maybe that we&rsquo;ll get an error.</p>

<p>But unpacking dictionaries doesn&rsquo;t raise errors and it doesn&rsquo;t return key-value pairs.  When you unpack dictionaries you get keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; x
'apples'
</code></pre>

<p>We&rsquo;ll come back to these gotchas after we&rsquo;ve learned a bit about the logic that powers these Python snippets.</p>

<h2>Review: Python&rsquo;s for loop</h2>

<p>Python doesn&rsquo;t have traditional <code>for</code> loops.  To explain what I mean, let&rsquo;s take a look at a <code>for</code> loop in another programming language.</p>

<p>This is a traditional C-style <code>for</code> loop written in JavaScript:</p>

<pre><code class="javascript">let numbers = [1, 2, 3, 5, 7];
for (let i = 0; i &lt; numbers.length; i += 1) {
    print(numbers[i])
}
</code></pre>

<p>JavaScript, C, C++, Java, PHP, and a whole bunch of other programming languages all have this kind of <code>for</code> loop.  <strong>But Python doesn&rsquo;t</strong>.</p>

<p>Python <strong>does not</strong> have traditional C-style <code>for</code> loops.  We do have something that we <em>call</em> a <code>for</code> loop in Python, but it works like a <a href="https://en.wikipedia.org/wiki/Foreach">foreach loop</a>.</p>

<p>This is Python&rsquo;s flavor of <code>for</code> loop:</p>

<pre><code class="python">numbers = [1, 2, 3, 5, 7]
for n in numbers:
    print(n)
</code></pre>

<p>Unlike traditional C-style <code>for</code> loops, Python&rsquo;s <code>for</code> loops don&rsquo;t have index variables.  There&rsquo;s no index initializing, bounds checking, or index incrementing.  Python&rsquo;s <code>for</code> loops do <em>all the work</em> of looping over our <code>numbers</code> list for us.</p>

<p>So while we do have <code>for</code> loops in Python, we do not have have traditional C-style <code>for</code> loops.  The thing that <em>we</em> call a <code>for</code> loop works very differently.</p>

<h2>Definitions: Iterables and Sequences</h2>

<p>Now that we&rsquo;ve addressed the index-free <code>for</code> loop in our Python room, let&rsquo;s get some definitions out of the way now.</p>

<p>An <strong>iterable</strong> is anything you can loop over with a <code>for</code> loop in Python.
Iterables can be looped over and anything that can be looped over is an iterable.</p>

<pre><code class="python">for item in some_iterable:
    print(item)
</code></pre>

<p>Sequences are a very common type of iterable.
Lists, tuples, and strings are all sequences.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = "hello there"
</code></pre>

<p>Sequences are iterables which have a specific set of features.
They can be indexed starting from <code>0</code> and ending at one less than the length of the sequence, they have a length, and they can be sliced.
Lists, tuples, strings and <em>all other</em> sequences work this way.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers[0]
1
&gt;&gt;&gt; coordinates[2]
7
&gt;&gt;&gt; words[4]
'o'
</code></pre>

<p>Lots of things in Python are iterables, but not all iterables are sequences.  Sets, dictionaries, files, and generators are all iterables but none of these things are sequences.</p>

<pre><code class="pycon">&gt;&gt;&gt; my_set = {1, 2, 3}
&gt;&gt;&gt; my_dict = {'k1': 'v1', 'k2': 'v2'}
&gt;&gt;&gt; my_file = open('some_file.txt')
&gt;&gt;&gt; squares = (n**2 for n in my_set)
</code></pre>

<p>So anything that can be looped over with a <code>for</code> loop is an iterable and sequences are one type of iterable but Python has many other kinds of iterables as well.</p>

<h2>Python&rsquo;s for loops don&rsquo;t use indexes</h2>

<p>You might think that under the hood, Python&rsquo;s <code>for</code> loops use indexes to loop.
Here we&rsquo;re manually looping over an iterable using a <code>while</code> loop and indexes:</p>

<pre><code class="python">numbers = [1, 2, 3, 5, 7]
i = 0
while i &lt; len(numbers):
    print(numbers[i])
    i += 1
</code></pre>

<p>This works for lists, but it won&rsquo;t work for everything.  This way of looping <strong>only works for sequences</strong>.</p>

<p>If we try to manually loop over a set using indexes, we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; fruits = {'lemon', 'apple', 'orange', 'watermelon'}
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; len(fruits):
...     print(fruits[i])
...     i += 1
...
Traceback (most recent call last):
File "&lt;stdin&gt;", line 2, in &lt;module&gt;
TypeError: 'set' object does not support indexing
</code></pre>

<p>Sets are not sequences so they don&rsquo;t support indexing.</p>

<p>We <em>cannot</em> manually loop over every iterable in Python by using indexes.
This simply won&rsquo;t work for iterables that aren&rsquo;t sequences.</p>

<h2>Iterators power for loops</h2>

<p>So we&rsquo;ve seen that Python&rsquo;s <code>for</code> loops must not be using indexes under the hood.
Instead, Python&rsquo;s <code>for</code> loops use <strong>iterators</strong>.</p>

<p>Iterators are the things that power iterables.
You can get an iterator from <em>any</em> iterable.
And you can use an iterator to manually loop over the iterable it came from.</p>

<p>Let&rsquo;s take a look at how that works.</p>

<p>Here are three iterables: a set, a tuple, and a string.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = {1, 2, 3, 5, 7}
&gt;&gt;&gt; coordinates = (4, 5, 7)
&gt;&gt;&gt; words = "hello there"
</code></pre>

<p>We can ask each of these iterables for an <em>iterator</em> using Python&rsquo;s built-in <code>iter</code> function.
Passing an iterable to the <code>iter</code> function will always give us back an iterator, no matter what type of iterable we&rsquo;re working with.</p>

<pre><code class="pycon">&gt;&gt;&gt; iter(numbers)
&lt;set_iterator object at 0x7f2b9271c860&gt;
&gt;&gt;&gt; iter(coordinates)
&lt;tuple_iterator object at 0x7f2b9271ce80&gt;
&gt;&gt;&gt; iter(words)
&lt;str_iterator object at 0x7f2b9271c860&gt;
</code></pre>

<p>Once we have an iterator, the one thing we can do with it is get its next item by passing it to the built-in <code>next</code> function.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; my_iterator = iter(numbers)
&gt;&gt;&gt; next(my_iterator)
1
&gt;&gt;&gt; next(my_iterator)
2
</code></pre>

<p>Iterators are stateful, meaning once you&rsquo;ve consumed an item from them it&rsquo;s gone.</p>

<p>If you ask for the <code>next</code> item from an iterator and there are no more items, you&rsquo;ll get a <code>StopIteration</code> exception:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
3
&gt;&gt;&gt; next(iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>So you can get an iterator from every iterable.
And the only thing that you can do with iterators is ask them for their next item using the <code>next</code> function.
And if you pass them to <code>next</code> but they don&rsquo;t have a next item, a <code>StopIteration</code> exception will be raised.</p>

<p><img src="/images/hello-kitty-pez.jpg" width="512" height="384" title="&ldquo;Hello Kitty PEZ dispenser&rdquo;" ></p>

<p><a href="https://www.flickr.com/photos/30223382@N06/4151828376">Hello Kitty PEZ dispenser photo</a> by Deborah Austin / <a href="https://creativecommons.org/licenses/by/2.0/">CC BY</a></p>

<p>You can think of iterators as like Hello Kitty PEZ dispensers that cannot be reloaded.
You can take PEZ out, but once a PEZ is removed it can&rsquo;t be put back and once the dispenser is empty, it&rsquo;s useless.</p>

<h2>Looping without a for loop</h2>

<p>Now that we&rsquo;ve learned about iterators and the <code>iter</code> and <code>next</code> functions, we&rsquo;re going to try manually looping over an iterable without using a <code>for</code> loop.</p>

<p>We&rsquo;ll do so by attempting to turn this <code>for</code> loop into a <code>while</code> loop:</p>

<pre><code class="python">def funky_for_loop(iterable, action_to_do):
    for item in iterable:
        action_to_do(item)
</code></pre>

<p>To do this we&rsquo;ll:</p>

<ol>
<li>Get an iterator from the given iterable</li>
<li>Repeatedly get the next item from the iterator</li>
<li>Execute the body of the <code>for</code> loop if we successfully got the next item</li>
<li>Stop our loop if we got a <code>StopIteration</code> exception while getting the next item</li>
</ol>


<pre><code class="python">def funky_for_loop(iterable, action_to_do):
    iterator = iter(iterable)
    done_looping = False
    while not done_looping:
        try:
            item = next(iterator)
        except StopIteration:
            done_looping = True
        else:
            action_to_do(item)
</code></pre>

<p>We&rsquo;ve just re-invented a <code>for</code> loop by using a <code>while</code> loop and iterators.</p>

<p>The above code pretty much defines the way looping works under the hood in Python.  If you understand the way the built-in <code>iter</code> and <code>next</code> functions work for looping over things, you understand how Python&rsquo;s <code>for</code> loops work.</p>

<p>In fact you&rsquo;ll understand a little bit more than just how <code>for</code> loops work in Python.  All forms of looping over iterables work this way.</p>

<p><strong>The iterator protocol</strong> is a fancy way of saying &ldquo;how looping over iterables works in Python&rdquo;.
It&rsquo;s essentially the definition of the way the <code>iter</code> and <code>next</code> functions work in Python.
All forms of iteration in Python are powered by the iterator protocol.</p>

<p>The iterator protocol is used by <code>for</code> loops (as we&rsquo;ve already seen):</p>

<pre><code class="python">for n in numbers:
    print(n)
</code></pre>

<p>Multiple assignment also uses the iterator protocol:</p>

<pre><code class="python">x, y, z = coordinates
</code></pre>

<p>Star expressions use the iterator protocol:</p>

<pre><code class="python">a, b, *rest = numbers
print(*numbers)
</code></pre>

<p>And many built-in functions rely on the iterator protocol:</p>

<pre><code class="python">unique_numbers = set(numbers)
</code></pre>

<p>Anything in Python that works with an <em>iterable</em> probably uses the iterator protocol in some way.
Any time you&rsquo;re looping over an iterable in Python, you&rsquo;re relying on the iterator protocol.</p>

<h2>Generators are iterators</h2>

<p>So you might be thinking: iterators seem cool, but they also just seem like an implementation detail and we might not need to <em>care</em> about them as users of Python.</p>

<p>I have news for you: it&rsquo;s very common to work directly with iterators in Python.</p>

<p>The <code>squares</code> object here is a generator:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>And generators are iterators, meaning you can call <code>next</code> on a generator to get its next item:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(squares)
1
&gt;&gt;&gt; next(squares)
4
</code></pre>

<p>But if you&rsquo;ve ever used a generator before, you probably know that you can also loop over generators:</p>

<pre><code class="pycon">&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; for n in squares:
...     print(n)
...
1
4
9
</code></pre>

<p>If you can loop over something in Python, it&rsquo;s an <strong>iterable</strong>.</p>

<p>So <strong>generators are iterators</strong>, but generators are also iterables.  What&rsquo;s going on here?</p>

<h2>I lied to you</h2>

<p>So when I explained how iterators worked earlier, I skipped over an important detail about them.</p>

<p><strong>Iterators are iterables</strong>.</p>

<p>I&rsquo;ll say that again: every iterator in Python is also an iterable, which means you can loop over iterators.</p>

<p>Because iterators are also iterables, you can get an iterator from an iterator using the built-in <code>iter</code> function:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3]
&gt;&gt;&gt; iterator1 = iter(numbers)
&gt;&gt;&gt; iterator2 = iter(iterator1)
</code></pre>

<p>Remember that iterables give us iterators when we call <code>iter</code> on them.</p>

<p>When we call <code>iter</code> on an iterator it will always give us itself back:</p>

<pre><code class="pycon">&gt;&gt;&gt; iterator1 is iterator2
True
</code></pre>

<p>Iterators are iterables and all iterators are their own iterators.</p>

<pre><code class="python">def is_iterator(iterable):
    return iter(iterable) is iterable
</code></pre>

<p>Confused yet?</p>

<p>Let&rsquo;s recap these terms.</p>

<p>An iter<strong>able</strong> is something you&rsquo;re able to iterate over.
An iter<strong>ator</strong> is the agent that actually does the iterating over an iterable.</p>

<p>Additionally, in Python iterators are also iterables and they act as <em>their own</em> iterators.</p>

<p>So iterators are iterables, but they don&rsquo;t have the variety of features that some iterables have.</p>

<p>Iterators have no length and they can&rsquo;t be indexed:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; iterator = iter(numbers)
&gt;&gt;&gt; len(iterator)
TypeError: object of type 'list_iterator' has no len()
&gt;&gt;&gt; iterator[0]
TypeError: 'list_iterator' object is not subscriptable
</code></pre>

<p>From our perspective as Python programmers, the only useful things you can do with an iterator are pass it to the built-in <code>next</code> function or loop over it:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
1
&gt;&gt;&gt; list(iterator)
[2, 3, 5, 7]
</code></pre>

<p>And if we loop over an iterator a second time, we&rsquo;ll get nothing back:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(iterator)
[]
</code></pre>

<p>You can think of iterators are <strong>lazy iterables</strong> that are <strong>single-use</strong>, meaning they can be looped over one time only.</p>

<table>
<thead>
<tr>
<th> Object    </th>
<th> Iterable?        </th>
<th> Iterator?        </th>
</tr>
</thead>
<tbody>
<tr>
<td> Iterable  </td>
<td> &#x2714;&#xfe0f; </td>
<td>         &#x2753; </td>
</tr>
<tr>
<td> Iterator  </td>
<td> &#x2714;&#xfe0f; </td>
<td> &#x2714;&#xfe0f; </td>
</tr>
<tr>
<td> Generator </td>
<td> &#x2714;&#xfe0f; </td>
<td> &#x2714;&#xfe0f; </td>
</tr>
<tr>
<td> List      </td>
<td> &#x2714;&#xfe0f; </td>
<td>         &#x274c; </td>
</tr>
</tbody>
</table>


<p>As you can see in the truth table above, iterables are not always iterators but iterators are always iterables:</p>

<h2>The iterator protocol, in full</h2>

<p>Let&rsquo;s define how iterators work from Python&rsquo;s perspective.</p>

<p>Iterables can be passed to the <code>iter</code> function to get an iterator for them.</p>

<p>Iterators:</p>

<ol>
<li>Can be passed to the <code>next</code> function which will give their next item or raise a <code>StopIteration</code> exception if there are no more items</li>
<li>Can be passed to the <code>iter</code> function and will return themselves back</li>
</ol>


<p>The inverse of these statements also hold true:</p>

<ol>
<li>Anything that can be passed to <code>iter</code> without a <code>TypeError</code> is an iterable</li>
<li>Anything that can be passed to <code>next</code> without a <code>TypeError</code> is an iterator</li>
<li>Anything that returns itself when passed to <code>iter</code> is an iterator</li>
</ol>


<p>That&rsquo;s the iterator protocol in Python.</p>

<h2>Iterators enable laziness</h2>

<p>Iterators allow us to both work with and create <strong>lazy iterables</strong> that don&rsquo;t do any work until we ask them for their next item.
Because we can create lazy iterables, we can make infinitely long iterables.
And we can create iterables that are conservative with system resources, that can save us memory and can save us CPU time.</p>

<h2>Iterators are everywhere</h2>

<p>You&rsquo;ve already seen lots of iterators in Python.
I&rsquo;ve already mentioned that generators are iterators.
Many of Python&rsquo;s built-in classes are iterators also.
For example Python&rsquo;s <code>enumerate</code> and <code>reversed</code> objects are iterators.</p>

<pre><code class="pycon">&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; e = enumerate(letters)
&gt;&gt;&gt; e
&lt;enumerate object at 0x7f112b0e6510&gt;
&gt;&gt;&gt; next(e)
(0, 'a')
</code></pre>

<p>In Python 3, <code>zip</code>, <code>map</code>, and <code>filter</code> objects are iterators too.</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; letters = ['a', 'b', 'c']
&gt;&gt;&gt; z = zip(numbers, letters)
&gt;&gt;&gt; z
&lt;zip object at 0x7f112cc6ce48&gt;
&gt;&gt;&gt; next(z)
(1, 'a')
</code></pre>

<p>And file objects in Python are iterators also.</p>

<pre><code class="pycon">&gt;&gt;&gt; next(open('hello.txt'))
'hello world\n'
</code></pre>

<p>There are lots of iterators bult-in to Python, in the standard library, and in third-party Python libraries.
These iterators all act like lazy iterables by delaying work until the moment you ask them for their next item.</p>

<h2>Creating your own iterator</h2>

<p>It&rsquo;s useful to know that you&rsquo;re already using iterators, but I&rsquo;d like you to also know that you can create your own iterators and your own lazy iterables.</p>

<p>This class makes an iterator that accepts an iterable of numbers and provides squares of each of the numbers as it&rsquo;s looped over.</p>

<pre><code class="python">class square_all:
    def __init__(self, numbers):
        self.numbers = iter(numbers)
    def __next__(self):
        return next(self.numbers) ** 2
    def __iter__(self):
        return self
</code></pre>

<p>But no work will be done until we start looping over an instance of this class.</p>

<p>Here we have an infinitely long iterable <code>count</code> and you can see that <code>square_all</code> accepts <code>count</code> without fully looping over this infinitely long iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; numbers = count(5)
&gt;&gt;&gt; squares = square_all(numbers)
&gt;&gt;&gt; next(squares)
25
&gt;&gt;&gt; next(squares)
36
</code></pre>

<p>This iterator class works, but we don&rsquo;t usually make iterators this way.
Usually when we want to make a custom iterator, we make a generator function:</p>

<pre><code class="python">def square_all(numbers):
    for n in numbers:
        yield n**2
</code></pre>

<p>This generator function is equivalent to the class we made above and it works essentially the same way.</p>

<p>That <code>yield</code> statement probablys seem magical, but it is very powerful: <code>yield</code> allows us to put our generator function on pause between calls from the <code>next</code> function.
The <code>yield</code> statement is the thing that separates generator functions from regular functions.</p>

<p>Another way we could implement this same iterator is with a generator expression.</p>

<pre><code class="python">def square_all(numbers):
    return (n**2 for n in numbers)
</code></pre>

<p>This does the same thing as our generator function but it uses a syntax that looks <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">like a list comprehension</a>.
If you need to make a lazy iterable in your code, think of iterators and consider making a generator function or a generator expression.</p>

<h2>How iterators can improve your code</h2>

<p>Once you&rsquo;ve embraced the idea of using lazy iterables in your code, you&rsquo;ll find that there are lots of possibilities for discovering or creating helper functions that assist you in looping over iterables and processing data.</p>

<h3>Laziness and summing</h3>

<p>This is a <code>for</code> loop that sums up all billable hours in a Django queryset:</p>

<pre><code class="python">hours_worked = 0
for event in events:
    if event.is_billable():
        hours_worked += event.duration
</code></pre>

<p>Here is code that does the same thing using a generator expression for lazy evaluation:</p>

<pre><code class="python">billable_times = (
    event.duration
    for event in events
    if event.is_billable()
)

hours_worked = sum(billable_times)
</code></pre>

<p>Notice that the shape of our code has changed dramatically.</p>

<p>Turning our billable times into a lazy iterable has allowed us to name something (<code>billable_times</code>) that was previously unnamed.
This has also allowed us to use the <code>sum</code> function.  We couldn&rsquo;t have used <code>sum</code> before because we didn&rsquo;t even have an iterable to pass to it.
Iterators allow you to fundamentally change the way you structure your code.</p>

<h3>Laziness and breaking out of loops</h3>

<p>This code prints out the first ten lines of a log file:</p>

<pre><code class="python">for i, line in enumerate(log_file):
    if i &gt;= 10:
        break
    print(line)
</code></pre>

<p>This code does the same thing, but we&rsquo;re using the <code>itertools.islice</code> function to lazily grab the first 10 lines of our file as we loop:</p>

<pre><code class="python">from itertools import islice

first_ten_lines = islice(log_file, 10)
for line in first_ten_lines:
    print(line)
</code></pre>

<p>The <code>first_ten_lines</code> variable we&rsquo;ve made is an iterator.
Again using an iterator allowed us to give a name to something (first ten lines) that was previously unnamed.
Naming things can make our code more descriptive and more readable.</p>

<p>As a bonus we also removed the need for a <code>break</code> statement in our loop because the <code>islice</code> utility handles the breaking for us.</p>

<p>You can find many more iteration helper functions in <a href="https://docs.python.org/3/library/itertools.html">itertools</a> in the standard library as well as in third-party libraries such as <a href="https://boltons.readthedocs.io">boltons</a> and <a href="https://more-itertools.readthedocs.io">more-itertools</a>.</p>

<h3>Creating your own iteration helpers</h3>

<p>You can find helper functions for looping in the standard library and in third-party libraries, but you can also make your own!</p>

<p>This code makes a list of the differences between consecutive values in a sequence.</p>

<pre><code class="python">current = readings[0]
for next_item in readings[1:]:
    differences.append(next_item - current)
    current = next_item
</code></pre>

<p>Notice that this code has an extra variable that we need to assign each time we loop.
Also note that this code only works with things we can slice, like sequences.  If <code>readings</code> were a generator, a zip object, or any other type of iterator this code would fail.</p>

<p>Let&rsquo;s write a helper function to fix our code.</p>

<p>This is a generator function that gives us the current item and the item following it for every item in a given iterable:</p>

<pre><code class="python">def with_next(iterable):
    """Yield (current, next_item) tuples for each item in iterable."""
    iterator = iter(iterable)
    current = next(iterator)
    for next_item in iterator:
        yield current, next_item
        current = next_item
</code></pre>

<p>We&rsquo;re manually getting an iterator from our iterable, calling <code>next</code> on it to grab the first item, and then looping over our iterator to get all subsequent items, keeping track of our last item along the way.
This function works not just with sequences, but with any type of iterable</p>

<p>This is the same code but we&rsquo;re using our helper function instead of manually keeping track of <code>next_item</code>:</p>

<pre><code class="python">differences = []
for current, next_item in with_next(readings):
    differences.append(next_item - current)
</code></pre>

<p>Notice that this code doesn&rsquo;t have awkward assignments to <code>next_item</code> hanging around our loop.
The <code>with_next</code> generator function handles the work of keeping track of <code>next_item</code> for us.</p>

<p>Also note that this code has been compacted enough that we could even <a href="http://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/">copy-paste our way into a list comprehension</a> if we wanted to.</p>

<pre><code class="python">differences = [
    (next_item - current)
    for current, next_item in with_next(readings)
]
</code></pre>

<h2>Looping Gotchas: Revisited</h2>

<p>At this point we&rsquo;re ready to jump back to those odd examples we saw earlier and try to figure out what was going on.</p>

<h3>Gotcha 1: Exhausting an Iterator</h3>

<p>Here we have a generator object, <code>squares</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we pass this generator to the <code>tuple</code> constructor, we&rsquo;ll get a tuple of its items back:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; tuple(squares)
(1, 4, 9, 25, 49)
</code></pre>

<p>If we then try to compute the <code>sum</code> of the numbers in this generator, we&rsquo;ll get <code>0</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; sum(squares)
0
</code></pre>

<p>This generator is now empty: we&rsquo;ve exhausted it.
If we try to make a tuple out of it again, we&rsquo;ll get an empty tuple:</p>

<pre><code class="pycon">&gt;&gt;&gt; tuple(squares)
()
</code></pre>

<p>Generators are iterators.
And iterators are single-use iterables.
They&rsquo;re like Hello Kitty PEZ dispensers that cannot be reloaded.</p>

<h3>Gotcha 2: Partially-Consuming an Iterator</h3>

<p>Again we have a generator object, <code>squares</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>If we ask whether <code>9</code> is in this <code>squares</code> generator, we&rsquo;ll get <code>True</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
True
</code></pre>

<p>But if we ask the same question again, we&rsquo;ll get <code>False</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; 9 in squares
False
</code></pre>

<p>When we ask whether <code>9</code> is in this generator, Python has to loop over this generator to find <code>9</code>.
If we kept looping over it after checking for <code>9</code>, we&rsquo;ll only get the last two numbers because we&rsquo;ve already consumed the numbers before this point:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 5, 7]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; 9 in squares
True
&gt;&gt;&gt; list(squares)
[25, 49]
</code></pre>

<p>Asking whether something is <em>contained</em> in an iterator will partially consume the iterator.
There is no way to know whether something is in an iterator without starting to loop over it.</p>

<h3>Gotcha 3: Unpacking is iteration</h3>

<p>When you <em>loop</em> over dictionaries you get keys:</p>

<pre><code class="pycon">&gt;&gt;&gt; counts = {'apples': 2, 'oranges': 1}
&gt;&gt;&gt; for key in counts:
...     print(key)
...
apples
oranges
</code></pre>

<p>You also get keys when you unpack a dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = counts
&gt;&gt;&gt; x, y
('apples', 'oranges')
</code></pre>

<p>Looping relies on the iterator protocol.
Iterable unpacking also relies on the iterator protocol.
Unpacking a dictionary is really the same as looping over the dictionary.
Both use the iterator protocol, so you get the same result in both cases.</p>

<h2>Recap and related resources</h2>

<p>Sequences are iterables, but not all iterables are sequences.
When someone says the word &ldquo;iterable&rdquo; you can only assume they mean &ldquo;something that you can iterate over&rdquo;.  Don&rsquo;t assume iterables can be looped over twice, asked for their length, or indexed.</p>

<p>Iterators are the most rudimentary form of iterables in Python.
If you&rsquo;d like to make a lazy iterable in your code think of iterators and consider making a generator function or a generator expression.</p>

<p>And finally, remember that every type of iteration in Python relies on the iterator protocol so understanding the iterator protocol is the key to understanding quite a bit about looping in Python in general.</p>

<p>Here are some related articles and videos I recommend:</p>

<ul>
<li><a href="https://nedbatchelder.com/text/iter.html">Loop Like a Native</a>, Ned Batchelder&rsquo;s PyCon 2013 talk</li>
<li><a href="https://www.youtube.com/watch?v=V2PkkMS2Ack">Loop Better</a>, the talk this article is based on</li>
<li><a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">The Iterator Protocol: How For Loops Work</a>, a short article I wrote on the iterator protocol</li>
<li><a href="https://www.youtube.com/watch?v=5_cJIcgM7rw">Comprehensible Comprehensions</a>, my talk on comprehensions and generator expressions</li>
<li><a href="http://treyhunner.com/2018/02/python-range-is-not-an-iterator/">Python: range is not an iterator</a>, my article on range and iterators</li>
<li><a href="https://www.youtube.com/watch?v=u8g9scXeAcI">Looping Like a Pro in Python</a>, DB&rsquo;s PyCon 2017 talk</li>
</ul>

]]></content>
  </entry>
  
</feed>
