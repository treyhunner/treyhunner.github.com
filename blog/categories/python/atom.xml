<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="http://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://treyhunner.com/"/>
  <updated>2018-03-07T16:36:58-08:00</updated>
  <id>http://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Multiple assignment and tuple unpacking improve Python code readability]]></title>
    <link href="http://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/"/>
    <updated>2018-03-07T16:30:00-08:00</updated>
    <id>http://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability</id>
    <content type="html"><![CDATA[<p>Whether I&rsquo;m teaching new Pythonistas or long-time Python programmers, I frequently find that <strong>Python programmers underutilize multiple assignment</strong>.</p>

<p>Multiple assignment (also known as tuple unpacking or iterable unpacking) allows you to assign multiple variables at the same time in one line of code.
This feature often seems simple after you&rsquo;ve learned about it, but <strong>it can be tricky to recall multiple assignment when you need it most</strong>.</p>

<p>In this article we&rsquo;ll see what multiple assignment is, we&rsquo;ll take a look at common uses of multiple assignment, and then we&rsquo;ll look at a few uses for multiple assignment that are often overlooked.</p>

<p>Note that in this article I will be using <a href="https://cito.github.io/blog/f-strings/">f-strings</a> which are a Python 3.6+ feature.
If you&rsquo;re on an older version of Python, you&rsquo;ll need to mentally translate those to use the string <code>format</code> method.</p>

<h2>How multiple assignment works</h2>

<p>I&rsquo;ll be using the words <strong>multiple assignment</strong>, <strong>tuple unpacking</strong>, and <strong>iterable unpacking</strong> interchangeably in this article.
They&rsquo;re all just different words for the same thing.</p>

<p>Python&rsquo;s multiple assignment looks like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = 10, 20
</code></pre>

<p>Here we&rsquo;re setting <code>x</code> to <code>10</code> and <code>y</code> to <code>20</code>.</p>

<p>What&rsquo;s happening at a lower level is that we&rsquo;re creating a tuple of <code>10, 20</code> and then looping over that tuple and taking each of the two items we get from looping and assigning them to <code>x</code> and <code>y</code> in order.</p>

<p>This syntax might make that a bit more clear:</p>

<pre><code class="pycon">&gt;&gt;&gt; (x, y) = (10, 20)
</code></pre>

<p>Parenthesis are optional around tuples in Python and they&rsquo;re also optional in multiple assignment (which uses a tuple-like syntax).
All of these are equivalent:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = 10, 20
&gt;&gt;&gt; x, y = (10, 20)
&gt;&gt;&gt; (x, y) = 10, 20
&gt;&gt;&gt; (x, y) = (10, 20)
</code></pre>

<p>Multiple assignment is often called &ldquo;tuple unpacking&rdquo; because it&rsquo;s frequently used with tuples.
But we can use multiple assignment with any iterable, not just tuples.
Here we&rsquo;re using it with a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = [10, 20]
&gt;&gt;&gt; x
10
&gt;&gt;&gt; y
20
</code></pre>

<p>And with a string:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = 'hi'
&gt;&gt;&gt; x
'h'
&gt;&gt;&gt; y
'i'
</code></pre>

<p>Anything that can be looped over can be &ldquo;unpacked&rdquo; with tuple unpacking / multiple assignment.</p>

<p>Here&rsquo;s another example to demonstrate that multiple assignment works with any number of items and that it works with variables as well as objects we&rsquo;ve just created:</p>

<pre><code class="pycon">&gt;&gt;&gt; point = 10, 20, 30
&gt;&gt;&gt; x, y, z = point
&gt;&gt;&gt; print(x, y, z)
10 20 30
&gt;&gt;&gt; (x, y, z) = (z, y, x)
&gt;&gt;&gt; print(x, y, z)
30 20 10
</code></pre>

<p>Note that on that last line we&rsquo;re actually swapping variable names, which is something multiple assignment allows us to do easily.</p>

<p>Alright, let&rsquo;s talk about how multiple assignment can be used.</p>

<h2>Unpacking in a for loop</h2>

<p>You&rsquo;ll commonly see multiple assignment used in <code>for</code> loops.</p>

<p>Let&rsquo;s take a dictionary:</p>

<pre><code class="pycon">&gt;&gt;&gt; person_dictionary = {'name': "Trey", 'company': "Truthful Technology LLC"}
</code></pre>

<p>Instead of looping over our dictionary like this:</p>

<pre><code class="python">for item in person_dictionary.items():
    print(f"Key {item[0]} has value {item[1]}")
</code></pre>

<p>You&rsquo;ll often see Python programmers use multiple assignment by writing this:</p>

<pre><code class="python">for key, value in person_dictionary.items():
    print(f"Key {key} has value {value}")
</code></pre>

<p>When you write the <code>for X in Y</code> line of a for loop, you&rsquo;re telling Python that it should do an assignment to <code>X</code> for each iteration of your loop.
Just like in an assignment using the <code>=</code> operator, we can use multiple assignment here.</p>

<p>This:</p>

<pre><code class="python">for key, value in person_dictionary.items():
    print(f"Key {key} has value {value}")
</code></pre>

<p>Is essentially the same as this:</p>

<pre><code class="python">for item in person_dictionary.items():
    key, value = item
    print(f"Key {key} has value {value}")
</code></pre>

<p>We&rsquo;re just not doing an unnecessary extra assignment in the first example.</p>

<p>So multiple assignment is great for unpacking dictionary items into key-value pairs, but it&rsquo;s helpful in many other places too.</p>

<p>It&rsquo;s great when paired with the built-in <code>enumerate</code> function:</p>

<pre><code class="python">for i, line in enumerate(my_file):
    print(f"Line {i}: {line}")
</code></pre>

<p>And the <code>zip</code> function:</p>

<pre><code class="python">for color, ratio in zip(colors, ratios):
    print(f"It's {ratio*100}% {color}.")
</code></pre>

<pre><code class="python">for (product, price, color) in zip(products, prices, colors):
    print(f"{product} is {color} and costs ${price:.2f}")
</code></pre>

<p>If you&rsquo;re unfamiliar with <code>enumerate</code> or <code>zip</code>, see my article on <a href="http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">looping with indexes in Python</a>.</p>

<p>Newer Pythonistas often see multiple assignment in the context of <code>for</code> loops and sometimes assume it&rsquo;s tied to loops.  Multiple assignment works for any assignment though, not just loop assignments.</p>

<h2>An alternative to hard coded indexes</h2>

<p>It&rsquo;s not uncommon to see hard coded indexes (e.g. <code>point[0]</code>, <code>items[1]</code>, <code>vals[-1]</code>) in code:</p>

<pre><code class="python">print(f"The first item is {items[0]} and the last item is {items[-1]}")
</code></pre>

<p>When you see Python code that uses hard coded indexes there&rsquo;s often a way to <strong>use multiple assignment to make your code more readable</strong>.</p>

<p>Here&rsquo;s some code that has three hard coded indexes:</p>

<pre><code class="python">def reformat_date(mdy_date_string):
    """Reformat MM/DD/YYYY string into YYYY-MM-DD string."""
    date = mdy_date_string.split('/')
    return f"{date[2]}-{date[0]}-{date[1]}"
</code></pre>

<p>We can make this code much more readable by using multiple assignment to assign separate month, day, and year variables:</p>

<pre><code class="python">def reformat_date(mdy_date_string):
    """Reformat MM/DD/YYYY string into YYYY-MM-DD string."""
    month, day, year = mdy_date_string.split('/')
    return f"{year}-{month}-{day}"
</code></pre>

<p>Whenever you see hard coded indexes in your code, stop to consider whether you could use multiple assignment to make your code more readable.</p>

<h2>Multiple assignment is very strict</h2>

<p>Multiple assignment is actually fairly strict when it comes to unpacking the iterable we give to it.</p>

<p>If we try to unpack a larger iterable into a smaller number of variables, we&rsquo;ll get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y = (10, 20, 30)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)
</code></pre>

<p>If we try to unpack a smaller iterable into a larger number of variables, we&rsquo;ll also get an error:</p>

<pre><code class="pycon">&gt;&gt;&gt; x, y, z = (10, 20)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: not enough values to unpack (expected 3, got 2)
</code></pre>

<p>This strictness is pretty great.
If we&rsquo;re working with an item that has a different size than we expected, the multiple assignment will fail loudly and we&rsquo;ll hopefully now know about a bug in our program that we weren&rsquo;t yet aware of.</p>

<p>Let&rsquo;s look at an example.
Imagine that we have a short command line program that parses command-line arguments in a rudimentary way, like this:</p>

<pre><code class="python">import sys

new_file = sys.argv[1]
old_file = sys.argv[2]
print(f"Copying {new_file} to {old_file}")
</code></pre>

<p>Our program is supposed to accept 2 arguments, like this:</p>

<pre><code class="bash">$ my_program.py file1.txt file2.txt
Copying file1.txt to file2.txt
</code></pre>

<p>But if someone called our program with three arguments, they will not see an error:</p>

<pre><code class="bash">$ my_program.py file1.txt file2.txt file3.txt
Copying file1.txt to file2.txt
</code></pre>

<p>There&rsquo;s no error because we&rsquo;re not validating that we&rsquo;ve received exactly 2 arguments.</p>

<p>If we use multiple assignment instead of hard coded indexes, the assignment will verify that we receive exactly the expected number of arguments:</p>

<pre><code class="python">import sys

_, new_file, old_file = sys.argv
print(f"Copying {new_file} to {old_file}")
</code></pre>

<p><strong>Note</strong>: we&rsquo;re using the variable name <code>_</code> to note that we don&rsquo;t care about <code>sys.argv[0]</code> (the name of our program).
Using <code>_</code> for variables you don&rsquo;t care about is just a convention.</p>

<h2>An alternative to slicing</h2>

<p>So multiple assignment can be used for avoiding hard coded indexes and it can be used to ensure we&rsquo;re strict about the size of the tuples/iterables we&rsquo;re working with.</p>

<p>Multiple assignment can be used to replace hard coded slices too!</p>

<p>Slicing is a handy way to grab a specific portion of the items in lists and other sequences.</p>

<p>Here are some slices that are &ldquo;hard coded&rdquo; in that they only use numeric indexes:</p>

<pre><code class="python">all_after_first = items[1:]
all_but_last_two = items[:-2]
items_with_ends_removed = items[1:-1]
</code></pre>

<p>Whenever you see slices that don&rsquo;t use any variables in their slice indexes, you can often use multiple assignment instead.
To do this we have to talk about a feature that I haven&rsquo;t mentioned yet: the <code>*</code> operator.</p>

<p>In Python 3.0, the <code>*</code> operator was added to the multiple assignment syntax, allowing us to capture remaining items after an unpacking into a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; first, *rest = numbers
&gt;&gt;&gt; rest
[2, 3, 4, 5, 6]
&gt;&gt;&gt; first
1
</code></pre>

<p>The <code>*</code> operator allows us to replace hard coded slices near the ends of sequences.</p>

<p>These two lines are equivalent:</p>

<pre><code class="pycon">&gt;&gt;&gt; beginning, last = numbers[:-1], numbers[-1]
&gt;&gt;&gt; *beginning, last = numbers
</code></pre>

<p>These two lines are equivalent also:</p>

<pre><code class="pycon">&gt;&gt;&gt; head, middle, tail = numbers[0], numbers[1:-1], numbers[-1]
&gt;&gt;&gt; head, *middle, tail = numbers
</code></pre>

<p>With the <code>*</code> operator and multiple assignment you can replace things like this:</p>

<pre><code class="python">main(sys.argv[0], sys.argv[1:])
</code></pre>

<p>With more descriptive code, like this:</p>

<pre><code class="python">program_name, *arguments = sys.argv
main(program_name, arguments)
</code></pre>

<p>So if you see hard coded slice indexes in your code, consider whether you could use multiple assignment to clarify what those slices really represent.</p>

<h2>Deep unpacking</h2>

<p>This next feature is something that long-time Python programmers often overlook.
It doesn&rsquo;t come up quite as often as the other uses for multiple assignment that I&rsquo;ve discussed, but it can be very handy to know about when you do need it.</p>

<p>We&rsquo;ve seen multiple assignment for unpacking tuples and other iterables.
We haven&rsquo;t yet seen that this is can be done <em>deeply</em>.</p>

<p>I&rsquo;d say that the following multiple assignment is <em>shallow</em> because it unpacks one level deep:</p>

<pre><code class="pycon">&gt;&gt;&gt; color, point = ("red", (1, 2, 3))
&gt;&gt;&gt; color
'red'
&gt;&gt;&gt; point
(1, 2, 3)
</code></pre>

<p>And I&rsquo;d say that this multiple assignment is <em>deep</em> because it unpacks the previous <code>point</code> tuple further into <code>x</code>, <code>y</code>, and <code>z</code> variables:</p>

<pre><code class="pycon">&gt;&gt;&gt; color, (x, y, z) = ("red", (1, 2, 3))
&gt;&gt;&gt; color
'red'
&gt;&gt;&gt; x
1
&gt;&gt;&gt; y
2
</code></pre>

<p>If it seems confusing what&rsquo;s going on above, maybe using parenthesis consistently on both sides of this assignment will help clarify things:</p>

<pre><code class="pycon">&gt;&gt;&gt; (color, (x, y, z)) = ("red", (1, 2, 3))
</code></pre>

<p>We&rsquo;re unpacking one level deep to get two objects, but then we take the second object and unpack it also to get 3 more objects.
Then we assign our first object and our thrice-unpacked second object to our new variables (<code>color</code>, <code>x</code>, <code>y</code>, and <code>z</code>).</p>

<p>Take these two lists:</p>

<pre><code class="python">start_points = [(1, 2), (3, 4), (5, 6)]
end_points = [(-1, -2), (-3, 4), (-6, -5)]
</code></pre>

<p>Here&rsquo;s an example of code that works with these lists by using shallow unpacking:</p>

<pre><code class="python">for start, end in zip(start_points, end_points):
    if start[0] == -end[0] and start[1] == -end[1]:
        print(f"Point {start[0]},{start[1]} was negated.")
</code></pre>

<p>And here&rsquo;s the same thing with deeper unpacking:</p>

<pre><code class="python">for (x1, y1), (x2, y2) in zip(start_points, end_points):
    if x1 == -x2 and y1 == -y2:
        print(f"Point {x1},{y1} was negated.")
</code></pre>

<p>Note that in this second case, it&rsquo;s much more clear what type of objects we&rsquo;re working with.
The deep unpacking makes it apparent that we&rsquo;re receiving two 2-itemed tuples each time we loop.</p>

<p>Deep unpacking often comes up when nesting looping utilities that each provide multiple items.
For example, you may see deep multiple assignments when using <code>enumerate</code> and <code>zip</code> together:</p>

<pre><code class="python">items = [1, 2, 3, 4, 2, 1]
for i, (first, last) in enumerate(zip(items, reversed(items))):
    if first != last:
        raise ValueError(f"Item {i} doesn't match: {first} != {last}")
</code></pre>

<p>I said before that multiple assignment is strict about the size of our iterables as we unpack them.
With deep unpacking we can also be <strong>strict about the shape of our iterables</strong>.</p>

<p>This works:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2), (-1, -2))
&gt;&gt;&gt; points[0][0] == -points[1][0] and points[0][1] == -point[1][1]
True
</code></pre>

<p>But this buggy code works too:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))
&gt;&gt;&gt; points[0][0] == -points[1][0] and points[0][1] == -point[1][1]
True
</code></pre>

<p>Whereas this works:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2), (-1, -2))
&gt;&gt;&gt; (x1, y1), (x2, y2) = points
&gt;&gt;&gt; x1 == -x2 and y1 == -y2
True
</code></pre>

<p>But this does not:</p>

<pre><code class="pycon">&gt;&gt;&gt; points = ((1, 2, 4), (-1, -2, 3), (6, 4, 5))
&gt;&gt;&gt; (x1, y1), (x2, y2) = points
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: too many values to unpack (expected 2)
</code></pre>

<p>With multiple assignment we&rsquo;re assigning variables while also making particular assertions about the size and shape of our iterables.
Multiple assignment will help you clarify your code to both humans (for <strong>better code readability</strong>) and to computers (for <strong>improved code correctness</strong>).</p>

<h2>Using a list-like syntax</h2>

<p>I noted before that multiple assignment uses a tuple-like syntax, but it works on any iterable.
That tuple-like syntax is the reason it&rsquo;s commonly called &ldquo;tuple unpacking&rdquo; even though it might be more clear to say &ldquo;iterable unpacking&rdquo;.</p>

<p>I didn&rsquo;t mention before that multiple assignment also works with <strong>a list-like syntax</strong>.</p>

<p>Here&rsquo;s a multiple assignment with a list-like syntax:</p>

<pre><code class="pycon">&gt;&gt;&gt; [x, y, z] = 1, 2, 3
&gt;&gt;&gt; x
1
</code></pre>

<p>This might seem really strange. What&rsquo;s the point of allowing both list-like and tuple-like syntaxes?</p>

<p>I use this feature rarely, but I find it helpful for <strong>code clarity</strong> in specific circumstances.</p>

<p>Let&rsquo;s say I have code that used to look like this:</p>

<pre><code class="python">def most_common(items):
    return Counter(items).most_common(1)[0][0]
</code></pre>

<p>And our well-intentioned coworker has decided to use deep multiple assignment to refactor our code to this:</p>

<pre><code class="python">def most_common(items):
    (value, times_seen), = Counter(items).most_common(1)
    return value
</code></pre>

<p>See that trailing comma on the left-hand side of the assignment?
It&rsquo;s easy to miss and it makes this code look sort of weird.
What is that comma even doing in this code?</p>

<p>That trailing comma is there to make a single item tuple.
We&rsquo;re doing deep unpacking here.</p>

<p>Here&rsquo;s another way we could write the same code:</p>

<pre><code class="python">def most_common(items):
    ((value, times_seen),) = Counter(items).most_common(1)
    return value
</code></pre>

<p>This might make that deep unpacking a little more obvious but I&rsquo;d prefer to see this instead:</p>

<pre><code class="python">def most_common(items):
    [(value, times_seen)] = Counter(items).most_common(1)
    return value
</code></pre>

<p>The list-syntax in our assignment makes it more clear that we&rsquo;re unpacking a one-item iterable and then unpacking that single item into <code>value</code> and <code>times_seen</code> variables.</p>

<p>When I see this, I also think <em>I bet we&rsquo;re unpacking a single-item list</em>.
And that is in fact what we&rsquo;re doing.
We&rsquo;re using a <a href="https://docs.python.org/3/library/collections.html#collections.Counter">Counter</a> object from the collections module here.
The <code>most_common</code> method on <code>Counter</code> objects allows us to limit the length of the list returned to us.
We&rsquo;re limiting the list we&rsquo;re getting back to just a single item.</p>

<p>When you&rsquo;re unpacking structures that often hold lots of values (like lists) and structures that often hold a very specific number of values (like tuples) you may decide that your code appears more <em>semantically accurate</em> if you use a list-like syntax when unpacking those list-like structures.</p>

<p>If you&rsquo;d like you might even decide to adopt a convention of always using a list-like syntax when unpacking list-like structures (frequently the case when using <code>*</code> in multiple assignment):</p>

<pre><code class="pycon">&gt;&gt;&gt; [first, *rest] = numbers
</code></pre>

<p>I don&rsquo;t usually use this convention myself, mostly because I&rsquo;m just not in the habit of using it.
But if you find it helpful, you might consider using this convention in your own code.</p>

<p>When using multiple assignment in your code, consider when and where a list-like syntax might make your code more descriptive and more clear.
This can sometimes improve readability.</p>

<h2>Don&rsquo;t forget about multiple assignment</h2>

<p>Multiple assignment can improve both the readability of your code and the correctness of your code.
It can make your code <strong>more descriptive</strong> while also making implicit assertions about the <strong>size and shape</strong> of the iterables you&rsquo;re unpacking.</p>

<p>The use for multiple assignment that I often see forgotten is its ability to <strong>replace hard coded indexes</strong>, including <strong>replacing hard coded slices</strong> (using the <code>*</code> syntax).
It&rsquo;s also common to overlook the fact that multiple assignment works <em>deeply</em> and can be used with both a <em>tuple-like</em> syntax and a <em>list-like</em> syntax.</p>

<p>It&rsquo;s tricky to recognize and remember all the cases that multiple assignment can come in handy.
Please feel free to use this article as your personal reference guide to multiple assignment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python: range is not an iterator!]]></title>
    <link href="http://treyhunner.com/2018/02/python-range-is-not-an-iterator/"/>
    <updated>2018-02-28T16:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/02/python-range-is-not-an-iterator</id>
    <content type="html"><![CDATA[<p>After my <a href="https://www.youtube.com/watch?v=Wd7vcuiMhxU">Loop Better talk at PyGotham 2017</a> someone asked me a great question: iterators are lazy iterables and <code>range</code> is a lazy iterable in Python 3, so is <code>range</code> an iterator?</p>

<p>Unfortunately, I don&rsquo;t remember the name of the person who asked me this question.  I do remember saying something along the lines of &ldquo;oh I love that question!&rdquo;</p>

<p>I love this question because <code>range</code> objects in Python 3 (<a href="treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/">xrange in Python 2</a>) are lazy, but <strong>range objects are not iterators</strong> and this is something I see folks mix up frequently.</p>

<p>In the last year I&rsquo;ve heard Python beginners, long-time Python programmers, and even other Python trainers mistakenly refer to Python 3&rsquo;s <code>range</code> objects as iterators.  This distinction is something a lot of people get confused about.</p>

<h2>Yes this <em>is</em> confusing</h2>

<p>When people talk about iterators and iterables in Python, you&rsquo;re likely to hear the someone repeat the misconception that <code>range</code> is an iterator.  This mistake might seem unimportant at first, but I think it&rsquo;s actually a pretty critical one.  If you believe that <code>range</code> objects are iterators, your mental model of how iterators work in Python <em>isn&rsquo;t clear enough yet</em>.  Both <code>range</code> and iterators are &ldquo;lazy&rdquo; in a sense, but they&rsquo;re lazy in fairly different ways.</p>

<p>With this article I&rsquo;m going to explain how iterators work, how <code>range</code> works, and how the laziness of these two types of &ldquo;lazy iterables&rdquo; differs.</p>

<p>But first, I&rsquo;d like to ask that you <strong>do not use the information below as an excuse to be unkind to anyone</strong>, whether new learners or experienced Python programmers.  Many people have used Python very happily for years without fully understanding the distinction I&rsquo;m about to explain.  You can write many thousands of lines of Python code without having a strong mental model of how iterators work.</p>

<h2>What&rsquo;s an iterator?</h2>

<p>In Python an iterable is anything that you can iterate over and an iterator is the thing that does the actual iterating.</p>

<p>Iter-<strong>ables</strong> are able to be iterated over.  Iter-<strong>ators</strong> are the agents that perform the iteration.</p>

<p>You can get an iterator from any iterable in Python by using the <code>iter</code> function:</p>

<pre><code class="python">&gt;&gt;&gt; iter([1, 2])
&lt;list_iterator object at 0x7f043a081da0&gt;
&gt;&gt;&gt; iter('hello')
&lt;str_iterator object at 0x7f043a081dd8&gt;
</code></pre>

<p>Once you have an iterator, the only thing you can do with it is get its next item:</p>

<pre><code class="python">&gt;&gt;&gt; my_iterator = iter([1, 2])
&gt;&gt;&gt; next(my_iterator)
1
&gt;&gt;&gt; next(my_iterator)
2
</code></pre>

<p>And you&rsquo;ll get a stop iteration exception if you ask for the next item but there aren&rsquo;t anymore items:</p>

<pre><code class="python">&gt;&gt;&gt; next(my_iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>Both conveniently and somewhat confusingly, all iterators are also iterables.  Meaning you can get an iterator from an iterator (it&rsquo;ll give you itself back).  Therefore you can iterate over an iterator as well:</p>

<pre><code class="python">&gt;&gt;&gt; my_iterator = iter([1, 2])
&gt;&gt;&gt; [x**2 for x in my_iterator]
[1, 4]
</code></pre>

<p>Importantly, it should be noted that iterators are stateful.  Meaning once you&rsquo;ve consumed an item from an iterator, it&rsquo;s gone.  So after you&rsquo;ve looped over an iterator once, it&rsquo;ll be empty if you try to loop over it again:</p>

<pre><code class="python">&gt;&gt;&gt; my_iterator = iter([1, 2])
&gt;&gt;&gt; [x**2 for x in my_iterator]
[1, 4]
&gt;&gt;&gt; [x**2 for x in my_iterator]
[]
</code></pre>

<p>In Python 3, <code>enumerate</code>, <code>zip</code>, <code>reversed</code>, and a number of other built-in functions return iterators:</p>

<pre><code class="python">&gt;&gt;&gt; enumerate(numbers)
&lt;enumerate object at 0x7f04384ff678&gt;
&gt;&gt;&gt; zip(numbers, numbers)
&lt;zip object at 0x7f043a085cc8&gt;
&gt;&gt;&gt; reversed(numbers)
&lt;list_reverseiterator object at 0x7f043a081f28&gt;
</code></pre>

<p>Generators (whether from generator functions or generator expressions) are one of the simpler ways to create your own iterators:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = [1, 2, 3, 4, 5]
&gt;&gt;&gt; squares = (n**2 for n in numbers)
&gt;&gt;&gt; squares
&lt;generator object &lt;genexpr&gt; at 0x7f043a0832b0&gt;
</code></pre>

<p>I often say that iterators are lazy single-use iterables.  They&rsquo;re &ldquo;lazy&rdquo; because they have the ability to only compute items as you loop over them.  And they&rsquo;re &ldquo;single-use&rdquo; because once you&rsquo;ve &ldquo;consumed&rdquo; an item from an iterator, it&rsquo;s gone forever.  The term &ldquo;exhausted&rdquo; is often used for an iterator that has been fully consumed.</p>

<p>That was the quick summary of what iterators are.  If you haven&rsquo;t encountered iterators before, I&rsquo;d recommend reviewing them a bit further before continuing on.  I&rsquo;ve written <a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">an article which explains iterators</a> and I&rsquo;ve given a talk, <a href="https://www.youtube.com/watch?v=Wd7vcuiMhxU">Loop Better</a> which I mentioned earlier, during which I dive a bit deeper into iterators.</p>

<h2>How is range different?</h2>

<p>Okay we&rsquo;ve reviewed iterators.  Let&rsquo;s talk about <code>range</code> now.</p>

<p>The <code>range</code> object in Python 3 (<code>xrange</code> in Python 2) can be looped over like any other iterable:</p>

<pre><code class="python">&gt;&gt;&gt; for n in range(3):
...     print(n)
...
0
1
2
</code></pre>

<p>And because <code>range</code> is an iterable, we can get an iterator from it:</p>

<pre><code class="python">&gt;&gt;&gt; iter(range(3))
&lt;range_iterator object at 0x7f043a0a7f90&gt;
</code></pre>

<p>But <code>range</code> objects themselves are not iterators.  We <strong>cannot</strong> call <code>next</code> on a <code>range</code> object:</p>

<pre><code class="python">&gt;&gt;&gt; next(range(3))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'range' object is not an iterator
</code></pre>

<p>And unlike an iterator, we can loop over a <code>range</code> object without consuming it:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = range(3)
&gt;&gt;&gt; tuple(numbers)
(0, 1, 2)
&gt;&gt;&gt; tuple(numbers)
(0, 1, 2)
</code></pre>

<p>If we did this with an iterator, we&rsquo;d get no elements the second time we looped:</p>

<pre><code class="python">&gt;&gt;&gt; numbers = iter(range(3))
&gt;&gt;&gt; tuple(numbers)
(0, 1, 2)
&gt;&gt;&gt; tuple(numbers)
()
</code></pre>

<p>Unlike <code>zip</code>, <code>enumerate</code>, or <code>generator</code> objects, <code>range</code> objects <strong>are not iterators</strong>.</p>

<h2>So what is range?</h2>

<p>The <code>range</code> object is &ldquo;lazy&rdquo; in a sense because it doesn&rsquo;t generate every number that it &ldquo;contains&rdquo; when we create it.  Instead it gives those numbers to us as we need them when looping over it.</p>

<p>Here is a <code>range</code> object and a generator (which is a type of iterator):</p>

<pre><code class="python">&gt;&gt;&gt; numbers = range(1_000_000)
&gt;&gt;&gt; squares = (n**2 for n in numbers)
</code></pre>

<p>Unlike iterators, <code>range</code> objects have a length:</p>

<pre><code class="python">&gt;&gt;&gt; len(numbers)
1000000
&gt;&gt;&gt; len(squares)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: object of type 'generator' has no len()
</code></pre>

<p>And they can be indexed:</p>

<pre><code class="python">&gt;&gt;&gt; numbers[-2]
999998
&gt;&gt;&gt; squares[-2]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'generator' object is not subscriptable
</code></pre>

<p>And unlike iterators, you can ask them whether they contain things without changing their state:</p>

<pre><code class="python">&gt;&gt;&gt; 0 in numbers
True
&gt;&gt;&gt; 0 in numbers
True
&gt;&gt;&gt; 0 in squares
True
&gt;&gt;&gt; 0 in squares
False
</code></pre>

<p>If you&rsquo;re looking for a description for <code>range</code> objects, you could call them &ldquo;lazy sequences&rdquo;.  They&rsquo;re sequences (like lists, tuples, and strings) but they don&rsquo;t really contain any memory under the hood and instead answer questions computationally.</p>

<pre><code class="python">&gt;&gt;&gt; from collections.abc import Sequence
&gt;&gt;&gt; isinstance([1, 2], Sequence)
True
&gt;&gt;&gt; isinstance('hello', Sequence)
True
&gt;&gt;&gt; isinstance(range(3), Sequence)
True
</code></pre>

<h2>Why does this distinction matter?</h2>

<p>It might seem like I&rsquo;m nitpicking in saying that range isn&rsquo;t an iterator, but I really don&rsquo;t think I am.</p>

<p>If I tell you something is an iterator, you&rsquo;ll know that when you call <code>iter</code> on it you&rsquo;ll always get the same object back (by definition):</p>

<pre><code>&gt;&gt;&gt; iter(my_iterator) is my_iterator
True
</code></pre>

<p>And you&rsquo;ll be certain that you can call <code>next</code> on it because you can call <code>next</code> on all iterators:</p>

<pre><code>&gt;&gt;&gt; next(my_iterator)
4
&gt;&gt;&gt; next(my_iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>And you&rsquo;ll know that items will be consumed from the iterator as you loop over it.  Sometimes this feature can come in handy for processing iterators in particular ways:</p>

<pre><code class="python">&gt;&gt;&gt; my_iterator = iter([1, 2, 3, 4])
&gt;&gt;&gt; list(zip(my_iterator, my_iterator))
[(1, 2), (3, 4)]
</code></pre>

<p>So while it may seem like the difference between &ldquo;lazy iterable&rdquo; and &ldquo;iterator&rdquo; is subtle, these terms really do mean different things.  While &ldquo;lazy iterable&rdquo; is a very general term without concrete meaning, the word &ldquo;iterator&rdquo; implies an object with a very specific set of behaviors.</p>

<h2>When in doubt say &ldquo;iterable&rdquo; or &ldquo;lazy iterable&rdquo;</h2>

<p>If you know you can loop over something, it&rsquo;s an <strong>iterable</strong>.</p>

<p>If you know the thing you&rsquo;re looping over happens to compute things as you loop over it, it&rsquo;s a <strong>lazy iterable</strong>.</p>

<p>If you know you can pass something to the <code>next</code> function, it&rsquo;s an <strong>iterator</strong> (which are the most common form of lazy iterables).</p>

<p>If you can loop over something multiple times without &ldquo;exhausting&rdquo; it, it&rsquo;s not an iterator.  If you can&rsquo;t pass something to the <code>next</code> function, it&rsquo;s not an iterator.  Python 3&rsquo;s <code>range</code> object is not an iterator.  If you&rsquo;re teaching people about <code>range</code> objects, please don&rsquo;t use the word &ldquo;iterator&rdquo;.  It&rsquo;s confusing and might cause others to start misusing the word &ldquo;iterator&rdquo; as well.</p>

<p>On the other hand, if you see someone else misusing the word iterator don&rsquo;t be mean.  You may want to point out the misuse if it seems important, but keep in mind that I&rsquo;ve heard long-time Python programmers and experienced Python trainers misuse this word by calling <code>range</code> objects iterators.  Words are important, but language is tricky.</p>

<p>Thanks for joining me on this brief <code>range</code> and iterator-filled adventure!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 3's range is more powerful than Python 2's xrange]]></title>
    <link href="http://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/"/>
    <updated>2018-02-15T08:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange</id>
    <content type="html"><![CDATA[<p>If you&rsquo;re switching between Python 2 and Python 3, you might think that Python 2&rsquo;s <code>xrange</code> objects are pretty much the identical to Python 3&rsquo;s <code>range</code> object.  It seems like they probably just renamed <code>xrange</code> to <code>range</code>, right?</p>

<p>Not quite.</p>

<p>Python 2&rsquo;s <code>xrange</code> is somewhat more limited than Python 3&rsquo;s <code>range</code>.  In this article we&rsquo;re going to take a look at how <code>xrange</code> in Python 2 differs from <code>range</code> in Python 3.</p>

<p>The inspiration for this article came from <a href="https://www.crowdcast.io/e/range/1/q/-KpfDuicwa4YGF9tAoMW">a question I addressed</a> during a <a href="http://www.weeklypython.chat">Weekly Python Chat</a> session I did last year on range objects.</p>

<h2>Python 2 vs Python 3: range</h2>

<p>The first thing I need to address is how <code>range</code> works in Python 2 and Python 3.</p>

<p>In Python 2, the <code>range</code> function returned a list of numbers:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(5)
[0, 1, 2, 3, 4]
</code></pre>

<p>And the <code>xrange</code> class represented an iterable that provided the same thing when looped over, but it was lazy:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(5)
xrange(5)
</code></pre>

<p>This laziness was really embraced in Python 3.  In Python 3, they removed the original <code>range</code> function and renamed <code>xrange</code> to <code>range</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(5)
range(0, 5)
</code></pre>

<p>So if you wanted the Python 2 behavior for <code>range</code> in Python 3, you could always convert the <code>range</code> object to a list:</p>

<pre><code class="pycon">&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
</code></pre>

<p>Okay now let&rsquo;s compare Python 2&rsquo;s <code>xrange</code> class to Python 3&rsquo;s <code>range</code> class.</p>

<h2>Similarities</h2>

<p>Before we take a look at differences between <code>xrange</code> and <code>range</code> objects, let&rsquo;s take a look at some of the similarities.</p>

<p>Python 2&rsquo;s <code>xrange</code> has a fairly descriptive string representation:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(10)
xrange(10)
</code></pre>

<p>And so does Python 3&rsquo;s <code>range</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(10)
range(0, 10)
</code></pre>

<p>The <code>xrange</code> object in Python 2 is an iterable (anything you can loop over is an iterable):</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in xrange(3):
...     print n
...
0
1
2
</code></pre>

<p>And the <code>range</code> object in Python 3 is also an iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in range(3):
...     print(n)
...
0
1
2
</code></pre>

<p>The <code>xrange</code> object has a start, stop, and step.  Step is optional and so is start:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(0, 5, 1)
xrange(5)
&gt;&gt;&gt; xrange(0, 5)
xrange(5)
&gt;&gt;&gt; xrange(5)
xrange(5)
&gt;&gt;&gt; list(xrange(0, 10, 3))
[0, 3, 6, 9]
</code></pre>

<p>So does the <code>range</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(0, 5, 1)
range(0, 5)
&gt;&gt;&gt; range(0, 5)
range(0, 5)
&gt;&gt;&gt; range(5)
range(0, 5)
&gt;&gt;&gt; list(range(0, 10, 3))
[0, 3, 6, 9]
</code></pre>

<p>Both have a length and both can be indexed in forward or reverse order:</p>

<pre><code class="pycon">&gt;&gt;&gt; len(xrange(5))
5
&gt;&gt;&gt; xrange(0, 5)[3]
3
&gt;&gt;&gt; xrange(0, 5)[-1]
4
</code></pre>

<p>Python considers both <code>range</code> and <code>xrange</code> to be sequences:</p>

<pre><code class="pycon">&gt;&gt;&gt; from collections import Sequence
&gt;&gt;&gt; isinstance(xrange(10), Sequence)
True
</code></pre>

<p>So much of the basic functionality is the same between <code>xrange</code> and <code>range</code>.  Let&rsquo;s talk about the differences.</p>

<h2>Dunder Methods</h2>

<p>The first difference we&rsquo;ll look at is the built-in documentation that exists for Python 2&rsquo;s <code>xrange</code> and Python 3&rsquo;s <code>range</code>.</p>

<p>If we use the <code>help</code> function to ask <code>xrange</code> for documentation, we&rsquo;ll see a number of dunder methods.  Dunder methods are what Python uses when you use many operators on objects (like <code>+</code> or <code>*</code>) as well as other features shared between different objects (like the <code>len</code> and <code>str</code> functions).</p>

<p>Here are the core dunder methods which Python 2&rsquo;s <code>xrange</code> objects fully implement:</p>

<pre><code> |  __getitem__(...)
 |      x.__getitem__(y) &lt;==&gt; x[y]
 |
 |  __iter__(...)
 |      x.__iter__() &lt;==&gt; iter(x)
 |
 |  __len__(...)
 |      x.__len__() &lt;==&gt; len(x)
 |
 |  __reduce__(...)
 |
 |  __repr__(...)
 |      x.__repr__() &lt;==&gt; repr(x)
 |
 |  __reversed__(...)
 |      Returns a reverse iterator.
</code></pre>

<p>And here are the core dunder methods which Python 3&rsquo;s <code>range</code> objects fully implement:</p>

<pre><code> |  __contains__(self, key, /)
 |      Return key in self.
 |
 |  __eq__(self, value, /)
 |      Return self==value.
 |
 |  __getitem__(self, key, /)
 |      Return self[key].
 |
 |  __iter__(self, /)
 |      Implement iter(self).
 |
 |  __len__(self, /)
 |      Return len(self).
 |
 |  __ne__(self, value, /)
 |      Return self!=value.
 |
 |  __repr__(self, /)
 |      Return repr(self).
 |
 |  __reversed__(...)
 |      Return a reverse iterator.
 |
 |  count(...)
 |      rangeobject.count(value) -&gt; integer -- return number of occurrences of value
 |
 |  index(...)
 |      rangeobject.index(value, [start, [stop]]) -&gt; integer -- return index of value.
 |      Raise ValueError if the value is not present.
</code></pre>

<p>Notice that <code>range</code> objects support many more operations than <code>xrange</code> does.  Let&rsquo;s take a look at some of them.</p>

<h2>Comparability</h2>

<p>Python 3&rsquo;s <code>range</code> support equality checks:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(4) == range(5)
False
&gt;&gt;&gt; range(5) == range(5)
True
</code></pre>

<p>Python 2&rsquo;s <code>xrange</code> objects may seem like they support equality:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(4) == xrange(5)
False
</code></pre>

<p>But they&rsquo;re actually falling back to Python&rsquo;s default identity check:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(5) == xrange(5)
False
</code></pre>

<p>Two <code>xrange</code> objects will not be seen as equal unless they are actually the same exact object:</p>

<pre><code class="pycon">&gt;&gt;&gt; a = xrange(5)
&gt;&gt;&gt; b = xrange(5)
&gt;&gt;&gt; a == a
True
&gt;&gt;&gt; a == b
False
</code></pre>

<p>Whereas a comparison between two <code>range</code> objects in Python 3 actually checks whether the start, stop, and step of each object is equal:</p>

<pre><code class="pycon">&gt;&gt;&gt; a = range(1, 10, 2)
&gt;&gt;&gt; b = range(1, 10, 2)
&gt;&gt;&gt; a == a
True
&gt;&gt;&gt; a == b
True
</code></pre>

<h2>Sliceabiltiy</h2>

<p>We already saw that both Python 2&rsquo;s <code>xrange</code> and Python 3&rsquo;s <code>range</code> support indexing:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(10)[3]
3
&gt;&gt;&gt; range(10)[-1]
9
</code></pre>

<p>Python 3&rsquo;s <code>range</code> object also supports slicing:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(10)[2:]
range(2, 10)
&gt;&gt;&gt; range(10)[3:8:-1]
range(3, 8, -1)
</code></pre>

<p>But <code>xrange</code> doesn&rsquo;t:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(10)[2:]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: sequence index must be integer, not 'slice'
</code></pre>

<h2>Containment</h2>

<p>Both <code>range</code> and <code>xrange</code> support containment checks:</p>

<pre><code class="pycon">&gt;&gt;&gt; 5 in xrange(10)
True
</code></pre>

<p>But this support is a little deceptive with <code>xrange</code>.  Python 2&rsquo;s <code>xrange</code> objects don&rsquo;t actually implement the <code>__contains__</code> method that is used to implement Python&rsquo;s <code>in</code> operator.</p>

<p>So while we can ask whether an <code>xrange</code> object contains a number, in order to answer our question Python will have to manually loop over the <code>xrange</code> object until it finds a match.</p>

<p>This takes about 20 seconds to run on my computer in Python 2.7.12:</p>

<pre><code class="pycon">&gt;&gt;&gt; -1 in xrange(1000000000)
False
</code></pre>

<p>But in Python 3 this returns an answer immediately:</p>

<pre><code class="pycon">&gt;&gt;&gt; -1 in range(1000000000)
False
</code></pre>

<p>Python 3 is able to return an answer immediately for <code>range</code> objects because it can compute an answer based off the start, stop, and step we provided.</p>

<h2>Start, stop, and step</h2>

<p>In Python 3, <code>range</code> objects have a start, stop, and step:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = range(10)
&gt;&gt;&gt; numbers.start
0
&gt;&gt;&gt; numbers.stop
10
&gt;&gt;&gt; numbers.step
1
</code></pre>

<p>These can be useful when playing with or extending the capability of <code>range</code>.</p>

<p>We might for example wish that <code>range</code> objects could be negated to get a mirrored <code>range</code> on the opposite side of the number line:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = range(5, 20)
&gt;&gt;&gt; -numbers
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: bad operand type for unary -: 'range'
</code></pre>

<p>While <code>range</code> objects don&rsquo;t support this feature, we could implement something similar by negating the start, stop, and step ourselves and making a new <code>range</code>:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = range(5, 20)
&gt;&gt;&gt; range(-numbers.start, -numbers.stop, -numbers.step)
range(-5, -20, -1)
</code></pre>

<p>While you can provide start, stop, and step as arguments to Python 2&rsquo;s <code>xrange</code> objects, they don&rsquo;t have these start, stop, and step <strong>attributes</strong> at all:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = xrange(10)
&gt;&gt;&gt; numbers.start
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'xrange' object has no attribute 'start'
</code></pre>

<p>If you wanted to get start, stop, and step from an <code>xrange</code> object, you would need to calculate them manually.  Something like this might work:</p>

<pre><code class="pycon">&gt;&gt;&gt; numbers = xrange(10)
&gt;&gt;&gt; start, stop, step = numbers[0], numbers[-1]+1, numbers[1]-numbers[0]
&gt;&gt;&gt; start
0
&gt;&gt;&gt; stop
10
&gt;&gt;&gt; step
1
</code></pre>

<h2>Support for big numbers</h2>

<p>The last difference I&rsquo;d like to mention is sort of a silly one, but it could be important for some interesting use cases of <code>range</code> and <code>xrange</code>.</p>

<p>In Python 3, the <code>range</code> object will accept integers of any size:</p>

<pre><code class="pycon">&gt;&gt;&gt; range(10**19)
range(0, 10000000000000000000)
</code></pre>

<p>But Python 2&rsquo;s <code>xrange</code> objects are limited in the size of integers they can accept:</p>

<pre><code class="pycon">&gt;&gt;&gt; xrange(10**19)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: Python int too large to convert to C long
</code></pre>

<p>I run into this difference most often during my on-site team training sessions because I sometimes use silly examples with big numbers when I teach.</p>

<h2>Is any of this important to know?</h2>

<p>Most of the time you use either Python 2&rsquo;s <code>xrange</code> objects or Python 3&rsquo;s <code>range</code> objects, you&rsquo;ll probably just be creating them and looping over them immediately:</p>

<pre><code class="pycon">&gt;&gt;&gt; for n in range(0, 10, 3):
...     print(n)
...
0
3
6
9
</code></pre>

<p>So the missing <code>xrange</code> features I noted above don&rsquo;t matter most of the time.</p>

<p>However, there are times when it&rsquo;s useful to have a sequence of consecutive numbers that supports features like slicing, fast containment checks, or equality.  In those cases, Python 2 users will be tempted to fall back to the Python 2 <code>range</code> function which returns a list.  In Python 3 though, you&rsquo;ll pretty much always find what you&rsquo;re looking for in the <code>range</code> class.  For pretty much every operation you&rsquo;ll want to perform, <strong>Python 3&rsquo;s <code>range</code> is fast, memory-efficient, and powerful</strong>.</p>

<p>Python 3 put a lot of work into making sure its built-ins are memory efficient and fast.  Many built-in functions (e.g. <code>zip</code>, <code>map</code>, <code>filter</code>) now return iterators and lazy objects instead of lists.</p>

<p>At the same time, Python 3 made common functions and classes, like <code>range</code>, more featureful.</p>

<p>There are many big improvements that Python 3 made over Python 2, but there are <strong>many many more tiny benefits to upgrading to Python 3</strong>.  If you haven&rsquo;t already, I&rsquo;d strongly consider whether it makes sense for you to upgrade your code to Python 3.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Craft Your Python Like Poetry]]></title>
    <link href="http://treyhunner.com/2017/07/craft-your-python-like-poetry/"/>
    <updated>2017-07-23T10:00:00-07:00</updated>
    <id>http://treyhunner.com/2017/07/craft-your-python-like-poetry</id>
    <content type="html"><![CDATA[<p>Line length is a big deal&hellip; programmers argue about it quite a bit.  PEP 8, the Python style guide, recommends a <a href="http://pep8.org/#maximum-line-length">79 character maximum line length</a> but concedes that a line length up to 100 characters is acceptable for teams that agree to use a specific longer line length.</p>

<p>So 79 characters is recommended&hellip; but isn&rsquo;t line length completely obsolete?  After all, programmers are no longer restricted by <a href="https://en.wikipedia.org/wiki/Punched_card">punch cards</a>, <a href="https://en.wikipedia.org/wiki/Teletype_Corporation">teletypes</a>, and 80 column <a href="https://en.wikipedia.org/wiki/Computer_terminal">terminals</a>.  The laptop screen I&rsquo;m typing this on can fit about 200 characters per line.</p>

<h2>Line length is not obsolete</h2>

<p>Line length is not a technical limitation: it&rsquo;s a human-imposed limitation.  Many programmers prefer short lines because <strong>long lines are hard to read</strong>.  This is true in typography and it&rsquo;s true in programming as well.</p>

<p>Short lines are easier to read.</p>

<p>In the typography world, a line length of 55 characters per line is recommended for electronic text (see <a href="https://en.wikipedia.org/wiki/Line_length">line length on Wikipedia</a>).  That doesn&rsquo;t mean we should use a 55 character limit though; typography and programming are different.</p>

<h2>Python isn&rsquo;t prose</h2>

<p>Python code isn&rsquo;t structured like prose.  English prose is structured in flowing sentences: each line wraps into the next line.  In Python, <strong>statements</strong> are somewhat like <strong>sentences</strong>, meaning each sentence begins at the <em>start</em> of each line.</p>

<p>Python code is more like poetry than prose.  Poets and Python programmers don&rsquo;t wrap lines once they hit an arbitrary length; they wrap lines when they make sense for readability and beauty.</p>

<pre><code>I stand amid the roar Of a surf-tormented shore, And I hold within my hand
Grains of the golden sand How few! yet how they creep Through my fingers to
the deep, While I weepwhile I weep! O God! can I not grasp Them with a
tighter clasp? O God! can I not save One from the pitiless wave? Is all that we
see or seem But a dream within a dream?
</code></pre>

<p>Don&rsquo;t wrap lines arbitrarily. Craft each line with care to help readers <strong>experience your code exactly the way you intended</strong>.</p>

<pre><code>I stand amid the roar
Of a surf-tormented shore,
And I hold within my hand
Grains of the golden sand
How few! yet how they creep
Through my fingers to the deep,
While I weepwhile I weep!
O God! can I not grasp
Them with a tighter clasp?
O God! can I not save
One from the pitiless wave?
Is all that we see or seem
But a dream within a dream?
</code></pre>

<h2>Examples</h2>

<p>It&rsquo;s not possible to make a single rule for when and how to wrap lines of code.  <a href="http://pep8.org/#indentation">PEP8 discusses line wrapping briefly</a>, but it only discusses one case of line wrapping and three different acceptable styles are provided, leaving the reader to choose which is best.</p>

<p>Line wrapping is best discussed through examples.  Let&rsquo;s look at a few examples of long lines and few variations for line wrapping for each.</p>

<h3>Example: Wrapping a Comprehension</h3>

<p>This line of code is over 79 characters long:</p>

<pre><code class="python">employee_hours = [schedule.earliest_hour for employee in self.public_employees for schedule in employee.schedules]
</code></pre>

<p>Here we&rsquo;ve wrapped that line of code so that it&rsquo;s two shorter lines of code:</p>

<pre><code class="python">employee_hours = [schedule.earliest_hour for employee in
                  self.public_employees for schedule in employee.schedules]
</code></pre>

<p>We&rsquo;re able to insert that line break in this line because we have an <strong>unclosed square bracket</strong>.  This is called an <strong>implicit line continuation</strong>.  Python knows we&rsquo;re continuing a line of code whenever there&rsquo;s a line break inside unclosed square brackets, curly braces, or parentheses.</p>

<p>This code still isn&rsquo;t very easy to read because the line break was inserted arbitrarily.  We simply wrapped this line just before a specific line length.  We were thinking about line length here, but we completely neglected to think about readability.</p>

<p>This code is the same as above, but we&rsquo;ve inserted line breaks in very particular places:</p>

<pre><code class="python">employee_hours = [schedule.earliest_hour
                  for employee in self.public_employees
                  for schedule in employee.schedules]
</code></pre>

<p>We have two lines breaks here and we&rsquo;ve purposely inserted them before our <code>for</code> clauses in this list comprehension.</p>

<p>Statements have logical components that make up a whole, the same way sentences have clauses that make up the whole.  We&rsquo;ve chosen to break up this list comprehension by inserting line breaks <strong>between these logical components</strong>.</p>

<p>Here&rsquo;s another way to break up this statement:</p>

<pre><code class="python">employee_hours = [
    schedule.earliest_hour
    for employee in self.public_employees
    for schedule in employee.schedules
]
</code></pre>

<p>Which of these methods you prefer is up to you.  It&rsquo;s important to make sure you break up the logical components though.  And whichever method you choose, <strong>be consistent</strong>!</p>

<h3>Example: Function Calls</h3>

<p>This is a Django model field with a whole bunch of arguments being passed to it:</p>

<pre><code class="python">default_appointment = models.ForeignKey(othermodel='AppointmentType',
                                        null=True, on_delete=models.SET_NULL,
                                        related_name='+')
</code></pre>

<p>We&rsquo;re already using an implicit line continuation to wrap these lines of code, but again we&rsquo;re wrapping this code at an arbitrary line length.</p>

<p>Here&rsquo;s the same Django model field with one argument specific per line:</p>

<pre><code class="python">default_appointment = models.ForeignKey(othermodel='AppointmentType',
                                        null=True,
                                        on_delete=models.SET_NULL,
                                        related_name='+')
</code></pre>

<p>We&rsquo;re breaking up the component parts (the arguments) of this statement onto separate lines.</p>

<p>We could also wrap this line by indenting each argument instead of aligning them:</p>

<pre><code class="python">default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+'
)
</code></pre>

<p>Notice we&rsquo;re also leaving that closing parenthesis on its own line.  We could additionally add a trailing comma if we wanted:</p>

<pre><code class="python">default_appointment = models.ForeignKey(
    othermodel='AppointmentType',
    null=True,
    on_delete=models.SET_NULL,
    related_name='+',
)
</code></pre>

<p><strong>Which of these is the best way to wrap this line?</strong></p>

<p>Personally for this line I prefer that last approach: each argument on its own line, the closing parenthesis on its own line, and a comma after each argument.</p>

<p>It&rsquo;s important to decide what you prefer, reflect on why you prefer it, and always maintain consistency within each project/file you create.  And keep in mind that consistence of your personal style is less important than <strong>consistency within a single project</strong>.</p>

<h3>Example: Chained Function Calls</h3>

<p>Here&rsquo;s a long line of chained Django queryset methods:</p>

<pre><code class="python">    books = Book.objects.filter(author__in=favorite_authors).select_related('author', 'publisher').order_by('title')
</code></pre>

<p>Notice that there aren&rsquo;t parenthesis around this whole statement, so the only place we can currently wrap our lines is inside those parenthesis.  We could do something like this:</p>

<pre><code class="python">    books = Book.objects.filter(
        author__in=favorite_authors
    ).select_related(
        'author', 'publisher'
    ).order_by('title')
</code></pre>

<p>But that looks kind of weird and it doesn&rsquo;t really improve readability.</p>

<p>We could add backslashes at the end of each line to allow us to wrap at arbitrary places:</p>

<pre><code class="python">    books = Book.objects\
        .filter(author__in=favorite_authors)\
        .select_related('author', 'publisher')\
        .order_by('title')
</code></pre>

<p>This works, but <a href="http://pep8.org/#maximum-line-length">PEP8 recommends against this</a>.</p>

<p>We could wrap the whole statement in parenthesis, allowing us to use implicit line continuation wherever we&rsquo;d like:</p>

<pre><code class="python">    books = (Book.objects
        .filter(author__in=favorite_authors)
        .select_related('author', 'publisher')
        .order_by('title'))
</code></pre>

<p>It&rsquo;s not uncommon to see extra parenthesis added in Python code to allow implicit line continuations.</p>

<p>That indentation style is a little odd though.  We could align our code with the parenthesis instead:</p>

<pre><code class="python">    books = (Book.objects
             .filter(author__in=favorite_authors)
             .select_related('author', 'publisher')
             .order_by('title'))
</code></pre>

<p>Although I&rsquo;d probably prefer to align the dots in this case:</p>

<pre><code class="python">    books = (Book.objects
                 .filter(author__in=favorite_authors)
                 .select_related('author', 'publisher')
                 .order_by('title'))
</code></pre>

<p>A fully indentation-based style works too (we&rsquo;ve also moved <code>objects</code> to its own line here):</p>

<pre><code class="python">    books = (
        Book
        .objects
        .filter(author__in=favorite_authors)
        .select_related('author', 'publisher')
        .order_by('title')
    )
</code></pre>

<p>There are yet more ways to resolve this problem.  For example we could try to use intermediary variables to avoid line wrapping entirely.</p>

<p>Chained methods pose a different problem for line wrapping than single method calls and require a different solution.  Focus on readability when picking a preferred solution and be consistent with the solution you pick.  <strong>Consistency lies at the heart of readability</strong>.</p>

<h3>Example: Dictionary Literals</h3>

<p>I often define long dictionaries and lists defined in Python code.</p>

<p>Here&rsquo;s a dictionary definition that has been over multiple lines, with line breaks inserted as a maximum line length is approached:</p>

<pre><code class="python">MONTHS = {'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5,
          'June': 6, 'July': 7, 'August': 8, 'September': 9, 'October': 10,
          'November': 11, 'December': 12}
</code></pre>

<p>Here&rsquo;s the same dictionary with each key-value pair on its own line, aligned with the first key-value pair:</p>

<pre><code class="python">MONTHS = {'January': 1,
          'February': 2,
          'March': 3,
          'April': 4,
          'May': 5,
          'June': 6,
          'July': 7,
          'August': 8,
          'September': 9,
          'October': 10,
          'November': 11,
          'December': 12}
</code></pre>

<p>And the same dictionary again, with each key-value pair indented instead of aligned (with a trailing comma on the last line as well):</p>

<pre><code class="python">MONTHS = {
    'January': 1,
    'February': 2,
    'March': 3,
    'April': 4,
    'May': 5,
    'June': 6,
    'July': 7,
    'August': 8,
    'September': 9,
    'October': 10,
    'November': 11,
    'December': 12,
}
</code></pre>

<p>This is the strategy I prefer for wrapping long dictionaries and lists.  I very often wrap short dictionaries and lists this way as well, for the sake of readability.</p>

<h2>Python is Poetry</h2>

<p>The moment of <strong>peak readability</strong> is <strong>the moment just after you write a line of code</strong>.  Your code will be far less readable to you one day, one week, and one month after you&rsquo;ve written it.</p>

<p>When crafting Python code, use spaces and line breaks to split up the logical components of each statement.  Don&rsquo;t write a statement on a single line unless it&rsquo;s already <em>very</em> clear.  If you break each line over multiple lines for clarity, lines length shouldn&rsquo;t be a major concern because your lines of code will mostly be far shorter than 79 characters already.</p>

<p>Make sure to craft your code carefully as you write it because your future self will have a much more difficult time cleaning it up than you will <strong>right now</strong>.  So take that line of code you just wrote and carefully add line breaks to it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Iterator Protocol: How "For Loops" Work in Python]]></title>
    <link href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/"/>
    <updated>2016-12-28T11:00:00-08:00</updated>
    <id>http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work</id>
    <content type="html"><![CDATA[<p>We&rsquo;re interviewing for a job and our interviewer has asked us to remove all <code>for</code> loops from a block of code.  They then mentioned something about iterators and cackled maniacally while rapping their fingers on the table.  We&rsquo;re nervous and frustrated about being assigned this ridiculous task, but we&rsquo;ll try our best.</p>

<p>To understand how to loop without a <code>for</code> loop, we&rsquo;ll need to discover what makes <code>for</code> loops tick.</p>

<p>We&rsquo;re about to learn how <code>for</code> loops work in Python.  Along the way we&rsquo;ll need to learn about iterables, iterators, and the iterator protocol.  Let&rsquo;s loop. </p>

<h2>Looping with indexes: a failed attempt</h2>

<p>We might initially try to remove our <code>for</code> loops by using a traditional looping idiom from the world of C: <a href="http://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/">looping with indexes</a>.</p>

<pre><code class="python">colors = ["red", "green", "blue", "purple"]
i = 0
while i &lt; len(colors):
    print(colors[i])
    i += 1
</code></pre>

<p>This works on lists, but it fails on sets:</p>

<pre><code class="pycon">&gt;&gt;&gt; colors = {"red", "green", "blue", "purple"}
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; len(colors):
...     print(colors[i])
...     i += 1
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
TypeError: 'set' object does not support indexing
</code></pre>

<p>This approach only works on <a href="https://docs.python.org/3/glossary.html#term-sequence">sequences</a>, which are data types that have indexes from <code>0</code> to one less than their length.  Lists, strings, and tuples are sequences.  Dictionaries, sets, and many other <em>iterables</em> are not <em>sequences</em>.</p>

<p>We&rsquo;ve been instructed to implement a looping construct that works on <em>all iterables</em>, not just sequences.</p>

<h2>Iterables: what are they?</h2>

<p>In the Python world, an <strong>iterable</strong> is any object that <strong>you can loop over with a for loop</strong>.</p>

<p><a href="https://docs.python.org/3/glossary.html#term-iterable">Iterables</a> are not always indexable, they don&rsquo;t always have lengths, and they&rsquo;re not always finite.</p>

<p>Here&rsquo;s an <em>infinite</em> iterable which provides every multiple of 5 as you loop over it:</p>

<pre><code class="python">from itertools import count
multiples_of_five = count(step=5)
</code></pre>

<p>When we were using <code>for</code> loops, we could have looped over the beginning of this iterable like this:</p>

<pre><code class="python">for n in multiples_of_five:
    if n &gt; 100:
        break
    print(n)
</code></pre>

<p>If we removed the <code>break</code> condition from that <code>for</code> loop, it would go on printing forever.</p>

<p>So iterables can be infinitely long: which means that we can&rsquo;t always convert an iterable to a <code>list</code> (or any other sequence) before we loop over it.  We need to somehow ask our iterable for each item of our iterable individually, the same way our <code>for</code> loop works.</p>

<h2>Iterables &amp; Iterators</h2>

<p>Okay we&rsquo;ve defined <em>iterable</em>, but how do iterables actually work in Python?</p>

<p>All <a href="https://docs.python.org/3/glossary.html#term-iterable">iterables</a> can be passed to the built-in <code>iter</code> function to get an <strong>iterator</strong> from them.</p>

<pre><code class="pycon">&gt;&gt;&gt; iter(['some', 'list'])
&lt;list_iterator object at 0x7f227ad51128&gt;
&gt;&gt;&gt; iter({'some', 'set'})
&lt;set_iterator object at 0x7f227ad32b40&gt;
&gt;&gt;&gt; iter('some string')
&lt;str_iterator object at 0x7f227ad51240&gt;
</code></pre>

<p>That&rsquo;s an interesting fact but&hellip; what&rsquo;s an <em>iterator</em>?</p>

<p>Iterators have exactly one job: return the &ldquo;next&rdquo; item in our iterable.  They&rsquo;re sort of like <a href="https://en.wikipedia.org/wiki/Tally_counter">tally counters</a>, but they don&rsquo;t have a reset button and instead of giving the next number they give the next item in our iterable.</p>

<p>You can get an iterator from <em>any</em> iterable:</p>

<pre><code class="pycon">&gt;&gt;&gt; iterator = iter('hi')
</code></pre>

<p>And iterators can be passed to <code>next</code> to get their next item:</p>

<pre><code class="pycon">&gt;&gt;&gt; next(iterator)
'h'
&gt;&gt;&gt; next(iterator)
'i'
&gt;&gt;&gt; next(iterator)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
</code></pre>

<p>So <a href="https://docs.python.org/3/glossary.html#term-iterator">iterators</a> can be passed to the built-in <code>next</code> function to get the next item from them and if there is no next item (because we reached the end), a <code>StopIteration</code> exception will be raised.</p>

<h2>Iterators are also iterables</h2>

<p>So calling <code>iter</code> on an <em>iterable</em> gives us an iterator.  And calling <code>next</code> on an <em>iterator</em> gives us the next item or raises a <code>StopIteration</code> exception if there aren&rsquo;t any more items.</p>

<p>There&rsquo;s actually a bit more to it than that though.  You can pass iterators to the built-in <code>iter</code> function to get themselves back.  That means that iterators are also iterables.</p>

<pre><code class="pycon">&gt;&gt;&gt; iterator = iter('hi')
&gt;&gt;&gt; iterator2 = iter(iterator)
&gt;&gt;&gt; iterator is iterator2
True
</code></pre>

<p>That fact leads to some interesting consequences that we don&rsquo;t have time to go into right now.  We&rsquo;ll save that discussion for a future learning adventure&hellip;</p>

<h2>The Iterator Protocol</h2>

<p>The <strong>iterator protocol</strong> is a fancy term meaning &ldquo;how iterables actually work in Python&rdquo;.</p>

<p>Let&rsquo;s redefine iterables from Python&rsquo;s perspective.</p>

<p>Iterables:</p>

<ol>
<li>Can be passed to the <code>iter</code> function to get an iterator for them.</li>
<li>There is no 2.  That&rsquo;s <em>really</em> all that&rsquo;s needed to be an iterable.</li>
</ol>


<p>Iterators:</p>

<ol>
<li>Can be passed to the <code>next</code> function which gives their next item or raises <code>StopIteration</code></li>
<li>Return themselves when passed to the <code>iter</code> function.</li>
</ol>


<p>The inverse of these statements should also hold true.  Which means:</p>

<ol>
<li>Anything that can be passed to <code>iter</code> without an error is an iterable.</li>
<li>Anything that can be passed to <code>next</code> without an error (except for <code>StopIteration</code>) is an iterator.</li>
<li>Anything that returns itself when passed to <code>iter</code> is an iterator.</li>
</ol>


<h2>Looping with iterators</h2>

<p>With what we&rsquo;ve learned about iterables and iterators, we should now be able to recreate a <code>for</code> loop without actually using a <code>for</code> loop.</p>

<p>This <code>while</code> loop manually loops over some <code>iterable</code>, printing out each item as it goes:</p>

<pre><code class="python">def print_each(iterable):
    iterator = iter(iterable)
    while True:
        try:
            item = next(iterator)
        except StopIteration:
            break  # Iterator exhausted: stop the loop
        else:
            print(item)
</code></pre>

<p>We can call this function with any iterable and it will loop over it:</p>

<pre><code class="pycon">&gt;&gt;&gt; print_each({1, 2, 3})
1
2
3
</code></pre>

<p>The above function is essentially the same as this one which uses a <code>for</code> loop:</p>

<pre><code class="python">def print_each(iterable):
    for item in iterable:
        print(item)
</code></pre>

<p>This <code>for</code> loop is automatically doing what we were doing manually: calling <code>iter</code> to get an iterator and then calling <code>next</code> over and over until a <code>StopIteration</code> exception is raised.</p>

<p>The iterator protocol is used by <code>for</code> loops, tuple unpacking, and all built-in functions that work on generic iterables.  Using the iterator protocol (either manually or automatically) is the only universal way to loop over any iterable in Python.</p>

<h2>For loops: more complex than they seem</h2>

<p>We&rsquo;re now ready to complete the very silly task our interviewer assigned to us.  We&rsquo;ll remove all <code>for</code> loops from our code by manually using <code>iter</code> and <code>next</code> to loop over iterables.  What did we learn in exploring this task?</p>

<p>Everything you can loop over is an <strong>iterable</strong>.  Looping over iterables works via getting an <strong>iterator</strong> from an iterable and then repeatedly asking the iterator for the next item.</p>

<p>The way iterators and iterables work is called the <strong>iterator protocol</strong>.  List comprehensions, tuple unpacking, <code>for</code> loops, and all other forms of iteration rely on the iterator protocol.</p>

<p>I&rsquo;ll explore iterators more in future articles.  For now know that iterators are hiding behind the scenes of all iteration in Python.</p>
]]></content>
  </entry>
  
</feed>
