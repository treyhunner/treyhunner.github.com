<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="http://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://treyhunner.com/"/>
  <updated>2019-03-13T10:50:17-07:00</updated>
  <id>http://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tuple ordering and deep comparisons in Python]]></title>
    <link href="http://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/"/>
    <updated>2019-03-13T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability</id>
    <content type="html"><![CDATA[<p>Comparing things in Python.
That sounds like something that almost doesn&rsquo;t even need to be taught.
But I&rsquo;ve found that <strong>Python&rsquo;s comparison operators are often misunderstood and under-appreciated by newer Pythonistas</strong>.</p>

<p>Let&rsquo;s review how Python&rsquo;s comparison operators work on different types of objects and then take a look at how we can use this to improve the readability of our code.</p>

<h2>Python&rsquo;s comparison operators</h2>

<p>By &ldquo;comparison operators&rdquo; I mean the equality operators (<code>==</code> and <code>!=</code>) and the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>).</p>

<p>We can use these operators to compare numbers, as you&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; 3 == 4
False
&gt;&gt;&gt; 3 != 4
True
&gt;&gt;&gt; 3 &lt; 4
True
&gt;&gt;&gt; 3 &gt; 4
False
</code></pre>

<p>But we can also use these operators to compare strings:</p>

<pre><code class="python">&gt;&gt;&gt; "pear" == "pickle"
False
&gt;&gt;&gt; "pear" != "pickle"
True
&gt;&gt;&gt; "pear" &lt; "pickle"
True
&gt;&gt;&gt; "pear" &gt; "pickle"
False
</code></pre>

<p>And even tuples:</p>

<pre><code class="python">&gt;&gt;&gt; target = (3, 6, 2)
&gt;&gt;&gt; installed = (3, 7, 0)
&gt;&gt;&gt; target == installed
False
&gt;&gt;&gt; target &lt;= installed
True
&gt;&gt;&gt; target &gt; installed
False
</code></pre>

<p>Many programming languages don&rsquo;t have an equivalent to Python&rsquo;s very flexible comparison operators.</p>

<p>We&rsquo;ll take a look at how these operators work on tuples and more complex objects in a moment, but we&rsquo;ll start with something simpler: string comparisons.</p>

<h2>String comparisons in Python</h2>

<p>Equality and inequality with strings is fairly simple.
If two strings have exactly the same characters, they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; "hello" == "hello"
True
&gt;&gt;&gt; "hello" == "hella"
False
</code></pre>

<p>Note that I&rsquo;m glossing over a very big exception: unicode characters.
There are often multiple ways to represent the same text and those different representations must be <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize">normalized</a> before they&rsquo;re seen as equal.
For simplicity, we&rsquo;re going to stick to ASCII characters in this article.</p>

<p>Ordering of strings is where things get a bit interesting in Python:</p>

<pre><code class="python">&gt;&gt;&gt; "pickle" &lt; "python"
True
</code></pre>

<p>The string <code>"pickle"</code> is <em>less than</em> the string <code>"python"</code> because we&rsquo;re ordering alphabetically&hellip; sort of.
Capitalization matters:</p>

<pre><code class="python">&gt;&gt;&gt; "pickle" &lt; "Python"
False
</code></pre>

<p>The string <code>"Python"</code> is less than <code>"pickle"</code> because <code>P</code> is less than <code>p</code>.</p>

<p>We&rsquo;re not actually ordering alphabetically here so much as <strong>ASCII-betically</strong> (unicode-betically really since we&rsquo;re in Python 3).
These strings are being ordered by the ASCII values of their characters (<code>p</code> is 112 in <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">ASCII</a> and <code>P</code> is 80).</p>

<pre><code class="python">&gt;&gt;&gt; ord("p")
112
&gt;&gt;&gt; ord("P")
80
&gt;&gt;&gt; "P" &lt; "p"
True
</code></pre>

<p>Technically Python compares the Unicode code point (which is what <a href="https://docs.python.org/3/library/functions.html#ord">ord</a> does) for these characters and that happens to be the same as the ASCII value for ASCII characters.</p>

<p>The rules for ordering strings are:</p>

<ol>
<li>Compare the n-th characters of each string (starting with the first character, index <code>0</code>) using the <code>==</code> operator; if they&rsquo;re equal, repeat this step with the next character</li>
<li>For two unequal characters, take the character that has the lower code point and declare its string &ldquo;less than&rdquo; the other</li>
<li>If all characters are equal, the strings are equal</li>
<li>If one string runs out of characters during step 1 (one string is a &ldquo;prefix&rdquo; of the other), the shorter string is &ldquo;less than&rdquo; the longer one</li>
</ol>


<p>The ordering algorithm Python uses for strings might seem complicated, but it&rsquo;s <strong>very similar to the ordering algorithm used in dictionaries</strong>; not Python dictionaries but <a href="https://en.wikipedia.org/wiki/Dictionary">physical dictionaries</a> (those things we used before the Internet existed).
We give precedence to the first characters when ordering words in dictionaries and if one word is a prefix of another, it comes first.</p>

<h2>Tuple comparisons</h2>

<p>We can ask tuples if they&rsquo;re equal, just as we can ask strings if they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; (3, 6, 2) == (3, 6, 2)
True
&gt;&gt;&gt; (3, 6, 2) == (3, 7, 0)
False
</code></pre>

<p>But we can also compare tuples using the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>):</p>

<pre><code class="python">&gt;&gt;&gt; (3, 6, 2) &lt; (3, 6, 2)
False
&gt;&gt;&gt; (3, 6, 2) &lt;= (3, 6, 2)
True
&gt;&gt;&gt; (3, 6, 2) &lt; (3, 7, 0)
True
&gt;&gt;&gt; (3, 6, 2) &gt;= (3, 7, 0)
False
</code></pre>

<p>String ordering might have been somewhat intuitive (most of us learned alphabetical ordering before Python), but tuple ordering doesn&rsquo;t often feel quite as intuitive at first.
But you&rsquo;re actually somewhat familiar with tuple ordering already because <strong>tuple ordering uses the same algorithm as string ordering</strong>.</p>

<p>The rules for ordering tuples (which are essentially the same as ordering strings):</p>

<ol>
<li>Compare the n-th items of each tuple (starting with the first, index <code>0</code>) using the <code>==</code> operator; if they&rsquo;re equal, repeat this step with the next item</li>
<li>For two unequal items, the item that is &ldquo;less than&rdquo; makes the tuple that contains it also &ldquo;less than&rdquo; the other tuple</li>
<li>If all items are equal, the tuples are equal</li>
<li>If one tuple runs out of items during step 1 (one tuple is a &ldquo;prefix&rdquo; of the other), the shorter tuple is &ldquo;less than&rdquo; the longer one</li>
</ol>


<p>In Python, this algorithm might look sort of like this:</p>

<pre><code class="python">def less_than(tuple1, tuple2):
    for x, y in zip(tuple1, tuple2):
        if x == y:
            continue
        return (x &lt; y)
    if len(tuple1) &lt; len(tuple2):
        return True  # There were more items in the second tuple
    else:
        return False  # The first tuple had more items or they are equal
</code></pre>

<p>Note that we&rsquo;d never write code like this because Python is doing all this work for us already.
That whole function is the same as using the <code>&lt;</code> operator:</p>

<pre><code class="python">def less_than(tuple1, tuple2):
    return tuple1 &lt; tuple2
</code></pre>

<h2>Lexicographical ordering</h2>

<p>This <strong>alphabetical-like style of ordering</strong> that gives precedence to the first items in an iterable is called <a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographical ordering</a>.
You don&rsquo;t need to know that phrase, but if you ever need to describe <em>the way ordering works in Python</em>, <strong>lexicographical</strong> is the word to use.</p>

<p>Strings and tuples are ordered lexicographically, as we&rsquo;ve seen, but so are lists:</p>

<pre><code class="python">&gt;&gt;&gt; [1, 2, 3] &lt; [1, 4]
True
&gt;&gt;&gt; [1, 2, 3] &lt; [1, 2, 2]
False
</code></pre>

<p>In fact, most <a href="https://docs.python.org/3/glossary.html#term-sequence">sequences</a> in Python <a href="https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types">should be ordered lexicographically</a> (<code>range</code> objects are an exception to this as they can&rsquo;t be ordered at all).</p>

<p>But not every collection in Python relies on lexicographical ordering.</p>

<h2>Dictionary and set comparisons</h2>

<p>Many objects in Python work with equality but don&rsquo;t work with ordering at all.</p>

<p>For example dictionaries compare &ldquo;equal&rdquo; when they have all the same keys and values:</p>

<pre><code class="python">&gt;&gt;&gt; expected = {'name': 'Trey', 'python_version': 3.7.0}
&gt;&gt;&gt; actual = {'name': 'Trey', 'python_version': 2.7.0}
&gt;&gt;&gt; expected == actual
False
&gt;&gt;&gt; actual['python_version'] = 3.7.0
&gt;&gt;&gt; expected == actual
True
</code></pre>

<p>But <strong>dictionaries can&rsquo;t be ordered</strong> using the <code>&lt;</code> or <code>&gt;</code> operators:</p>

<pre><code class="python">&gt;&gt;&gt; expected &lt; actual
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>

<p>Sets are similar, except that sets <em>do</em> work with ordering operators&hellip; they just don&rsquo;t use those operators for ordering:</p>

<pre><code class="python">&gt;&gt;&gt; {1, 2} &lt; {1, 2, 3}
True
&gt;&gt;&gt; {1, 3} &lt; {1, 2, 4}
False
</code></pre>

<p>Sets overload these operators to answer questions about <strong>whether one set is a subset or superset of another</strong> (<a href="https://docs.python.org/3.7/library/stdtypes.html#set-types-set-frozenset">see sets in the documentation</a>).</p>

<h2>Deep equality</h2>

<p>Comparisons between two data structures in Python tend to be <strong>deep comparisons</strong>.
Whether we&rsquo;re comparing lists, tuples, sets, or dictionaries, when we ask whether two of these objects are &ldquo;equal&rdquo; Python will recurse through each sub-object and ask whether each is &ldquo;equal&rdquo;.</p>

<p>So given a dictionary that maps tuples to lists of tuples:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2), (3, 4)]}
&gt;&gt;&gt; previous_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2)]}
</code></pre>

<p>Asking whether these two dictionaries are equal is equivalent to asking whether each key-value pair is equal, recursively:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals == previous_portals
False
&gt;&gt;&gt; current_portals[2, 1].pop()
(3, 4)
&gt;&gt;&gt; current_portals == previous_portals
True
</code></pre>

<p>The dictionaries ask each of their keys &ldquo;are you in the other dictionary&rdquo; and then asks each of the corresponding values for those keys &ldquo;are you equal to the other value&rdquo;.
But each of these operations may (as in this case) require another level of depth: the keys are tuples which need to be traversed and the values are lists which need to be traversed.
And in this case those values, the lists, need to be traversed even deeper because they contain more data structures: tuples.</p>

<p><strong>We don&rsquo;t have to worry about any of this though</strong>: Python just does these deep comparisons for us automatically.</p>

<p>While you don&rsquo;t need to worry about how deep comparisons work, the fact that Python&rsquo;s comparisons <em>are</em> deep can be pretty handy to know.</p>

<p>For example if we have <a href="https://pastebin.com/raw/yspKmfyj">a class</a> with <code>x</code>, <code>y</code>, and <code>z</code> attributes we&rsquo;d like to compare in our <code>__eq__</code> method, instead of this long boolean expression:</p>

<pre><code class="python">def __eq__(self, other):
    return self.x == other.x and self.y == other.y and self.z == other.z
</code></pre>

<p>We could bundle these values into 3-item tuples and compare them that way instead:</p>

<pre><code class="python">def __eq__(self, other):
    return (self.x, self.y, self.z) == (other.x, other.y, other.z)
</code></pre>

<p>I find this more readable, mostly because <strong>we&rsquo;ve added symmetry to our code</strong>: we have one <code>==</code> expression with the same kind of object on each side of it.</p>

<h2>Deep ordering</h2>

<p>This &ldquo;deep comparison&rdquo; works for equality, but it also works for ordering.</p>

<p>The use case for deep ordering isn&rsquo;t as obvious as for deep equality, but identifying places where deep ordering is handy can help you drastically improve the readability of your code.</p>

<p>Take this example method:</p>

<pre><code class="python">def __lt__(self, other):
    if self.last_name &lt; other.last_name:
        return True
    elif other.last_name &lt; self.last_name:
        return False
    elif self.first_name &lt; other.first_name:
        return True
    else:
        return False
</code></pre>

<p>This <code>__lt__</code> method implements the <code>&lt;</code> operator on <a href="https://pastebin.com/raw/u8uGDArq">its class</a>, returning <code>True</code> if <code>self</code> is less than <code>other</code>.
Storing and comparing <code>first_name</code> and <code>last_name</code> attributes this way is <a href="https://www.youtube.com/watch?v=458KmAKq0bQ&amp;feature=youtu.be&amp;t=148">an anti-pattern</a> but we&rsquo;ll to ignore that fact for this example.</p>

<p>That <code>__lt__</code> method above gives precedence to the <code>last_name</code>: the <code>first_name</code> is only checked if the <code>last_name</code> attribute of these two objects happens to be equal.</p>

<p>If we wanted to collapse this logic some, we could rewrite our code like this:</p>

<pre><code class="python">def __lt__(self, other):
    return (
        self.last_name &lt; other.last_name or
        self.last_name == other.last_name and self.first_name &lt; other.first_name
    )
</code></pre>

<p>Or&hellip; we could rely on the deep ordering of tuples instead:</p>

<pre><code class="python">def __lt__(self, other):
    return (self.last_name, self.first_name) &lt; (other.last_name, other.first_name)
</code></pre>

<p>Here we&rsquo;re ordering our tuples lexicographically (by their first item first).
Our tuples happen to contain strings, which are also ordered lexicographically (by their first character first).
So we&rsquo;re <strong>deeply ordering</strong> these objects.</p>

<h2>Sorting by multiple attributes at once</h2>

<p>Knowing about lexicographical ordering and deep ordering of Python sequences can be quite useful when sorting Python objects.
From Python&rsquo;s perspective, <strong>sorting is really just ordering over and over</strong>.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function accepts a <code>key</code> function which can return a corresponding key object to sort each of these items by.</p>

<p>Here we&rsquo;re specifying a <code>key</code> function that accepts a word and returns a tuple of two things: the length of the word and the case-normalized word:</p>

<pre><code class="python">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; def length_and_word(word): return (len(word), word.casefold())
...
&gt;&gt;&gt; sorted(fruits, key=length_and_word)
['jujube', 'longan', 'Loquat', 'kumquat', 'Cherimoya']
</code></pre>

<p>With the key function above we&rsquo;re able to sort fruits first by their length and <em>then</em> by their case-normalized equivalent.
So &ldquo;jujube&rdquo; comes first because it&rsquo;s 6 letters (like <code>longan</code> and <code>Loquat</code>) but it&rsquo;s also alphabetically before <code>longan</code> and <code>Loquat</code>.</p>

<p>If we just sorted by length we would have had a different ordering:</p>

<pre><code class="python">&gt;&gt;&gt; sorted(fruits, key=len)
['Loquat', 'longan', 'jujube', 'kumquat', 'Cherimoya']
</code></pre>

<p><strong>Slight aside</strong>: deep comparisons actually predate the <code>sorted</code> function&rsquo;s <code>key</code> argument in Python.
Before there was a key function Python developers would create lists of tuples, sort the lists of tuples, and then grab the actual value they cared about out of that list (which is <a href="https://docs.python.org/3/howto/sorting.html#the-old-way-using-decorate-sort-undecorate">discussed in the docs</a>).</p>

<p>The <code>sorted</code> function isn&rsquo;t the only place where tuple ordering can come in handy.
Any place where you see a <code>key</code> function might be a candidates for relying on tuple ordering.
For example the <code>min</code> and <code>max</code> functions:</p>

<pre><code>&gt;&gt;&gt; min(fruits, key=str.casefold)
'Cherimoya'
&gt;&gt;&gt; max(fruits, key=str.casefold)
'Loquat'
</code></pre>

<p>Anywhere Python does an ordering operation might be a place you could rely on the deep ordering of Python&rsquo;s data structures.</p>

<h2>Deep hashability (and unhashability)</h2>

<p>Python has both deep equality and deep orderability.
But Python&rsquo;s deep comparisons don&rsquo;t stop there: there&rsquo;s also deep hashability.</p>

<p>This is something that mostly comes up with tuples.
Tuples can be used as a key in a dictionary (as we saw earlier), and they can be used in sets:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2), (3, 4)]}
&gt;&gt;&gt; points = {(1, 2), (2, 1), (3, 4)}
</code></pre>

<p>But this only works for tuples that contain immutable values:</p>

<pre><code class="python">&gt;&gt;&gt; things = {(["dress", "truck"], "yellow"), (["ball", "plane"], "purple")}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>

<p>Tuples with lists in them aren&rsquo;t hashable because lists aren&rsquo;t hashable: each object inside a tuple must be hashable for the tuple itself to be hashable.</p>

<p>So while tuples containing lists aren&rsquo;t hashable, tuples containing tuples <em>are</em> hashable:</p>

<pre><code class="python">&gt;&gt;&gt; things = {(("dress", "truck"), "yellow"), (("ball", "plane"), "purple")}
&gt;&gt;&gt; things
{(('dress', 'truck'), 'yellow'), (('ball', 'plane'), 'purple')}
</code></pre>

<p>Tuples compute their hash values by delegating to the hash values of the items they contain:</p>

<pre><code class="python">&gt;&gt;&gt; x = (1, 2)
&gt;&gt;&gt; y = (1, 2)
&gt;&gt;&gt; hash(x)
3713081631934410656
&gt;&gt;&gt; hash(x) == hash(y)
True
</code></pre>

<p>While hashability is a big subject, this is really all I&rsquo;m going to say about it.
You don&rsquo;t really need to know how hashing works in Python so if you found this section confusing, that&rsquo;s okay!</p>

<p>The takeaway here is that Python supports <strong>deep hashability</strong> which is <strong>the reason we can use tuples as dictionary keys</strong> and the reason we can use tuples in sets.</p>

<h2>Deep comparisons are a tool to remember</h2>

<p>When you have code that compares two objects based on subparts in a particular order:</p>

<pre><code class="python">d1 = (1999, 12, 31)
d2 = (1999, 12, 1)
if d1[0] &gt; d2[0]:
    greater = d1
elif d1[0] &lt; d2[0]:
    greater = d2
elif d1[1] &gt; d2[1]:
    greater = d1
elif d2[1] &gt; d2[1]:
    greater = d2
elif d1[2] &gt; d2[2]:
    greater = d1
else:
    greater = d2
</code></pre>

<p>You could probably rely on tuple ordering instead:</p>

<pre><code class="python">d1 = (1999, 12, 31)
d2 = (1999, 12, 1)
if d1 &lt; d2:
    greater = d1
else:
    greater = d2
</code></pre>

<p>If you are comparing many different things as equal:</p>

<pre><code class="python">&gt;&gt;&gt; d1 = (1999, 12, 31)
&gt;&gt;&gt; d2 = (1999, 12, 1)
&gt;&gt;&gt; d1[0] == d2[0] and d1[1] == d2[1] and d1[2] == d2[2]
False
</code></pre>

<p>You could probably rely on deep equality instead:</p>

<pre><code class="python">&gt;&gt;&gt; d1 = (1999, 12, 31)
&gt;&gt;&gt; d2 = (1999, 12, 1)
&gt;&gt;&gt; d1 == d2
False
</code></pre>

<p>And if you need to use a dictionary that has a key made up of multiple parts, if those parts are each hashable, you could probably use a tuple:</p>

<pre><code class="python">&gt;&gt;&gt; points = {}
&gt;&gt;&gt; points[1, 2] = 'red'
&gt;&gt;&gt; points
{(1, 2): 'red'}
</code></pre>

<p><strong>Python&rsquo;s support for lexicographical ordering and deep comparisons is often overlooked by folks moving from other programming languages</strong>.
Remember these features: you may not need them today, but they&rsquo;ll almost certainly come in handy at some point.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[No really, pathlib is great]]></title>
    <link href="http://treyhunner.com/2019/01/no-really-pathlib-is-great/"/>
    <updated>2019-01-15T11:20:00-08:00</updated>
    <id>http://treyhunner.com/2019/01/no-really-pathlib-is-great</id>
    <content type="html"><![CDATA[<p>I recently <a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/">published an article about Python&rsquo;s pathlib module</a> and how I think everyone should be using it.</p>

<p>I won some <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> converts, but some folks also brought up concerns.
Some folks noted that I seemed to be comparing <code>pathlib</code> to <code>os.path</code> in a disingenuous way.
Some people were also concerned that <code>pathlib</code> will take a very long time to be widely adopted because <code>os.path</code> is so entrenched in the Python community.
And there were also concerns expressed about performance.</p>

<p>In this article I&rsquo;d like to acknowledge and address these concerns.
This will be both a defense of <code>pathlib</code> and a sort of love letter to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>.</p>

<h2>Comparing pathlib and os.path the right way</h2>

<p>In my last article I compared this code which uses <code>os</code> and <code>os.path</code>:</p>

<pre><code class="python">import os
import os.path

os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)
os.rename('.editorconfig', os.path.join('src', '.editorconfig'))
</code></pre>

<p>To this code with uses <code>pathlib.Path</code>:</p>

<pre><code class="python">from pathlib import Path

Path('src/__pypackages__').mkdir(parents=True, exist_ok=True)
Path('.editorconfig').rename('src/.editorconfig')
</code></pre>

<p>This might seem like an unfair comparison because I used <code>os.path.join</code> in the first example to ensure the correct path separator is used on all platforms but I didn&rsquo;t do that in the second example.
But this is in fact a fair comparison because <strong>the Path class normalizes path separators automatically</strong>.</p>

<p>We can prove this by looking at the string representation of this <code>Path</code> object on Windows:</p>

<pre><code class="pycon">&gt;&gt;&gt; str(Path('src/__pypackages__'))
'src\\__pypackages__'
</code></pre>

<p>No matter whether we use the <code>joinpath</code> method, a <code>/</code> in a path string, the <code>/</code> operator (which is a neat feature of <code>Path</code> objects), or separate arguments to the <code>Path</code> constructor, we get the same representation in all cases:</p>

<pre><code class="pycon">&gt;&gt;&gt; Path('src', '.editorconfig')
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src') / '.editorconfig'
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src').joinpath('.editorconfig')
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src/.editorconfig')
WindowsPath('src/.editorconfig')
</code></pre>

<p>That last expression caused some confusion from folks who assumed <code>pathlib</code> wouldn&rsquo;t be smart enough to convert that <code>/</code> into a <code>\</code> in the path string.
Fortunately, it is!</p>

<p>With <code>Path</code> objects, you never have to worry about backslashes vs forward slashes again: specify all paths using forward slashes and you&rsquo;ll get what you&rsquo;d expect on all platforms.</p>

<h2>Normalizing file paths shouldn&rsquo;t be your concern</h2>

<p>If you&rsquo;re developing on Linux or Mac, it&rsquo;s very easy to add bugs to your code that only affect Windows users.
Unless you&rsquo;re careful to use <code>os.path.join</code> to build your paths up or <code>os.path.normcase</code> to convert forward slashes to backslashes as appropriate, <strong>you may be writing code that breaks on Windows</strong>.</p>

<p>This is a Windows bug waiting to happen (we&rsquo;ll get mixed backslashes and forward slashes here):</p>

<pre><code class="python">import sys
import os.path
directory = '.' if not sys.argv[1:] else sys.argv[1]
new_file = os.path.join(directory, 'new_package/__init__.py')
</code></pre>

<p>This just works on all systems:</p>

<pre><code class="python">import sys
from pathlib import Path
directory = '.' if not sys.argv[1:] else sys.argv[1]
new_file = Path(directory, 'new_package/__init__.py')
</code></pre>

<p>It used to be the responsibility of you the Python programmer to carefully join and normalize your paths, just as it used to be your responsibility in Python 2 land to use unicode whenever it was more appropriate than bytes.
This is the case no more.
The <code>pathlib.Path</code> class is careful to fix path separator issues before they even occur.</p>

<p>I don&rsquo;t use Windows.
I don&rsquo;t own a Windows machine.
But a ton of the developers who use my code likely use Windows and I don&rsquo;t want my code to break on their machines.</p>

<p><strong>If there&rsquo;s a chance that your Python code will ever run on a Windows machine, you really need <code>pathlib</code></strong>.</p>

<p><strong>Don&rsquo;t stress about path normalization</strong>: just use <code>pathlib.Path</code> whenever you need to represent a file path.</p>

<h2>pathlib seems great, but I depend on code that doesn&rsquo;t use it!</h2>

<p>You have lots of code that works with path strings.
Why would you switch to using <code>pathlib</code> when it means you&rsquo;d need to rewrite all this code?</p>

<p>Let&rsquo;s say you have a function like this:</p>

<pre><code class="python">import os
import os.path

def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filename."""
    filename = os.path.join(dir_path, '.editorconfig')
    if not os.path.exists(filename):
        os.makedirs(dir_path, exist_ok=True)
        open(filename, mode='wt').write('')
    return filename
</code></pre>

<p>This function accepts a directory to create a <code>.editorconfig</code> file in, like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; make_editorconfig(os.path.join('src', 'my_package'))
'src/my_package/.editorconfig'
</code></pre>

<p>But our code also works with a <code>Path</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; make_editorconfig(Path('src/my_package'))
'src/my_package/.editorconfig'
</code></pre>

<p>But&hellip; how??</p>

<p>Well <code>os.path.join</code> accepts <code>Path</code> objects (as of Python 3.6).
And <code>os.makedirs</code> accepts <code>Path</code> objects too.</p>

<p>In fact the built-in <code>open</code> function accepts <code>Path</code> objects and <code>shutil</code> does and anything in the standard library that previously accepted a path string is now expected to work with both <code>Path</code> objects and path strings.</p>

<p>This is all thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, which called for an <code>os.PathLike</code> abstract base class and declared that Python utilities that work with file paths should now accept either path strings or path-like objects.</p>

<h2>But my favorite third-party library X has a better Path object!</h2>

<p>You might already be using a third-party library that has a <code>Path</code> object which works differently than pathlib&rsquo;s Path objects.
Maybe you even like it better.</p>

<p>For example <a href="https://github.com/joke2k/django-environ">django-environ</a>, <a href="https://github.com/jaraco/path.py">path.py</a>, <a href="https://github.com/tomerfiliba/plumbum">plumbum</a>, and <a href="https://github.com/saulpw/visidata">visidata</a> all have their own custom <code>Path</code> objects that represent file paths.
Some of these <code>pathlib</code> alternatives predate <code>pathlib</code> and chose to inherit from <code>str</code> so they could be passed to functions that expected path strings.
Thanks to PEP 519 both <code>pathlib</code> and its third-party alternatives can play nicely without needing to resort to the hack of inheriting from <code>str</code>.</p>

<p>Let&rsquo;s say you don&rsquo;t like <code>pathlib</code> because <code>Path</code> objects are immutable and you very much prefer using mutable <code>Path</code> objects.
Well thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, you can create your own even-better-because-it-is-mutable <code>Path</code> and also has a <code>__fspath__</code>.
You don&rsquo;t <em>need</em> to use <code>pathlib</code> to benefit from it.</p>

<p>Any homegrown <code>Path</code> object you make or find in a third party library now has the ability to work natively with the Python built-ins and standard library modules that expect Path objects.
<strong>Even if you don&rsquo;t like <code>pathlib</code>, its existence a big win for third-party <code>Path</code> objects as well</strong>.</p>

<h2>But Path objects and path strings don&rsquo;t mix, do they?</h2>

<p>You might be thinking: this is really wonderful, but won&rsquo;t this sometimes-a-string and sometimes-a-path-object situation add confusion to my code?</p>

<p>The answer is yes, somewhat.
But I&rsquo;ve found that it&rsquo;s pretty easy to work around.</p>

<p>PEP 519 added a couple other things along with path-like objects: one is a way to convert all path-like objects to path strings and the other is a way to convert all path-like objects to <code>Path</code> objects.</p>

<p>Given either a path string or a <code>Path</code> object (or anything with a <code>__fspath__</code> method):</p>

<pre><code class="python">from pathlib import Path
import os.path
p1 = os.path.join('src', 'my_package')
p2 = Path('src/my_package')
</code></pre>

<p>The <code>os.fspath</code> function will now normalize both of these types of paths to strings:</p>

<pre><code class="pycon">&gt;&gt;&gt; from os import fspath
&gt;&gt;&gt; fspath(p1), fspath(p2)
('src/my_package', 'src/my_package')
</code></pre>

<p>And the <code>Path</code> class will now accept both of these types of paths and convert them to <code>Path</code> objects:</p>

<pre><code class="pycon">&gt;&gt;&gt; Path(p1), Path(p2)
(PosixPath('src/my_package'), PosixPath('src/my_package'))
</code></pre>

<p>That means you could convert the output of the <code>make_editorconfig</code> function back into a <code>Path</code> object if you wanted to:</p>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; Path(make_editorconfig(Path('src/my_package')))
PosixPath('src/my_package/.editorconfig')
</code></pre>

<p>Though of course a better long-term approach would be to rewrite the <code>make_editorconfig</code> function to use <code>pathlib</code> instead.</p>

<h2>pathlib is too slow</h2>

<p>I&rsquo;ve heard this concern come up a few times: <code>pathlib</code> is just too slow.</p>

<p>It&rsquo;s true that <code>pathlib</code> can be slow.
Creating thousands of <code>Path</code> objects can make a noticeable impact on your code.</p>

<p>I decided to test the performance difference between <code>pathlib</code> and the alternative on my own machine using two different programs that both look for all <code>.py</code> files below the current directory.</p>

<p>Here&rsquo;s the <code>os.walk</code> version:</p>

<pre><code class="python">from os import getcwd, walk


extension = '.py'
count = 0
for root, directories, filenames in walk(getcwd()):
    for filename in filenames:
        if filename.endswith(extension):
            count += 1
print(f"{count} Python files found")
</code></pre>

<p>Here&rsquo;s the <code>Path.rglob</code> version:</p>

<pre><code class="python">from pathlib import Path


extension = '.py'
count = 0
for filename in Path.cwd().rglob(f'*{extension}'):
    count += 1
print(f"{count} Python files found")
</code></pre>

<p>Testing runtimes for programs that rely on filesystem accesses is tricky because runtimes vary greatly, so I reran each script 10 times and compared the best runtime of each.</p>

<p>Both scripts found 97,507 Python files in the directory I ran them in.
The first one finished in 1.914 seconds (best out of 10 runs).
The second one finished in 3.430 seconds (best out of 10 runs).</p>

<p>When I set <code>extension = ''</code> these find about 600,000 files and the differences spread a little further apart.
The first runs in 1.888 seconds and the second in 7.485 seconds.</p>

<p>So the <code>pathlib</code> version of this program <strong>ran twice as slow</strong> for <code>.py</code> files and <strong>four times as slow</strong> for every file in my home directory.
<strong>The <code>pathlib</code> code was indeed slower</strong>, much slower percentage-wise.</p>

<p>But in my case, this speed difference doesn&rsquo;t matter much.
I searched for every file in my home directory and lost 6 seconds to the slower version of my code.
If I needed to scale this code to search 10 million files, I&rsquo;d probably want to rewrite it.
But that&rsquo;s a problem I can get to if I experience it.</p>

<p>If you have a tight loop that could use some optimizing and <code>pathlib.Path</code> is one of the bottlenecks that&rsquo;s slowing that loop down, abandon <code>pathlib</code> in that part of your code.
But <strong>don&rsquo;t optimize parts of your code that aren&rsquo;t bottlenecks</strong>: it&rsquo;s a waste of time and often results in less readable code for little gain.</p>

<h2>Improving readability with pathlib</h2>

<p>I&rsquo;d like to wrap up these thoughts by ending with some <code>pathlib</code> refactorings.
I&rsquo;ve taken a couple small examples of code that work with files and refactored these examples to use <code>pathlib</code> instead.
I&rsquo;ll mostly leave these code blocks without comment and let you be the judge of which versions you like best.</p>

<p>Here&rsquo;s the <code>make_editorconfig</code> function we saw earlier:</p>

<pre><code class="python">import os
import os.path


def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filename."""
    filename = os.path.join(dir_path, '.editorconfig')
    if not os.path.exists(filename):
        os.makedirs(dir_path, exist_ok=True)
        open(filename, mode='wt').write('')
    return filename
</code></pre>

<p>And here&rsquo;s the same function using <code>pathlib.Path</code> instead:</p>

<pre><code class="python">from pathlib import Path


def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filepath."""
    path = Path(dir_path, '.editorconfig')
    if not path.exists():
        path.parent.mkdir(exist_ok=True, parent=True)
        path.touch()
    return path
</code></pre>

<p>Here&rsquo;s a command-line program that accepts a string representing a directory and prints the contents of the <code>.gitignore</code> file in that directory if one exists:</p>

<pre><code class="python">import os.path
import sys


directory = sys.argv[1]
ignore_filename = os.path.join(directory, '.gitignore')
if os.path.isfile(ignore_filename):
    with open(ignore_filename, mode='rt') as ignore_file:
        print(ignore_file.read(), end='')
</code></pre>

<p>This is the same code using <code>pathlib.Path</code>:</p>

<pre><code class="python">from pathlib import Path
import sys


directory = Path(sys.argv[1])
ignore_path = directory / '.gitignore'
if ignore_path.is_file():
    print(ignore_path.read_text(), end='')
</code></pre>

<p>And here&rsquo;s some code that prints all groups of files in and below the current directory which are duplicates:</p>

<pre><code class="python">from collections import defaultdict
from hashlib import md5
from os import getcwd, walk
import os.path


def find_files(filepath):
    for root, directories, filenames in walk(filepath):
        for filename in filenames:
            yield os.path.join(root, filename)


file_hashes = defaultdict(list)
for path in find_files(getcwd()):
    with open(path, mode='rb') as my_file:
        file_hash = md5(my_file.read()).hexdigest()
        file_hashes[file_hash].append(path)

for paths in file_hashes.values():
    if len(paths) &gt; 1:
        print("Duplicate files found:")
        print(*paths, sep='\n')
</code></pre>

<p>This is the same code that uses <code>pathlib.Path</code> instead:</p>

<pre><code class="python">from collections import defaultdict
from hashlib import md5
from pathlib import Path


def find_files(filepath):
    for path in Path(filepath).rglob('*'):
        if path.is_file():
            yield path


file_hashes = defaultdict(list)
for path in find_files(Path.cwd()):
    file_hash = md5(path.read_bytes()).hexdigest()
    file_hashes[file_hash].append(path)

for paths in file_hashes.values():
    if len(paths) &gt; 1:
        print("Duplicate files found:")
        print(*paths, sep='\n')
</code></pre>

<p>The changes here are subtle, but I think they add up.
I prefer this <code>pathlib</code>-refactored version.</p>

<h2>Start using pathlib.Path objects</h2>

<p>Let&rsquo;s recap.</p>

<p>The <code>/</code> separators in <code>pathlib.Path</code> strings are automatically converted to the correct path separator based on the operating system you&rsquo;re on.
This is a huge feature that can make for code that is <strong>more readable and more certain to be free of path-related bugs</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; path1 = Path('dir', 'file')
&gt;&gt;&gt; path2 = Path('dir') / 'file'
&gt;&gt;&gt; path3 = Path('dir/file')
&gt;&gt;&gt; path3
WindowsPath('dir/file')
&gt;&gt;&gt; path1 == path2 == path3
True
</code></pre>

<p>The Python standard library and built-ins (like <code>open</code>) also accept <code>pathlib.Path</code> objects now.
This means <strong>you can start using pathlib, even if your dependencies don&rsquo;t</strong>!</p>

<pre><code class="python">from shutil import move

def rename_and_redirect(old_filename, new_filename):
    move(old, new)
    with open(old, mode='wt') as f:
        f.write(f'This file has moved to {new}')
</code></pre>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; old, new = Path('old.txt'), Path('new.txt')
&gt;&gt;&gt; rename_and_redirect(old, new)
&gt;&gt;&gt; old.read_text()
'This file has moved to new.txt'
</code></pre>

<p>And if you don&rsquo;t like <code>pathlib</code>, you can use a third-party library that provides the same path-like interface.
This is great because <strong>even if you&rsquo;re not a fan of <code>pathlib</code> you&rsquo;ll still benefit from the new changes detailed in PEP 519</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; from plumbum import Path
&gt;&gt;&gt; my_path = Path('old.txt')
&gt;&gt;&gt; with open(my_path) as f:
...     print(f.read())
...
This file has moved to new.txt
</code></pre>

<p>While <code>pathlib</code> is sometimes slower than the alternative(s), the cases where this matters are somewhat rare (in my experience at least) and <strong>you can always jump back to using path strings for parts of your code that are particularly performance sensitive</strong>.</p>

<p>And in general, <code>pathlib</code> makes for more readable code.
Here&rsquo;s a succinct and descriptive Python script to demonstrate my point:</p>

<pre><code class="python">from pathlib import Path
gitignore = Path('.gitignore')
if gitignore.is_file():
    print(gitignore.read_text(), end='')
</code></pre>

<p>The <code>pathlib</code> module is lovely: start using it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why you should be using pathlib]]></title>
    <link href="http://treyhunner.com/2018/12/why-you-should-be-using-pathlib/"/>
    <updated>2018-12-21T14:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/12/why-you-should-be-using-pathlib</id>
    <content type="html"><![CDATA[<p>When I discovered Python&rsquo;s new <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> module a few years ago, I initially wrote it off as being a slightly more awkward and unnecessarily object-oriented version of the <code>os.path</code> module.
I was wrong.
Python&rsquo;s <code>pathlib</code> module is actually <a href="https://jefftriplett.com/2017/pathlib-is-wonderful/">wonderful</a>!</p>

<p>In this article I&rsquo;m going to try to sell you on <code>pathlib</code>.
I hope that this article will inspire you to <strong>use Python&rsquo;s <code>pathlib</code> module pretty much anytime you need to work with files in Python</strong>.</p>

<p><strong>Update</strong>: I wrote a follow-up article to address further comments and concerns that were raised after this one.  Read this article first and then take a look at <a href="https://treyhunner.com/2019/01/no-really-pathlib-is-great/">the follow-up article here</a>.</p>

<h2>os.path is clunky</h2>

<p>The <code>os.path</code> module has always been what we reached for to work with paths in Python.
It&rsquo;s got pretty much all you need, but it can be very clunky sometimes.</p>

<p>Should you import it like this?</p>

<pre><code class="python">import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')
</code></pre>

<p>Or like this?</p>

<pre><code class="python">from os.path import abspath, dirname, join

BASE_DIR = dirname(dirname(abspath(__file__)))
TEMPLATES_DIR = join(BASE_DIR, 'templates')
</code></pre>

<p>Or maybe that <code>join</code> function is too generically named&hellip; so we could do this instead:</p>

<pre><code class="python">from os.path import abspath, dirname, join as joinpath

BASE_DIR = dirname(dirname(abspath(__file__)))
TEMPLATES_DIR = joinpath(BASE_DIR, 'templates')
</code></pre>

<p>I find all of these a bit awkward.
We&rsquo;re passing strings into functions that return strings which we then pass into other functions that return strings.
All of these strings happen to represent paths, but they&rsquo;re still just strings.</p>

<p>The string-in-string-out functions in <code>os.path</code> are really awkward when nested because the code has to be read from the inside out.
Wouldn&rsquo;t it be nice if we could take these nested function calls and turn them into chained method calls instead?</p>

<p>With the <code>pathlib</code> module we can!</p>

<pre><code class="python">from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR.joinpath('templates')
</code></pre>

<p>The <code>os.path</code> module requires function nesting, but <strong>the <code>pathlib</code> modules&#8217; <code>Path</code> class allows us to chain methods and attributes</strong> on <code>Path</code> objects to get an equivalent path representation.</p>

<p>I know what you&rsquo;re thinking: wait these <code>Path</code> objects aren&rsquo;t the same thing: they&rsquo;re objects, not path strings!
I&rsquo;ll address that later (hint: these can pretty much be used interchangeably with path strings).</p>

<h2>The os module is crowded</h2>

<p>Python&rsquo;s classic <code>os.path</code> module is just for working with paths.
Once you want to actually <em>do</em> something with a path (e.g. create a directory) you&rsquo;ll need to reach for another Python module, often the <code>os</code> module.</p>

<p>The <code>os</code> module has lots of utilities for working with files and directories: <code>mkdir</code>, <code>getcwd</code>, <code>chmod</code>, <code>stat</code>, <code>remove</code>, <code>rename</code>, and <code>rmdir</code>.
Also <code>chdir</code>, <code>link</code>, <code>walk</code>, <code>listdir</code>, <code>makedirs</code>, <code>renames</code>, <code>removedirs</code>, <code>unlink</code> (same as <code>remove</code>), and <code>symlink</code>.
And a bunch of other stuff that isn&rsquo;t related to the filesystems at all: <code>fork</code>, <code>getenv</code>, <code>putenv</code>, <code>environ</code>, <code>getlogin</code>, and <code>system</code>.
Plus dozens of things I didn&rsquo;t mention in this paragraph.</p>

<p><strong>Python&rsquo;s <code>os</code> module does a little bit of everything; it&rsquo;s sort of a junk drawer for system-related stuff</strong>.
There&rsquo;s a lot of lovely stuff in the <code>os</code> module, but it can be hard to find what you&rsquo;re looking for sometimes:
if you&rsquo;re looking for path-related or filesystem-related things in the <code>os</code> module, you&rsquo;ll need to do a bit of digging.</p>

<p>The <code>pathlib</code> module replaces many of these filesystem-related <code>os</code> utilities with methods on the <code>Path</code> object.</p>

<p>Here&rsquo;s some code that makes a <code>src/__pypackages__</code> directory and renames our <code>.editorconfig</code> file to <code>src/.editorconfig</code>:</p>

<pre><code class="python">import os
import os.path

os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)
os.rename('.editorconfig', os.path.join('src', '.editorconfig'))
</code></pre>

<p>This code does the same thing using <code>Path</code> objects:</p>

<pre><code class="python">from pathlib import Path

Path('src/__pypackages__').mkdir(parents=True, exist_ok=True)
Path('.editorconfig').rename('src/.editorconfig')
</code></pre>

<p>Notice that the <code>pathlib</code> code puts the path first because of method chaining!</p>

<p>As the Zen of Python says, &ldquo;namespaces are one honking great idea, let&rsquo;s do more of those&rdquo;.
The <code>os</code> module is a very large namespace with a bunch of stuff in it.
<strong>The pathlib.Path class is a much smaller and more specific namespace than the os module</strong>.
Plus the methods in this <code>Path</code> namespace return <code>Path</code> objects, which allows for method chaining instead of nested string-iful function calls.</p>

<h2>Don&rsquo;t forget about the glob module!</h2>

<p>The <code>os</code> and <code>os.path</code> modules aren&rsquo;t the only filepath/filesystem-related utilities in the Python standard library.
The <code>glob</code> module is another handy path-related module.</p>

<p>We can use the <code>glob.glob</code> function for finding files that match a certain pattern:</p>

<pre><code class="python">from glob import glob

top_level_csv_files = glob('*.csv')
all_csv_files = glob('**/*.csv', recursive=True)
</code></pre>

<p>The new <code>pathlib</code> module includes glob-like utilities as well.</p>

<pre><code class="python">from pathlib import Path

top_level_csv_files = Path.cwd().glob('*.csv')
all_csv_files = Path.cwd().rglob('*.csv')
</code></pre>

<p>After you&rsquo;ve started using <code>pathlib</code> more heavily, <strong>you can pretty much forget about the glob module entirely</strong>: you&rsquo;ve got all the glob functionality you need with <code>Path</code> objects.</p>

<h2>pathlib makes the simple cases simpler</h2>

<p>The <code>pathlib</code> module makes a number of complex cases somewhat simpler, but <strong>it also makes some of the simple cases even simpler</strong>.</p>

<p>Need to read all the text in one or more files?</p>

<p>You could open the file, read its contents and close the file using a <code>with</code> block:</p>

<pre><code class="python">from glob import glob

file_contents = []
for filename in glob('**/*.py', recursive=True):
    with open(filename) as python_file:
        file_contents.append(python_file.read())
</code></pre>

<p>Or you could use the <code>read_text</code> method on <code>Path</code> objects and a list comprehension to read the file contents into a new list all in one line:</p>

<pre><code class="python">from pathlib import Path

file_contents = [
    path.read_text()
    for path in Path.cwd().rglob('*.py')
]
</code></pre>

<p>What if you need to write to a file?</p>

<p>You could use the <code>open</code> context manager again:</p>

<pre><code class="python">with open('.editorconfig') as config:
    config.write('# config goes here')
</code></pre>

<p>Or you could use the <code>write_text</code> method:</p>

<pre><code class="python">Path('.editorconfig').write_text('# config goes here')
</code></pre>

<p>If you prefer using <code>open</code>, whether as a context manager or otherwise, you could instead use the <code>open</code> method on your <code>Path</code> object:</p>

<pre><code class="python">from pathlib import Path

path = Path('.editorconfig')
with path.open(mode='wt') as config:
    config.write('# config goes here')
</code></pre>

<p>Or, as of Python 3.6, you can even pass your <code>Path</code> object to the built-in <code>open</code> function:</p>

<pre><code class="python">from pathlib import Path

path = Path('.editorconfig')
with open(path, mode='wt') as config:
    config.write('# config goes here')
</code></pre>

<h2>Path objects make your code more explicit</h2>

<p>What do the following 3 variables point to?
What do their values represent?</p>

<pre><code class="python">person = '{"name": "Trey Hunner", "location": "San Diego"}'
pycon_2019 = "2019-05-01"
home_directory = '/home/trey'
</code></pre>

<p>Each of those variables points to a string.</p>

<p>Those strings represent different things: one is a JSON blob, one is a date, and one is a file path.</p>

<p>These are a little bit more useful representations for these objects:</p>

<pre><code class="python">from datetime import date
from pathlib import Path

person = {"name": "Trey Hunner", "location": "San Diego"}
pycon_2019 = date(2019, 5, 1)
home_directory = Path('/home/trey')
</code></pre>

<p>JSON objects deserialize to dictionaries, dates are represented natively using <code>datetime.date</code> objects, and <strong>filesystem paths can now be generically represented using <code>pathlib.Path</code> objects</strong>.</p>

<p>Using <code>Path</code> objects makes your code more explicit.
If you&rsquo;re trying to represent a date, you can use a <code>date</code> object.
If you&rsquo;re trying to represent a filepath, you can use a <code>Path</code> object.</p>

<p>I&rsquo;m not a strong advocate of object-oriented programming.
Classes add another layer of abstraction and abstractions can sometimes add more complexity than simplicity.
But the <code>pathlib.Path</code> class is <strong>a useful abstraction</strong>.
It&rsquo;s also quickly becoming a universally recognized abstraction.</p>

<p>Thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, file path objects are now becoming the standard for working with paths.
As of Python 3.6, the built-in <code>open</code> function and the various functions in the <code>os</code>, <code>shutil</code>, and <code>os.path</code> modules all work properly with <code>pathlib.Path</code> objects.
<strong>You can start using pathlib today without changing most of your code that works with paths</strong>!</p>

<h2>What&rsquo;s missing from pathlib?</h2>

<p>While <code>pathlib</code> is great, it&rsquo;s not all-encompassing.
There are definitely <strong>a few missing features I&rsquo;ve stumbled upon that I wish the <code>pathlib</code> module included</strong>.</p>

<p>The first gap I&rsquo;ve noticed is the lack of <code>shutil</code> equivalents within the <code>pathlib.Path</code> methods.</p>

<p>While you can pass <code>Path</code> objects (and path-like objects) to the higher-level <code>shutil</code> functions for copying/deleting/moving files and directories, there&rsquo;s no equivalent to these functions on <code>Path</code> objects.</p>

<p>So to copy a file you still have to do something like this:</p>

<pre><code class="python">from pathlib import Path
from shutil import copyfile

source = Path('old_file.txt')
destination = Path('new_file.txt')
copyfile(source, destination)
</code></pre>

<p>There&rsquo;s also no <code>pathlib</code> equivalent of <code>os.chdir</code>.</p>

<p>This just means you&rsquo;ll need to import <code>chdir</code> if you ever need to change the current working directory:</p>

<pre><code class="python">from pathlib import Path
from os import chdir

parent = Path('..')
chdir(parent)
</code></pre>

<p>The <code>os.walk</code> function has no <code>pathlib</code> equivalent either.
Though you can make your own <code>walk</code>-like functions using <code>pathlib</code> fairly easily.</p>

<p>My hope is that <code>pathlib.Path</code> objects might eventually include methods for some of these missing operations.
But even with these missing features, <strong>I still find it much more manageable to use &ldquo;<code>pathlib</code> and friends&rdquo; than &ldquo;<code>os.path</code> and friends&rdquo;</strong>.</p>

<h2>Should you always use pathlib?</h2>

<p>Since Python 3.6, <strong>pathlib.Path objects work nearly everywhere you&rsquo;re already using path strings</strong>.
So I see no reason <em>not</em> to use <code>pathlib</code> if you&rsquo;re on Python 3.6 (or higher).</p>

<p>If you&rsquo;re on an earlier version of Python 3, you can always wrap your <code>Path</code> object in a <code>str</code> call to get a string out of it when you need an escape hatch back to string land.
It&rsquo;s awkward but it works:</p>

<pre><code class="python">from os import chdir
from pathlib import Path

chdir(Path('/home/trey'))  # Works on Python 3.6+
chdir(str(Path('/home/trey')))  # Works on earlier versions also
</code></pre>

<p>Regardless of which version of Python 3 you&rsquo;re on, I would recommend giving <code>pathlib</code> a try.</p>

<p>And if you&rsquo;re stuck on Python 2 still (the clock is ticking!) the third-party <a href="https://github.com/mcmtroffaes/pathlib2">pathlib2</a> module on PyPI is a backport so you can use <code>pathlib</code> on any version of Python.</p>

<p>I find that using <code>pathlib</code> often makes my code more readable.
Most of my code that works with files now defaults to using <code>pathlib</code> and I recommend that you do the same.
<strong>If you can use <code>pathlib</code>, you should</strong>.</p>

<p>If you&rsquo;d like to continue reading about pathlib, check out my follow-up article called <a href="https://treyhunner.com/2019/01/no-really-pathlib-is-great/">No really, pathlib is great</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Cyber Monday Sales]]></title>
    <link href="http://treyhunner.com/2018/11/python-cyber-monday-sales/"/>
    <updated>2018-11-26T07:45:00-08:00</updated>
    <id>http://treyhunner.com/2018/11/python-cyber-monday-sales</id>
    <content type="html"><![CDATA[<p>I&rsquo;m running <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">a sale</a> that ends in 24 hours, but I&rsquo;m not the only one.
This post is a compilation of the different Cyber Monday deals I&rsquo;ve found related to Python and Python learning.</p>

<h3>Python Morsels weekly skill-building</h3>

<p>This is my weekly Python skill-building service.</p>

<p>I&rsquo;m offering 52 weeks of <a href="https://www.pythonmorsels.com/">Python Morsels</a> for 50% off.</p>

<p>You can find <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">more details on this sale here</a>.</p>

<h3>Talk Python Course Bundle</h3>

<p>Michael Kennedy of <a href="https://training.talkpython.fm/courses/bundle/black-friday-2018">Talk Python</a> is offering a 4 course bundle for a number of Python courses.</p>

<h3>Reuven Lerner&rsquo;s Python courses</h3>

<p>Reuven Lerner is also offering a <a href="http://blog.lerner.co.il/last-chance-to-save-40-on-python-and-git-courses/">40% off sale on his courses</a>.
Reuven has courses on Python, Git, and regular expressions.</p>

<h3>PyBites Code Challenges</h3>

<p>Bob and Julian of PyBites are offering a 50% off sale on their <a href="https://gumroad.com/l/ZFrD/black-friday">Code Challenges</a>.
These are a different variety of code challenges than Python Morsels.
You could sign up for both and <a href="https://www.pythonmorsels.com/">Python Morsels</a> if you wanted extra learning every week.</p>

<h3>Hello Web Books</h3>

<p>Tracy Osborn is running a 50% off sale on her <a href="https://hellowebbooks.com/order/">Hello Web Books</a>, which include books on Python and Django for beginners to web programming and books on design for beginners to web design.
You&rsquo;ll need to enter coupon code BLACKFRIDAY2018 to get these deals.</p>

<h3>The pytest book</h3>

<p>Brian Okken&rsquo;s <a href="https://pragprog.com/book/bopytest/python-testing-with-pytest">Python Testing with pytest</a> is on sale today (along with other Pragmatic Bookshelf books) for 40% off with coupon code turkeysale2018.</p>

<h3>More Python Books</h3>

<p>A number of Python book publishers, such as <a href="https://nostarch.com/catalog/python">No Starch</a>, are running big sales on their books.
I took a look at their sale, but haven&rsquo;t gone searching for more of them.</p>

<h3>Other Cyber Monday deals?</h3>

<p>If you have questions about the <a href="https://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/">Python Morsels sale</a>, <a href="mailto:tr%65y%40&amp;#116;%72%75&amp;#116;%68%66u&amp;#108;&amp;#46;&amp;#116;&amp;#101;c%68&amp;#110;%6flo%67%79">email me</a>.</p>

<p>The Python Morsels sale and likely all the other sales above will end in the next 24 hours, probably sooner depending on when you&rsquo;re reading this.</p>

<p>So go check them out!</p>

<p>Did I miss a deal that you know about?
Link to it in the comments!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Black Friday Sale: 50% Off 52 weeks of Python Morsels]]></title>
    <link href="http://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python/"/>
    <updated>2018-11-21T11:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/11/python-morsels-sale-52-weeks-of-python</id>
    <content type="html"><![CDATA[<p>I launched a weekly Python skill-building service earlier this year called <a href="https://www.pythonmorsels.com/">Python Morsels</a>.
This week I&rsquo;m running my first sale, which will also likely be the biggest sale that I run on Python Morsels for the foreseeable future (I don&rsquo;t want to say forever, but probably forever).</p>

<p>If you&rsquo;re an experienced programmer and you feel like your Python code could be <em>more Pythonic</em>, <a href="https://www.pythonmorsels.com/">Python Morsels</a> is for you.</p>

<p>Before I jump into details, let me explain what Python Morsels is.</p>

<h2>The inspiration</h2>

<p>I do on-site Python training for teams, which means I work with a lot of developers at a lot of companies.
One question I hear all the time is &ldquo;how can I make my code more Pythonic&rdquo;?</p>

<p>Most of the folks I teach are not new to programming and they&rsquo;re usually not new to Python either, but they also aren&rsquo;t experienced at leveraging the features and idioms that make Python unique.
Being a skilled programmer isn&rsquo;t the same as being a skilled <em>Python</em> programmer</p>

<p>Late last year this conundrum inspired me to create <a href="https://www.pythonmorsels.com/">Python Morsels</a>.</p>

<h2>Learning by doing</h2>

<p>My training courses and workshops are exercise-driven and I find an exercise-heavy style of teaching very effective.</p>

<p>You don&rsquo;t learn by putting information into your head, <strong>you learn by trying to retrieve information from your head</strong>.
You can watch talks and read books and read code, but you&rsquo;ll absorb very little unless you <em>apply</em> what you&rsquo;ve learned.
You learn by doing, which means writing Python code.</p>

<p>That&rsquo;s why Python Morsels is entirely about writing code and reflecting on the code you&rsquo;ve written.</p>

<h2>Python Morsels: exercise-driven learning</h2>

<p>After you sign up for Python Morsels I&rsquo;ll send you <strong>one exercise every week</strong>.
Not an interview questions: a realistic Python exercise inspired by the interesting problems I&rsquo;ve had to solve in the past. The purpose of these exercises is to <strong>inspire you to learn something new about Python each week</strong>.</p>

<p>Each exercise includes a number of bonuses so you can <strong>choose your own difficulty level</strong>.
All exercises also include automated tests so you can test your code quickly.
After you&rsquo;ve solved the exercise I&rsquo;ll send you a number of different solutions to the problem with a discussion about why we might choose one solution over another.
These solutions are meant to help you <strong>reconsider the way you write your code</strong>.</p>

<p>While solving the bonuses is important, the more important thing is that you <strong>get into the habit of time-boxed weekly learning</strong>. You want to spend your time effectively and the best way to do that is to <strong>form a learning habit</strong> and time box that habit.
I suggest that you dedicate 30 minutes every week to solving the exercise, regardless of the difficulty level you choose, as well as 30 minutes to reflecting on the solutions email I send you.</p>

<h2>So how much is this sale for?</h2>

<p>Python Morsels normally costs $16/month (or $160/year on the annual plan).</p>

<p>From now until Monday I&rsquo;m offering a 40% discount off the annual plan, which means you&rsquo;ll get <strong>52 weeks of Python skill-building for $96</strong>.
That&rsquo;s effectively $8/month or <strong>a 50% discount</strong> when compared to the monthly subscription.</p>

<p>I say &ldquo;52 weeks&rdquo; instead of 1 year because Python Morsels subscriptions can be &ldquo;paused&rdquo; at any time, which allows for breaks during vacations and busy periods and ensures you&rsquo;ll get all of the 52 weeks you signed up for.</p>

<p>To take advantage of this discount you&rsquo;ll need to sign up for <a href="https://www.pythonmorsels.com/">Python Morsels</a>, verify your email address, go to the Account page, and click the Subscribe button for the <strong>52 Week Plan</strong>.
The BLACKFRIDAY discount code should be automatically applied from now until the end of the sale on Monday.</p>

<h2>Money back guarantee</h2>

<p>This is the first sale I&rsquo;ve ever held so I&rsquo;m not sure whether it&rsquo;s common to offer a guarantee on sales, but I&rsquo;m going to do it for this one because I&rsquo;m pretty confident in what I&rsquo;m offering.</p>

<p>If you contact me with concerns but I can&rsquo;t find something that works for your needs, I&rsquo;ll send you a full refund.
I want you to improve your Python skills, but I don&rsquo;t want you signing up for something that isn&rsquo;t for you.
If you end up signing up for Python Morsels and you don&rsquo;t improve your Python skills because of it, <strong>you deserve a refund because I&rsquo;ve wasted your time</strong>.</p>

<h2>What do the first 52 weeks of Python Morsels exercises cover?</h2>

<p>Python Morsels starts small, but the exercises increase in difficulty over time.
The first 52 weeks of Python exercises will wander into <strong>a lot of interesting topics</strong>.</p>

<p>Within one year we&rsquo;ll:</p>

<ul>
<li>work with and create our own iterators (both generators and iterator classes)</li>
<li>make text-parsing programs and command-line programs</li>
<li>talk a lot about readability and code style</li>
<li>dive into a number of the built-ins and standard library modules</li>
<li>use operator overloading to make classes that support arithmetic</li>
<li>create our context managers</li>
<li>create our own decorators</li>
<li>use properties and descriptors and even <strong>make our own descriptor</strong></li>
<li>create custom collections (mappings, sequences, strings, sets, etc.)</li>
</ul>


<p>Haven&rsquo;t made a descriptor before?
By this time next year you will have!</p>

<h2>The sale ends on Monday</h2>

<p>This sale will ends on <strong>Monday November 26</strong>, end of day.</p>

<p>To get an effective 50% discount on Python Morsels over the next 52 weeks, <a href="https://www.pythonmorsels.com/signup/">sign up to Python Morsels</a>, verify your email, go to the Account page, and subscribe to the <strong>52 Week Plan</strong>.</p>

<h2>Share this sale with friends and family</h2>

<p>If you have a friend or colleague who might benefit from weekly Python practice, let them know about this sale!
The BLACKFRIDAY coupon expires on Monday, but there&rsquo;s no limit on the number of signups, so there&rsquo;s no reason to keep this sale a secret.</p>

<p>So please share this email or the discount code with anyone you know who might find value in 52 weeks of Python skill-building.</p>

<h2>Frequently Asked Questions</h2>

<p>These are questions that I&rsquo;ve been asked at least once (that&rsquo;s apparently what &ldquo;frequently&rdquo; means now).</p>

<h4>Is this for someone who is brand new to programming?</h4>

<p>No, it isn&rsquo;t.
Python Morsels is for someone who has been using Python for a while and wants to improve their Python coding practices.
Many of the folks currently signed up write primarily Python code, but have a background in at least one other programming language.
However, there are a handful of folks who are signed up who would call Python their first and only programming language and I do try to accommodate folks in that camp as much as I can.</p>

<p>In general, I recommend Python Morsels for <strong>folks who are currently writing Python code regularly</strong>.</p>

<h4>How is Python Morsels different from a Python course?</h4>

<p>During my on-site trainings I&rsquo;m present as a live instructor and coach.
That&rsquo;s something you won&rsquo;t get from Python Morsels.
During online courses there are videos explaining each topic before it&rsquo;s practiced.
Python Morsels also doesn&rsquo;t have that.</p>

<p>The focus of Python Morsels is a bit different than a course or a training.
If you think of Python course as like taking a tennis class, Python Morsels is more like <strong>weekly tennis practice</strong>.
A Python Morsels subscriber described it to me as <strong>like Hannon&rsquo;s finger exercises for piano or Kreutzer&rsquo;s tudes for violin</strong>.
Python Morsels is guided <strong>deliberate practice</strong> in the domain of writing readable and maintainable Python code.</p>

<h4>How much time does this require each week?</h4>

<p>I expect that you&rsquo;ll spend <strong>about an hour each week on Python Morsels in total</strong>.</p>

<p>You&rsquo;re a busy person who has production code to write and I don&rsquo;t want to waste your time.
The exercise includes bonuses, but I don&rsquo;t expect you to solve them all each week: instead I want you to time box yourself.
I recommend that you set aside 30 minutes to solve the problem each week, including running the tests and solving as many bonuses as you can.
I&rsquo;d also like you to set aside 30 minutes to reflect on your code while reading the solution email I send each week.
I often link to related resources to read/watch, but I&rsquo;d like you to bookmark those for later.</p>

<p>If you have more than one hour to devote each week, you could sit on the solutions for a couple days and then resolve the exercise without looking at the solutions email.
I don&rsquo;t expect this though.</p>

<h4>What if the exercises are too easy for me and I don&rsquo;t learn anything new?</h4>

<p>If you find the exercises are too easy, email me and I&rsquo;ll see what I can do.
I&rsquo;ve developed quite a few exercises over the last year and I may be able to work with you to ensure the exercises you get are a good fit for your experience level.
If it turns out that Python Morsels simply isn&rsquo;t for you, I&rsquo;ll refund you.</p>

<h4>What if the exercises suddenly get too hard for me?</h4>

<p>If the exercises turn out to be too challenging for you, either immediately or eventually, email me.
I plan to create some easier tracks for Python Morsels eventually (there&rsquo;s certainly demand for this) and I may have some suitable exercises to send to you.
If Python Morsels doesn&rsquo;t suit your needs and I can&rsquo;t easily fix the problem, I&rsquo;ll send you a refund.</p>

<h2>Ready to start a weekly skill-building habit?</h2>

<p>Are you ready to start 52 weeks of Python skill-building for $96 (normally $192)?
That&rsquo;s less than $2/week and about one hour of your time each week (which really is the bigger cost here).</p>

<p>If you have questions that I didn&rsquo;t address above, please <a href="mailto:tr%65y%40&amp;#116;%72%75&amp;#116;%68%66u&amp;#108;&amp;#46;&amp;#116;&amp;#101;c%68&amp;#110;%6flo%67%79">email me</a> and say what you&rsquo;re thinking/feeling.</p>

<p>If you&rsquo;re interested in seeing the opinion of someone who has worked through Python Morsels exercises, see the testimonials <a href="https://www.pythonmorsels.com/">on the homepage</a> or take a look at what some of my Python Morsels friends have said about it on Twitter (<a href="https://twitter.com/AndrewsForge/status/1018597131496710144">Andrew Pinkham</a>, <a href="https://twitter.com/PavelAnni/status/963778202605932544">Pavel Anni</a>, <a href="https://twitter.com/jmwatt3/status/1035314897280794629">Jason Wattier</a>, <a href="https://twitter.com/abqpythonista/status/976202006405595136">Ben Jones</a>).</p>

<p>Ready to sign up?
<a href="https://www.pythonmorsels.com/signup/">Click here to get 52 weeks of Python Morsels at 50% off</a>.</p>
]]></content>
  </entry>
  
</feed>
